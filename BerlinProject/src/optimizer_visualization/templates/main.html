<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algorithm Visualization</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Socket.IO -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <!-- Highcharts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/11.2.0/highcharts.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/11.2.0/modules/stock.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/11.2.0/indicators/indicators.min.js"></script>

    <style>
        .config-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-panel {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            margin: 20px 0;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 10px;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-ready { background: #d1ecf1; color: #0c5460; }
        .status-loading { background: #fff3cd; color: #856404; }
        .status-running { background: #d1ecf1; color: #0c5460; }
        .status-paused { background: #f0ad4e; color: #fff; }
        .status-error { background: #f8d7da; color: #721c24; }

        .bar-charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .file-input-group {
            margin-bottom: 15px;
        }

        .file-input-group label {
            font-weight: 600;
            margin-bottom: 5px;
            display: block;
        }

        .config-summary {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
        }

        .optimization-progress {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .best-individuals-log {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.875rem;
        }

        .collapsible-section {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .collapsible-header {
            background: #f8f9fa;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #dee2e6;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-header:hover {
            background: #e9ecef;
        }

        .collapsible-content {
            padding: 15px;
            display: block;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        .collapse-icon {
            transition: transform 0.3s ease;
        }

        .collapse-icon.rotated {
            transform: rotate(180deg);
        }

        .metrics-table {
            font-size: 0.8rem;
            margin: 0;
        }

        .metrics-table th,
        .metrics-table td {
            padding: 6px 8px;
            text-align: center;
            border: 1px solid #dee2e6;
        }

        .metrics-table th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-optimization {
            min-width: 100px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <!-- Header -->
        <nav class="navbar navbar-dark bg-dark mb-4">
            <div class="container-fluid">
                <span class="navbar-brand mb-0 h1">
                    <i class="fas fa-chart-line me-2"></i>
                    Genetic Algorithm Visualization
                </span>
                <span id="appStatus" class="status-badge status-ready">Ready</span>
            </div>
        </nav>

        <!-- Configuration Panel -->
        <div class="collapsible-section">
            <div class="collapsible-header" onclick="toggleCollapse('configPanel')">
                <h3 class="mb-0">Configuration Setup</h3>
                <i class="fas fa-chevron-down collapse-icon" id="configPanel-icon"></i>
            </div>
            <div id="configPanel" class="collapsible-content">
                <div class="row">
                    <div class="col-md-6">
                        <div class="file-input-group">
                            <label for="gaConfigFile">Genetic Algorithm Monitor JSON</label>
                            <input type="file" class="form-control" id="gaConfigFile" accept=".json">
                            <div class="form-text">Select the genetic algorithm monitor configuration file</div>
                        </div>
                    </div>

                    <div class="col-md-6">
                        <div class="file-input-group">
                            <label for="dataConfigFile">Yahoo Finance Data Config</label>
                            <input type="file" class="form-control" id="dataConfigFile" accept=".json">
                            <div class="form-text">Select the Yahoo Finance data configuration file</div>
                        </div>
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-12">
                        <button id="loadConfigsBtn" class="btn btn-primary">
                            <i class="fas fa-upload me-2"></i>Load Configurations
                        </button>
                    </div>
                </div>

                <!-- Configuration Summary -->
                <div id="configSummary" class="config-summary" style="display: none;">
                    <h5>Configuration Summary</h5>
                    <div id="configDetails"></div>
                </div>
            </div>
        </div>

        <!-- Control Panel -->
        <div id="controlPanel" class="control-panel" style="display: none;">
            <h3 class="mb-3">Optimization Control</h3>

            <!-- Progress Information -->
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapse('optimizationProgress')">
                    <h5 class="mb-0">Progress Information</h5>
                    <i class="fas fa-chevron-down collapse-icon" id="optimizationProgress-icon"></i>
                </div>
                <div id="optimizationProgress" class="collapsible-content" style="display: none;">
                    <div class="progress-info">
                        <h5 id="testName">Test: Loading...</h5>
                        <span id="generationInfo">Generation 0 / 0</span>
                    </div>
                    <div class="progress mb-3">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                            0%
                        </div>
                    </div>

                    <!-- Objectives Chart and Metrics Table -->
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <h6>Optimization Progress - Objective Functions:</h6>
                            <div id="objectivesChart" style="height: 800px; border: 1px solid #dee2e6; border-radius: 4px; background: white;"></div>
                        </div>
                        <div class="col-md-6">
                            <h6>Generation Metrics Summary:</h6>
                            <div class="table-container">
                                <table class="table table-sm metrics-table">
                                    <thead>
                                        <tr>
                                            <th>Gen</th>
                                            <th>Total Trades</th>
                                            <th>Winning</th>
                                            <th>Losing</th>
                                            <th>Total P&L (%)</th>
                                            <th>Avg Win (%)</th>
                                            <th>Avg Loss (%)</th>
                                        </tr>
                                    </thead>
                                    <tbody id="metricsTableBody">
                                        <tr>
                                            <td colspan="7" class="text-muted">No data yet...</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md-6">
                            <h6>Current Best Individual Metrics:</h6>
                            <div id="currentMetrics" class="small text-muted">No data yet...</div>
                        </div>
                        <div class="col-md-6">
                            <h6>Best Individuals Log:</h6>
                            <div id="bestIndividualsLog" class="best-individuals-log" style="height: 200px;">
                                <div class="text-muted">Optimization not started...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Control Buttons -->
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapse('controlButtons')">
                    <h5 class="mb-0">Control Buttons</h5>
                    <i class="fas fa-chevron-down collapse-icon" id="controlButtons-icon"></i>
                </div>
                <div id="controlButtons" class="collapsible-content">
                    <div class="control-buttons">
                        <button id="startBtn" class="btn btn-success btn-optimization">
                            <i class="fas fa-play me-2"></i>Start
                        </button>
                        <button id="pauseBtn" class="btn btn-warning btn-optimization" style="display: none;">
                            <i class="fas fa-pause me-2"></i>Pause
                        </button>
                        <button id="resumeBtn" class="btn btn-info btn-optimization" style="display: none;">
                            <i class="fas fa-play me-2"></i>Resume
                        </button>
                        <button id="stopBtn" class="btn btn-danger btn-optimization" style="display: none;">
                            <i class="fas fa-stop me-2"></i>Stop
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Section -->
        <div id="chartsSection" style="display: none;">
            <!-- Candlestick Chart -->
            <div class="chart-container">
                <h4>Price Chart with Signals</h4>
                <div id="candlestickChart" style="height: 500px;"></div>
            </div>

            <!-- P&L Chart -->
            <div class="chart-container">
                <h4>Portfolio P&L</h4>
                <div id="pnlChart" style="height: 300px;"></div>
            </div>

            <!-- Bar Scores Grid -->
            <div id="barScoresContainer" class="bar-charts-grid">
                <!-- Bar score charts will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Initialize Socket.IO
        const socket = io();

        // Global variables
        let uploadedFiles = {};
        let optimizationRunning = false;
        let charts = {};
        let generationMetrics = []; // Store metrics for each generation

        // Collapsible section toggle function
        function toggleCollapse(sectionId) {
            const content = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + '-icon');

            if (content.classList.contains('collapsed') || content.style.display === 'none') {
                content.classList.remove('collapsed');
                content.style.display = 'block';
                icon.classList.remove('rotated');
            } else {
                content.classList.add('collapsed');
                content.style.display = 'none';
                icon.classList.add('rotated');
            }
        }

        // Update metrics table with generation data
        function updateMetricsTable(generation, chartData) {
            const tableBody = document.getElementById('metricsTableBody');

            // Calculate trade metrics
            const trades = chartData.trade_history || [];
            const totalTrades = trades.length;

            // Separate winning and losing trades based on P&L
            const completedTrades = chartData.pnl_history || [];
            let winningTrades = 0;
            let losingTrades = 0;
            let totalWinPnL = 0;
            let totalLossPnL = 0;

            completedTrades.forEach(trade => {
                if (trade.trade_pnl > 0) {
                    winningTrades++;
                    totalWinPnL += trade.trade_pnl;
                } else if (trade.trade_pnl < 0) {
                    losingTrades++;
                    totalLossPnL += trade.trade_pnl;
                }
            });

            const totalPnL = completedTrades.length > 0
                ? completedTrades[completedTrades.length - 1].cumulative_pnl
                : 0;

            const avgWin = winningTrades > 0 ? totalWinPnL / winningTrades : 0;
            const avgLoss = losingTrades > 0 ? totalLossPnL / losingTrades : 0;

            // Store metrics for this generation
            const generationData = {
                generation,
                totalTrades,
                winningTrades,
                losingTrades,
                totalPnL,
                avgWin,
                avgLoss
            };

            // Update or add to generationMetrics array
            const existingIndex = generationMetrics.findIndex(g => g.generation === generation);
            if (existingIndex >= 0) {
                generationMetrics[existingIndex] = generationData;
            } else {
                generationMetrics.push(generationData);
            }

            // Sort by generation
            generationMetrics.sort((a, b) => a.generation - b.generation);

            // Rebuild table
            if (generationMetrics.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="7" class="text-muted">No data yet...</td></tr>';
                return;
            }

            const tableRows = generationMetrics.map(data => `
                <tr>
                    <td><strong>${data.generation}</strong></td>
                    <td>${data.totalTrades}</td>
                    <td class="text-success">${data.winningTrades}</td>
                    <td class="text-danger">${data.losingTrades}</td>
                    <td class="${data.totalPnL >= 0 ? 'text-success' : 'text-danger'}">${data.totalPnL.toFixed(2)}%</td>
                    <td class="text-success">${data.avgWin.toFixed(2)}%</td>
                    <td class="text-danger">${data.avgLoss.toFixed(2)}%</td>
                </tr>
            `).join('');

            tableBody.innerHTML = tableRows;

            // Scroll to latest entry
            const tableContainer = document.querySelector('.table-container');
            tableContainer.scrollTop = tableContainer.scrollHeight;
        }

        // Socket event handlers
        socket.on('connect', function() {
            console.log('Connected to server');
            updateStatus('Ready', 'ready');
        });

        socket.on('optimization_started', function(data) {
            console.log('Optimization started:', data);
            optimizationRunning = true;
            updateStatus('Running', 'running');

            document.getElementById('testName').textContent = `Test: ${data.test_name}`;
            document.getElementById('generationInfo').textContent = `Generation 0 / ${data.total_generations}`;
            document.getElementById('optimizationProgress').style.display = 'block';

            // Clear previous data
            generationMetrics = [];
            document.getElementById('metricsTableBody').innerHTML = '<tr><td colspan="7" class="text-muted">Starting optimization...</td></tr>';

            // Update button states
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'inline-block';

            // Clear previous data
            document.getElementById('bestIndividualsLog').innerHTML = '<div class="text-muted">Starting optimization...</div>';
        });

        socket.on('generation_complete', function(data) {
            console.log('Generation complete:', data);

            // Update progress
            const progress = (data.generation / data.total_generations) * 100;
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = `${Math.round(progress)}%`;
            progressBar.setAttribute('aria-valuenow', progress);

            document.getElementById('generationInfo').textContent = `Generation ${data.generation} / ${data.total_generations}`;

            // Update current metrics
            const metricsText = Object.entries(data.fitness_metrics)
                .map(([key, value]) => `${key}: ${value.toFixed(4)}`)
                .join(', ');
            document.getElementById('currentMetrics').textContent = metricsText;

            // Update best individuals log
            updateBestIndividualsLog(data.best_individuals_log);

            // Update charts with new data
            updateCharts(data.chart_data);

            // Update objectives chart
            updateObjectivesChart(data.best_individuals_log);

            // Update metrics table
            updateMetricsTable(data.generation, data.chart_data);

            // Show charts section
            document.getElementById('chartsSection').style.display = 'block';

            // Show charts section
            document.getElementById('chartsSection').style.display = 'block';
        });

        socket.on('optimization_complete', function(data) {
            console.log('Optimization complete:', data);
            optimizationRunning = false;
            updateStatus('Complete', 'ready');

            // Update button states
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('resumeBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'none';
        });

        socket.on('optimization_paused', function(data) {
            console.log('Optimization paused:', data);
            updateStatus(`Paused at Generation ${data.generation}`, 'paused');

            // Update button states
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('resumeBtn').style.display = 'inline-block';
        });

        socket.on('optimization_resumed', function(data) {
            console.log('Optimization resumed:', data);
            updateStatus('Running', 'running');

            // Update button states
            document.getElementById('pauseBtn').style.display = 'inline-block';
            document.getElementById('resumeBtn').style.display = 'none';
        });

        socket.on('optimization_stopped', function(data) {
            console.log('Optimization stopped:', data);
            optimizationRunning = false;
            updateStatus('Stopped', 'ready');

            // Update button states
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('resumeBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'none';
        });

        socket.on('optimization_error', function(data) {
            console.error('Optimization error:', data);
            optimizationRunning = false;
            updateStatus('Error', 'error');

            // Update button states
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('resumeBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'none';

            alert(`Optimization Error: ${data.error}`);
        });

        // Button event handlers
        document.getElementById('startBtn').addEventListener('click', function() {
            if (!uploadedFiles.ga_config || !uploadedFiles.data_config) {
                alert('Please load both configuration files first.');
                return;
            }

            socket.emit('start_optimization', {
                ga_config_path: uploadedFiles.ga_config,
                data_config_path: uploadedFiles.data_config
            });
        });

        document.getElementById('pauseBtn').addEventListener('click', function() {
            socket.emit('pause_optimization');
        });

        document.getElementById('resumeBtn').addEventListener('click', function() {
            socket.emit('resume_optimization');
        });

        document.getElementById('stopBtn').addEventListener('click', function() {
            if (confirm('Are you sure you want to stop the optimization?')) {
                socket.emit('stop_optimization');
            }
        });

        // File upload handlers
        document.getElementById('gaConfigFile').addEventListener('change', async function(e) {
            if (e.target.files.length > 0) {
                await uploadFile(e.target.files[0], 'ga_config');
            }
        });

        document.getElementById('dataConfigFile').addEventListener('change', async function(e) {
            if (e.target.files.length > 0) {
                await uploadFile(e.target.files[0], 'data_config');
            }
        });

        document.getElementById('loadConfigsBtn').addEventListener('click', async function() {
            if (!uploadedFiles.ga_config || !uploadedFiles.data_config) {
                alert('Please select both configuration files first.');
                return;
            }

            await loadConfigurations();
        });

        // Helper functions
        function updateStatus(text, type) {
            const statusElement = document.getElementById('appStatus');
            statusElement.textContent = text;
            statusElement.className = `status-badge status-${type}`;
        }

        function updateBestIndividualsLog(logData) {
            const logContainer = document.getElementById('bestIndividualsLog');

            if (!logData || logData.length === 0) {
                logContainer.innerHTML = '<div class="text-muted">No data yet...</div>';
                return;
            }

            const logHtml = logData.map(entry => {
                const metricsText = Object.entries(entry.metrics)
                    .map(([key, value]) => `${key}=${value.toFixed(4)}`)
                    .join(', ');
                return `<div>Gen ${entry.generation}: ${metricsText}</div>`;
            }).join('');

            logContainer.innerHTML = logHtml;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        async function uploadFile(file, type) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('type', type);

            try {
                updateStatus('Uploading...', 'loading');
                const response = await fetch('/api/upload_file', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    uploadedFiles[type] = result.filepath;
                    console.log(`${type} uploaded:`, result.filepath);
                    updateStatus('Ready', 'ready');
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Upload error:', error);
                updateStatus('Error', 'error');
                alert(`Upload failed: ${error.message}`);
            }
        }

        async function loadConfigurations() {
            try {
                updateStatus('Loading configs...', 'loading');

                const response = await fetch('/api/load_configs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        ga_config_path: uploadedFiles.ga_config,
                        data_config_path: uploadedFiles.data_config
                    })
                });

                const result = await response.json();

                if (result.success) {
                    displayConfigSummary(result);
                    document.getElementById('controlPanel').style.display = 'block';
                    updateStatus('Ready', 'ready');
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Config loading error:', error);
                updateStatus('Error', 'error');
                alert(`Failed to load configurations: ${error.message}`);
            }
        }

        function displayConfigSummary(configData) {
            const summaryElement = document.getElementById('configDetails');
            const gaConfig = configData.ga_config;
            const dataConfig = configData.data_config;

            summaryElement.innerHTML = `
                <div class="row">
                    <div class="col-md-6">
                        <h6>Genetic Algorithm Config</h6>
                        <ul class="list-unstyled small">
                            <li><strong>Test Name:</strong> ${gaConfig.test_name}</li>
                            <li><strong>Generations:</strong> ${gaConfig.genetic_algorithm?.number_of_generations || 'Not specified'}</li>
                            <li><strong>Population:</strong> ${gaConfig.genetic_algorithm?.population_size || 'Not specified'}</li>
                        </ul>
                    </div>
                    <div class="col-md-6">
                        <h6>Data Config</h6>
                        <ul class="list-unstyled small">
                            <li><strong>Ticker:</strong> ${dataConfig.ticker}</li>
                            <li><strong>Start:</strong> ${dataConfig.start_date}</li>
                            <li><strong>End:</strong> ${dataConfig.end_date}</li>
                        </ul>
                    </div>
                </div>
            `;

            document.getElementById('configSummary').style.display = 'block';
        }

        function updateCharts(chartData) {
            console.log('Updating charts with data:', chartData);

            // Update candlestick chart
            updateCandlestickChart(chartData);

            // Update P&L chart
            updatePnLChart(chartData);

            // Update bar scores charts
            updateBarScoresCharts(chartData);

            // Show charts section
            document.getElementById('chartsSection').style.display = 'block';
        }

        // Global function to sync all charts when one is zoomed (excluding objectives chart)
        function syncAllCharts(extremes, sourceChart) {
            if (!extremes || extremes.trigger === 'syncExtremes') return;

            try {
                // Don't sync objectives chart since it has different x-axis (generations vs time)
                if (sourceChart === 'objectives') return;

                // Sync candlestick chart
                if (charts.candlestick && sourceChart !== 'candlestick') {
                    charts.candlestick.xAxis[0].setExtremes(extremes.min, extremes.max, true, false, { trigger: 'syncExtremes' });
                }

                // Sync P&L chart
                if (charts.pnl && sourceChart !== 'pnl') {
                    charts.pnl.xAxis[0].setExtremes(extremes.min, extremes.max, true, false, { trigger: 'syncExtremes' });
                }

                // Sync all bar score charts
                Object.keys(charts).forEach(chartKey => {
                    if (chartKey.startsWith('barChart_') && sourceChart !== chartKey && charts[chartKey]) {
                        charts[chartKey].xAxis[0].setExtremes(extremes.min, extremes.max, true, false, { trigger: 'syncExtremes' });
                    }
                });
            } catch (error) {
                console.warn('Error syncing charts:', error);
            }
        }

        function updateObjectivesChart(bestIndividualsLog) {
            const container = document.getElementById('objectivesChart');

            if (!bestIndividualsLog || bestIndividualsLog.length === 0) {
                container.innerHTML = '<div class="alert alert-info">No objectives data available</div>';
                return;
            }

            // Extract objective names from the first entry
            const objectiveNames = Object.keys(bestIndividualsLog[0].metrics);

            // Prepare series data for each objective
            const series = objectiveNames.map(objName => {
                const data = bestIndividualsLog.map(entry => [entry.generation, entry.metrics[objName]]);

                // Assign colors based on objective type
                let color = '#2196F3'; // Default blue
                if (objName.toLowerCase().includes('profit')) {
                    color = '#00C851'; // Green for profit
                } else if (objName.toLowerCase().includes('loss')) {
                    color = '#ff4444'; // Red for loss
                } else if (objName.toLowerCase().includes('losing')) {
                    color = '#ff9800'; // Orange for losing trades
                }

                return {
                    name: objName,
                    data: data,
                    color: color,
                    lineWidth: 2,
                    marker: {
                        enabled: true,
                        radius: 4
                    }
                };
            });

            const chartConfig = {
                chart: {
                    type: 'line'
                },
                title: {
                    text: 'Objective Functions Evolution'
                },
                xAxis: {
                    title: {
                        text: 'Generation'
                    },
                    min: 1,
                    tickInterval: 1,
                    events: {
                        afterSetExtremes: function(e) {
                            syncAllCharts(e, 'objectives');
                        }
                    }
                },
                yAxis: {
                    title: {
                        text: 'Objective Value'
                    }
                },
                tooltip: {
                    shared: true,
                    crosshairs: true,
                    pointFormat: '<b>{series.name}:</b> {point.y:.4f}<br/>'
                },
                legend: {
                    enabled: true,
                    align: 'bottom'
                },
                series: series,
                plotOptions: {
                    line: {
                        connectNulls: false,
                        marker: {
                            enabled: true
                        }
                    }
                }
            };

            if (charts.objectives) {
                charts.objectives.destroy();
            }
            charts.objectives = Highcharts.chart(container, chartConfig);
        }

        function updateCandlestickChart(data) {
            const container = document.getElementById('candlestickChart');

            // Prepare candlestick data - already in correct format [timestamp, open, high, low, close]
            const candlestickData = data.candlestick_data;

            // Process trade_history to create entry/exit arrows
            const buyArrows = [];
            const sellArrows = [];

            if (data.triggers && data.triggers.length > 0) {
                data.triggers.forEach(trigger => {
                    if (trigger.type === 'buy') {
                        buyArrows.push({
                            x: trigger.timestamp,
                            y: trigger.price,
                            reason: trigger.reason,
                            price: trigger.price
                        });
                    } else if (trigger.type === 'sell') {
                        sellArrows.push({
                            x: trigger.timestamp,
                            y: trigger.price,
                            reason: trigger.reason,
                            price: trigger.price
                        });
                    }
                });
            }

            const chartConfig = {
                chart: {
                    zoomType: 'xy', // Enable box zoom on both axes
                    panning: {
                        enabled: true,
                        type: 'xy'
                    },
                    panKey: 'shift' // Hold shift to pan instead of zoom
                },
                title: {
                    text: `${data.ticker} - Price with Trade Entry/Exit Arrows`
                },

                rangeSelector: {
                    selected: 1
                },

                // FORCE NO DATA GROUPING - This is the key fix!
                plotOptions: {
                    candlestick: {
                        dataGrouping: {
                            enabled: false
                        }
                    },
                    scatter: {
                        dataGrouping: {
                            enabled: false
                        }
                    }
                },

                yAxis: [{
                    labels: {
                        align: 'right',
                        x: -3
                    },
                    title: {
                        text: 'Price ($)'
                    },
                    height: '100%',
                    lineWidth: 2
                }],

                // Add event handlers for zoom synchronization
                xAxis: {
                    events: {
                        afterSetExtremes: function(e) {
                            syncAllCharts(e, 'candlestick');
                        }
                    }
                },

                tooltip: {
                    split: false,
                    shared: true
                },

                series: [{
                    type: 'candlestick',
                    name: data.ticker,
                    data: candlestickData,
                    yAxis: 0,
                    dataGrouping: {
                        enabled: false
                    },
                    // Set proper candlestick colors
                    color: '#ff4444', // Red for down candles
                    upColor: '#00C851', // Green for up candles
                    lineColor: '#ff4444', // Red border for down candles
                    upLineColor: '#00C851' // Green border for up candles
                }, {
                    type: 'scatter',
                    name: 'Buy Signals',
                    data: buyArrows,
                    color: 'green',
                    marker: {
                        symbol: 'triangle',
                        radius: 8
                    },
                    yAxis: 0,
                    dataGrouping: {
                        enabled: false
                    },
                    tooltip: {
                        pointFormat: '<b>BUY:</b> ${point.y:.2f}<br/><b>Reason:</b> {point.reason}'
                    }
                }, {
                    type: 'scatter',
                    name: 'Sell Signals',
                    data: sellArrows,
                    color: 'red',
                    marker: {
                        symbol: 'triangle-down',
                        radius: 8
                    },
                    yAxis: 0,
                    dataGrouping: {
                        enabled: false
                    },
                    tooltip: {
                        pointFormat: '<b>SELL:</b> ${point.y:.2f}<br/><b>Reason:</b> {point.reason}'
                    }
                }]
            };

            if (charts.candlestick) {
                charts.candlestick.destroy();
            }
            charts.candlestick = Highcharts.stockChart(container, chartConfig);
        }

        function updatePnLChart(data) {
            const container = document.getElementById('pnlChart');

            // Prepare P&L data
            const pnlData = data.pnl_history.map(point => [
                point.timestamp,
                point.cumulative_pnl
            ]);

            const chartConfig = {
                title: {
                    text: `Portfolio Performance - Cumulative P&L`
                },

                rangeSelector: {
                    selected: 1
                },

                plotOptions: {
                    line: {
                        dataGrouping: {
                            enabled: false  // Disable grouping
                        }
                    }
                },

                yAxis: {
                    title: {
                        text: 'Cumulative P&L (%)'
                    },
                    plotLines: [{
                        value: 0,
                        color: 'gray',
                        dashStyle: 'dash',
                        width: 1,
                        label: {
                            text: 'Break Even',
                            align: 'right'
                        }
                    }]
                },

                // Add event handlers for zoom synchronization
                xAxis: {
                    events: {
                        afterSetExtremes: function(e) {
                            syncAllCharts(e, 'pnl');
                        }
                    }
                },

                tooltip: {
                    pointFormat: '<b>P&L:</b> {point.y:.2f}%'
                },

                series: [{
                    name: 'Cumulative P&L',
                    data: pnlData,
                    color: '#2E86AB',
                    lineWidth: 2,
                    marker: {
                        enabled: true,
                        radius: 3,
                        fillColor: '#2E86AB'
                    },
                    dataGrouping: {
                        enabled: false
                    }
                }]
            };

            if (charts.pnl) {
                charts.pnl.destroy();
            }
            charts.pnl = Highcharts.stockChart(container, chartConfig);
        }

        function updateBarScoresCharts(data) {
            const container = document.getElementById('barScoresContainer');

            // Clear existing bar score charts
            container.innerHTML = '';

            if (!data.bar_scores_history || data.bar_scores_history.length === 0) {
                container.innerHTML = '<div class="col-12"><div class="alert alert-info">No bar scores data available</div></div>';
                return;
            }

            // Create charts for each bar score type
            const barScoreTypes = new Set();
            data.bar_scores_history.forEach(point => {
                Object.keys(point.scores).forEach(type => barScoreTypes.add(type));
            });

            barScoreTypes.forEach(type => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                chartDiv.innerHTML = `
                    <h5>Bar Scores: ${type}</h5>
                    <div id="barChart_${type.replace(/[^a-zA-Z0-9]/g, '_')}" style="height: 300px;"></div>
                `;
                container.appendChild(chartDiv);

                // Prepare data for this bar score type
                const barData = data.bar_scores_history
                    .filter(point => point.scores[type] !== undefined)
                    .map(point => [point.timestamp, point.scores[type]]);

                // Find thresholds for this bar from enter_long and exit_long conditions
                const plotLines = [];

                // Check enter_long conditions (typically bull bars)
                if (data.threshold_config && data.threshold_config.enter_long) {
                    data.threshold_config.enter_long.forEach(condition => {
                        if (condition.name === type) {
                            plotLines.push({
                                value: condition.threshold,
                                color: '#00C851', // Green for entry threshold
                                dashStyle: 'dash',
                                width: 2,
                                label: {
                                    text: `Entry: ${condition.threshold}`,
                                    align: 'right',
                                    style: {
                                        color: '#00C851',
                                        fontWeight: 'bold'
                                    }
                                },
                                zIndex: 5
                            });
                        }
                    });
                }

                // Check exit_long conditions (typically bear bars)
                if (data.threshold_config && data.threshold_config.exit_long) {
                    data.threshold_config.exit_long.forEach(condition => {
                        if (condition.name === type) {
                            plotLines.push({
                                value: condition.threshold,
                                color: '#ff4444', // Red for exit threshold
                                dashStyle: 'dash',
                                width: 2,
                                label: {
                                    text: `Exit: ${condition.threshold}`,
                                    align: 'right',
                                    style: {
                                        color: '#ff4444',
                                        fontWeight: 'bold'
                                    }
                                },
                                zIndex: 5
                            });
                        }
                    });
                }

                const chartConfig = {
                    title: {
                        text: `${type} Bar Scores Evolution`
                    },

                    rangeSelector: {
                        selected: 1
                    },

                    plotOptions: {
                        line: {
                            dataGrouping: {
                                enabled: false
                            }
                        }
                    },

                    yAxis: {
                        title: {
                            text: 'Score'
                        },
                        plotLines: plotLines, // Add threshold lines here
                        min: 0,
                        max: 1
                    },

                    // Add event handlers for zoom synchronization
                    xAxis: {
                        events: {
                            afterSetExtremes: function(e) {
                                syncAllCharts(e, chartId);
                            }
                        }
                    },

                    tooltip: {
                        pointFormat: '<b>{series.name}:</b> {point.y:.4f}<br/>',
                        shared: true
                    },

                    series: [{
                        name: type,
                        data: barData,
                        color: '#FF6B6B',
                        lineWidth: 2,
                        dataGrouping: {
                            enabled: false
                        }
                    }]
                };

                const chartId = `barChart_${type.replace(/[^a-zA-Z0-9]/g, '_')}`;
                charts[chartId] = Highcharts.stockChart(chartId, chartConfig);
            });
        }
    </script>
</body>
</html>