<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitor Replay Visualization - Dynamic Configuration</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Highcharts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/11.2.0/highcharts.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/11.2.0/modules/stock.min.js"></script>

    <!-- Shared form components -->
    <link rel="stylesheet" href="/static/css/config-form-builder.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/compact-monitor-form.css') }}">
    
    <!-- Indicator Chart Component -->
    <script src="/static/js/indicator-chart-component.js"></script>

    <style>
        .navbar-custom {
            padding: 20px 0;
            min-height: 80px;
        }

        .navbar-brand-custom {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
        }

        .logo-img {
            height: 150px;
            width: auto;
            margin-right: 15px;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-ready { background: #d1ecf1; color: #0c5460; }
        .status-loading { background: #fff3cd; color: #856404; }
        .status-running { background: #d1ecf1; color: #0c5460; }
        .status-error { background: #f8d7da; color: #721c24; }

        .collapsible-section {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .collapsible-header {
            background: #f8f9fa;
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #dee2e6;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .collapsible-header:hover {
            background: #e9ecef;
        }

        .collapsible-content {
            padding: 10px;
            display: block;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        /* Compact configuration form */
        .config-actions {
            background: #f8f9fa;
            padding: 0.75rem;
            border-radius: 0.375rem;
            margin-bottom: 0.75rem;
        }

        .configuration-tabs {
            margin-bottom: 1rem;
        }

        .tab-content {
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            padding: 0.75rem;
            background: #fff;
        }

        .action-buttons {
            margin: 0.5rem 0;
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }

        /* Make form elements more compact */
        .form-group {
            margin-bottom: 0.5rem;
        }

        .form-control {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }

        .form-label {
            font-size: 0.825rem;
            margin-bottom: 0.25rem;
            font-weight: 600;
        }

        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.775rem;
        }

        .collapse-icon {
            transition: transform 0.3s ease;
        }

        .collapse-icon.rotated {
            transform: rotate(180deg);
        }

        .configuration-tabs {
            margin-bottom: 2rem;
        }

        .tab-content {
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            padding: 1.5rem;
            background: #fff;
        }

        .action-buttons {
            margin: 1rem 0;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .config-actions {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
        }

        .results-section {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .chart-container {
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 15px 0;
        }

        .metrics-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .metric-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007bff;
        }

        .metric-label {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 5px;
        }

        .positive { color: #28a745 !important; }
        .negative { color: #dc3545 !important; }

        /* Responsive improvements */
        @media (max-width: 768px) {
            .navbar-brand-custom {
                font-size: 1.2rem;
            }
            
            .logo-img {
                height: 100px;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .chart-container {
                height: 300px !important;
            }
            
            #pnlChart.chart-container {
                height: 250px !important;
            }
        }

        @media (max-width: 576px) {
            .navbar-brand-custom {
                font-size: 1rem;
            }
            
            .logo-img {
                height: 80px;
                margin-right: 8px;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .btn-sm {
                width: 100%;
                margin-bottom: 0.25rem;
            }
        }

        /* Enhanced chart styling */
        .chart-container {
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background: white;
        }

        /* Improved metrics display */
        .metrics-display {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .metric-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .metric-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <!-- Header -->
        <nav class="navbar navbar-dark bg-dark mb-4 navbar-custom">
            <div class="container-fluid">
                <span class="navbar-brand mb-0 navbar-brand-custom">
                    <img src="/static/mlf_logo.png" alt="Logo" class="logo-img">
                    Monitor Replay Visualization - Dynamic Configuration
                </span>
                <span id="appStatus" class="status-badge status-ready">Ready</span>
            </div>
        </nav>

        <!-- Configuration Panel -->
        <div class="collapsible-section">
            <div class="collapsible-header" onclick="toggleCollapse('configPanel')">
                <h3 class="mb-0"><i class="fas fa-cogs"></i> Configuration Setup</h3>
                <i class="fas fa-chevron-down collapse-icon" id="configPanel-icon"></i>
            </div>
            <div id="configPanel" class="collapsible-content">
                
                <!-- Configuration Actions -->
                <div class="config-actions">
                    <h5><i class="fas fa-file-upload"></i> Load Configuration Files</h5>
                    <div class="row">
                        <div class="col-md-4">
                            <label for="monitorConfigFile" class="form-label">Monitor Configuration JSON</label>
                            <input type="file" class="form-control" id="monitorConfigFile" accept=".json">
                        </div>
                        <div class="col-md-4">
                            <label for="dataConfigFile" class="form-label">Data Configuration JSON</label>
                            <input type="file" class="form-control" id="dataConfigFile" accept=".json">
                        </div>
                        <div class="col-md-4 d-flex align-items-end">
                            <button id="loadFilesBtn" class="btn btn-primary">
                                <i class="fas fa-upload"></i> Load Files
                            </button>
                            <button id="loadExampleBtn" class="btn btn-outline-secondary ms-2">
                                <i class="fas fa-star"></i> Load Example
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Configuration Tabs -->
                <div class="configuration-tabs">
                    <ul class="nav nav-tabs" id="configTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="monitor-config-tab" data-bs-toggle="tab" data-bs-target="#monitor-config" type="button" role="tab">
                                <i class="fas fa-chart-area"></i> Monitor Configuration
                            </button>
                        </li>
                    </ul>
                    
                    <div class="tab-content" id="configTabContent">
                        <!-- Monitor Configuration Form -->
                        <div class="tab-pane fade show active" id="monitor-config" role="tabpanel">
                            <div id="compactMonitorFormContainer">
                                <div class="text-center text-muted py-5">
                                    <i class="fas fa-upload fa-3x mb-3"></i>
                                    <p>Load a monitor configuration file or click "Load Example" to get started</p>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>

                <!-- Run Visualization Button -->
                <div class="text-center">
                    <button id="runVisualizationBtn" class="btn btn-success btn-lg" disabled>
                        <i class="fas fa-play"></i> Run Monitor Visualization
                    </button>
                </div>
            </div>
        </div>

        <!-- Results Panel -->
        <div id="resultsPanel" class="collapsible-section" style="display: none;">
            <div class="collapsible-header" onclick="toggleCollapse('visualizationResults')">
                <h3 class="mb-0"><i class="fas fa-chart-line"></i> Visualization Results</h3>
                <i class="fas fa-chevron-down collapse-icon" id="visualizationResults-icon"></i>
            </div>
            <div id="visualizationResults" class="collapsible-content">
                <!-- Strategy Overview -->
                <div class="row mb-4">
                    <div class="col-md-12">
                        <h5><i class="fas fa-info-circle"></i> Strategy Overview</h5>
                        <div id="strategyOverview" class="metrics-display">
                            <div class="row">
                                <div class="col-md-6">
                                    <strong>Strategy Name:</strong> <span id="strategyName">-</span><br>
                                    <strong>Description:</strong> <span id="strategyDescription">-</span><br>
                                    <strong>Symbol:</strong> <span id="dataTicker">-</span>
                                </div>
                                <div class="col-md-6">
                                    <strong>Date Range:</strong> <span id="dateRange">-</span><br>
                                    <strong>Total Indicators:</strong> <span id="totalIndicators">-</span><br>
                                    <strong>Entry Conditions:</strong> <span id="entryConditions">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Key Metrics -->
                <div class="row mb-4">
                    <div class="col-md-12">
                        <h5><i class="fas fa-calculator"></i> Performance Metrics</h5>
                        <div id="keyMetrics" class="metrics-grid">
                            <div class="metric-item">
                                <div class="metric-value" id="totalTrades">-</div>
                                <div class="metric-label">Total Trades</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value positive" id="winningTrades">-</div>
                                <div class="metric-label">Winning Trades</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value negative" id="losingTrades">-</div>
                                <div class="metric-label">Losing Trades</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" id="winRate">-</div>
                                <div class="metric-label">Win Rate</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" id="totalPnL">-</div>
                                <div class="metric-label">Total P&L (%)</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value positive" id="avgWin">-</div>
                                <div class="metric-label">Avg Win (%)</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value negative" id="avgLoss">-</div>
                                <div class="metric-label">Avg Loss (%)</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" id="profitFactor">-</div>
                                <div class="metric-label">Profit Factor</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Enhanced Indicator Charts -->
                <div class="row">
                    <div class="col-12">
                        <h6><i class="fas fa-chart-line"></i> Interactive Price & Indicator Charts</h6>
                        <div id="indicatorChartsContainer">
                            <div class="text-center text-muted d-flex align-items-center justify-content-center" style="height: 200px;">
                                <i class="fas fa-chart-line me-2"></i>Load configuration and run visualization to see interactive charts
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <h6><i class="fas fa-coins"></i> P&L Evolution Chart</h6>
                        <div id="pnlChart" class="chart-container" style="height: 300px;">
                            <div class="text-center text-muted d-flex align-items-center justify-content-center h-100">
                                <i class="fas fa-coins me-2"></i>P&L chart will appear here after running visualization
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Trade History Table -->
                <div class="row mt-4">
                    <div class="col-md-12">
                        <h6><i class="fas fa-list"></i> Trade History</h6>
                        <div class="table-responsive" style="max-height: 400px; overflow-y: auto;">
                            <table class="table table-sm table-striped">
                                <thead class="table-dark">
                                    <tr>
                                        <th>Date</th>
                                        <th>Type</th>
                                        <th>Price</th>
                                        <th>Size</th>
                                        <th>P&L</th>
                                        <th>Cumulative P&L</th>
                                        <th>Signal</th>
                                    </tr>
                                </thead>
                                <tbody id="tradeHistoryTable">
                                    <tr>
                                        <td colspan="7" class="text-center text-muted">No trades to display</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Shared form components -->
    <script src="/static/js/indicator-parameter-definitions.js"></script>
    <script src="/static/js/config-form-builder.js"></script>
    <script src="/static/js/data-config-form.js"></script>
    <script src="{{ url_for('static', filename='js/compact-monitor-form.js') }}"></script>

    <script>
        // Global variables
        let uploadedFiles = {};
        let charts = {};

        // Form builders
        let compactMonitorForm = null;

        // Configuration data
        let currentMonitorConfig = null;
        let currentDataConfig = null;
        
        // Indicator Chart Component
        let indicatorChartComponent = null;
        
        // Chart synchronization function
        function syncAllCharts(min, max, sourceChart) {
            // Check for valid min/max values
            if (!min || !max || isNaN(min) || isNaN(max)) {
                console.warn('Invalid min/max values for chart sync:', min, max, 'from:', sourceChart);
                return;
            }
            
            console.log(`Syncing all charts from ${sourceChart} to range:`, new Date(min), new Date(max));
            
            try {
                // Sync price chart
                if (charts.price && sourceChart !== 'price') {
                    charts.price.xAxis[0].setExtremes(min, max, true, false, {trigger: 'syncExtremes'});
                }
                
                // Sync P&L chart
                if (charts.pnl && sourceChart !== 'pnl') {
                    charts.pnl.xAxis[0].setExtremes(min, max, true, false, {trigger: 'syncExtremes'});
                }
                
                // Sync indicator charts
                if (indicatorChartComponent && indicatorChartComponent.charts) {
                    Object.keys(indicatorChartComponent.charts).forEach(chartKey => {
                        const chart = indicatorChartComponent.charts[chartKey];
                        if (chart && chart.xAxis && chart.xAxis[0] && sourceChart !== chartKey) {
                            try {
                                chart.xAxis[0].setExtremes(min, max, true, false, {trigger: 'syncExtremes'});
                            } catch (e) {
                                console.log(`Could not sync chart ${chartKey}:`, e.message);
                            }
                        }
                    });
                }
            } catch (e) {
                console.error('Error syncing charts:', e);
            }
        }

        // Collapsible section toggle function
        function toggleCollapse(sectionId) {
            const content = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + '-icon');

            if (content.classList.contains('collapsed') || content.style.display === 'none') {
                content.classList.remove('collapsed');
                content.style.display = 'block';
                icon.classList.remove('rotated');
            } else {
                content.classList.add('collapsed');
                content.style.display = 'none';
                icon.classList.add('rotated');
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // File upload handlers
            document.getElementById('monitorConfigFile').addEventListener('change', handleFileUpload);
            document.getElementById('dataConfigFile').addEventListener('change', handleFileUpload);
            
            // Button handlers
            document.getElementById('loadFilesBtn').addEventListener('click', loadConfigurationFiles);
            document.getElementById('loadExampleBtn').addEventListener('click', loadExampleConfigurations);
            document.getElementById('runVisualizationBtn').addEventListener('click', runVisualization);

            // Config action handlers - all config buttons are now handled by the compact form
        });

        // File upload handler
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileType = event.target.id === 'monitorConfigFile' ? 'monitor_config' : 'data_config';
            
            try {
                updateStatus('Uploading...', 'loading');
                
                const formData = new FormData();
                formData.append('file', file);
                formData.append('type', fileType);

                const response = await fetch('/api/upload_file', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    uploadedFiles[fileType] = result.filepath;
                    console.log(`${fileType} uploaded:`, result.filepath);
                    updateStatus('Ready', 'ready');
                    updateLoadButtonState();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Upload error:', error);
                updateStatus('Error', 'error');
                alert(`Upload failed: ${error.message}`);
            }
        }

        // Load configuration files and generate forms
        async function loadConfigurationFiles() {
            if (!uploadedFiles.monitor_config || !uploadedFiles.data_config) {
                alert('Please select both configuration files first.');
                return;
            }

            try {
                updateStatus('Loading configurations...', 'loading');

                // Use existing API endpoint but adapt the parameters
                const response = await fetch('/api/run_visualization', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        monitor_config_path: uploadedFiles.monitor_config,
                        data_config_path: uploadedFiles.data_config
                    })
                });

                const result = await response.json();

                if (result.success) {
                    currentMonitorConfig = result.monitor_config;
                    currentDataConfig = result.data_config;
                    
                    generateForms();
                    updateStatus('Ready', 'ready');
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Config loading error:', error);
                updateStatus('Error', 'error');
                alert(`Failed to load configurations: ${error.message}`);
            }
        }

        // Load example configurations
        async function loadExampleConfigurations() {
            try {
                updateStatus('Loading examples...', 'loading');

                const response = await fetch('/api/load_example_configs');
                const result = await response.json();

                if (result.success) {
                    currentMonitorConfig = result.examples.monitor_config;
                    currentDataConfig = result.examples.data_config;
                    
                    generateForms();
                    updateStatus('Ready', 'ready');
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Example loading error:', error);
                updateStatus('Error', 'error');
                alert(`Failed to load examples: ${error.message}`);
            }
        }

        // Generate dynamic forms
        function generateForms() {
            // Use compact monitor form with data config enabled
            compactMonitorForm = new CompactMonitorForm('compactMonitorFormContainer', {
                showDataConfig: true
            });
            
            // Extract monitor config from the nested structure if needed
            let monitorConfig = currentMonitorConfig;
            if (currentMonitorConfig && currentMonitorConfig.monitor) {
                monitorConfig = currentMonitorConfig.monitor;
                if (currentMonitorConfig.indicators) {
                    monitorConfig.indicators = currentMonitorConfig.indicators;
                }
            }
            
            compactMonitorForm.generateForm(monitorConfig, currentDataConfig);
            
            // Initialize indicator chart component
            initializeIndicatorChartComponent();

            // Set up form change handlers
            setupFormChangeHandlers();
            
            // Enable action buttons
            enableActionButtons();

            console.log('Forms generated successfully');
        }
        
        // Initialize indicator chart component
        function initializeIndicatorChartComponent() {
            if (indicatorChartComponent) {
                indicatorChartComponent.destroy();
            }
            
            indicatorChartComponent = new IndicatorChartComponent('indicatorChartsContainer', {
                showTriggerGraphs: true,
                chartHeight: 400,
                indicatorHeight: 250,
                triggerHeight: 150
            });
            
            // Load indicators from current monitor configuration
            if (currentMonitorConfig) {
                indicatorChartComponent.loadIndicators(currentMonitorConfig);
            }
        }

        // Set up form change handlers
        function setupFormChangeHandlers() {
            // Listen for configuration changes from compact monitor form
            document.getElementById('compactMonitorFormContainer').addEventListener('monitorConfigSave', (event) => {
                const data = event.detail;
                if (data.monitorConfig) {
                    currentMonitorConfig = data.monitorConfig;
                    console.log('Monitor Config updated:', currentMonitorConfig);
                }
                if (data.dataConfig) {
                    currentDataConfig = data.dataConfig;
                    console.log('Data Config updated:', currentDataConfig);
                }
                
                // Update indicator chart component if indicators changed
                if (indicatorChartComponent && data.monitorConfig) {
                    indicatorChartComponent.loadIndicators(data.monitorConfig);
                }
            });

        }

        // Enable action buttons
        function enableActionButtons() {
            ['runVisualizationBtn'].forEach(id => {
                document.getElementById(id).disabled = false;
            });
        }

        // Update load button state
        function updateLoadButtonState() {
            const hasFiles = uploadedFiles.monitor_config && uploadedFiles.data_config;
            document.getElementById('loadFilesBtn').disabled = !hasFiles;
        }

        // Save configuration
        async function saveConfiguration(configType) {
            const configData = configType === 'monitor_config' ? 
                (compactMonitorForm ? compactMonitorForm.getFormData().monitorConfig : currentMonitorConfig) :
                (compactMonitorForm ? compactMonitorForm.getFormData().dataConfig : currentDataConfig);

            if (!configData) {
                alert('No configuration data to save');
                return;
            }

            try {
                const response = await fetch('/api/save_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config_data: configData,
                        config_type: configType,
                        filename: `${configData.name || configData.ticker || 'config'}.json`
                    })
                });

                const result = await response.json();

                if (result.success) {
                    alert(result.message);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Save error:', error);
                alert(`Failed to save configuration: ${error.message}`);
            }
        }

        // Download configuration
        async function downloadConfiguration(configType) {
            const configData = configType === 'monitor_config' ? 
                (compactMonitorForm ? compactMonitorForm.getFormData().monitorConfig : currentMonitorConfig) :
                (compactMonitorForm ? compactMonitorForm.getFormData().dataConfig : currentDataConfig);

            if (!configData) {
                alert('No configuration data to download');
                return;
            }

            try {
                const response = await fetch('/api/download_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config_data: configData,
                        config_type: configType,
                        test_name: configData.name || configData.ticker || 'config'
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Create download link
                    const link = document.createElement('a');
                    link.href = result.download_url;
                    link.download = result.filename;
                    link.click();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Download error:', error);
                alert(`Failed to prepare download: ${error.message}`);
            }
        }

        // Validate configuration
        async function validateConfiguration(configType) {
            let configData = configType === 'monitor_config' ? 
                (compactMonitorForm ? compactMonitorForm.getFormData().monitorConfig : currentMonitorConfig) :
                (compactMonitorForm ? compactMonitorForm.getFormData().dataConfig : currentDataConfig);

            if (!configData) {
                alert('No configuration data to validate');
                return;
            }

            // For monitor config validation, ensure we're sending the full structure expected by the backend
            if (configType === 'monitor_config' && !configData.monitor && configData.name) {
                // If we have a flat monitor structure, wrap it properly
                configData = {
                    monitor: configData,
                    indicators: currentMonitorConfig.indicators || []
                };
            }

            try {
                const response = await fetch('/api/validate_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config_data: configData,
                        config_type: configType
                    })
                });

                const result = await response.json();

                let message = result.message;
                if (result.warnings && result.warnings.length > 0) {
                    message += '\n\nWarnings:\n• ' + result.warnings.join('\n• ');
                }
                if (result.errors && result.errors.length > 0) {
                    message += '\n\nErrors:\n• ' + result.errors.join('\n• ');
                }

                alert(message);
            } catch (error) {
                console.error('Validation error:', error);
                alert(`Failed to validate configuration: ${error.message}`);
            }
        }

        // Run visualization
        async function runVisualization() {
            const monitorConfig = compactMonitorForm ? compactMonitorForm.getFormData().monitorConfig : currentMonitorConfig;
            const dataConfig = compactMonitorForm ? compactMonitorForm.getFormData().dataConfig : 
                              (dataFormBuilder ? dataFormBuilder.getFormData() : currentDataConfig);

            if (!monitorConfig || !dataConfig) {
                alert('Please configure both monitor and data settings before running visualization.');
                return;
            }

            try {
                updateStatus('Running visualization...', 'loading');

                // Create temporary files for the current configurations
                const monitorConfigBlob = new Blob([JSON.stringify(monitorConfig, null, 2)], { type: 'application/json' });
                const dataConfigBlob = new Blob([JSON.stringify(dataConfig, null, 2)], { type: 'application/json' });

                const monitorConfigFile = new File([monitorConfigBlob], 'current_monitor_config.json');
                const dataConfigFile = new File([dataConfigBlob], 'current_data_config.json');

                // Upload current configurations
                const monitorFormData = new FormData();
                monitorFormData.append('file', monitorConfigFile);
                monitorFormData.append('type', 'current_monitor_config');

                const dataFormData = new FormData();
                dataFormData.append('file', dataConfigFile);
                dataFormData.append('type', 'current_data_config');

                const [monitorUploadResponse, dataUploadResponse] = await Promise.all([
                    fetch('/api/upload_file', { method: 'POST', body: monitorFormData }),
                    fetch('/api/upload_file', { method: 'POST', body: dataFormData })
                ]);

                const monitorUploadResult = await monitorUploadResponse.json();
                const dataUploadResult = await dataUploadResponse.json();

                if (!monitorUploadResult.success || !dataUploadResult.success) {
                    throw new Error('Failed to upload configurations');
                }

                // Run visualization with uploaded file paths
                const vizResponse = await fetch('/api/run_visualization', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        monitor_config_path: monitorUploadResult.filepath,
                        data_config_path: dataUploadResult.filepath
                    })
                });

                const vizResult = await vizResponse.json();

                if (vizResult.success) {
                    // First call gives us the configuration and summary
                    updateStatus('Loading chart data...', 'loading');
                    
                    // Make second call to get full chart data
                    const chartResponse = await fetch('/api/get_chart_data', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            monitor_config_path: monitorUploadResult.filepath,
                            data_config_path: dataUploadResult.filepath
                        })
                    });

                    const chartResult = await chartResponse.json();
                    
                    if (chartResult.success) {
                        displayResults(chartResult.chart_data, vizResult.monitor_config, vizResult.data_config);
                        updateStatus('Visualization Complete', 'ready');
                        
                        // Show results panel
                        document.getElementById('resultsPanel').style.display = 'block';
                        document.getElementById('visualizationResults').style.display = 'block';
                    } else {
                        throw new Error(chartResult.error);
                    }
                } else {
                    throw new Error(vizResult.error);
                }

            } catch (error) {
                console.error('Visualization error:', error);
                updateStatus('Error', 'error');
                alert(`Failed to run visualization: ${error.message}`);
            }
        }

        // Display visualization results
        function displayResults(chartData, monitorConfig, dataConfig) {
            // Update strategy overview
            document.getElementById('strategyName').textContent = monitorConfig.name || 'Unknown';
            document.getElementById('strategyDescription').textContent = monitorConfig.description || 'No description';
            document.getElementById('dataTicker').textContent = dataConfig.ticker || 'Unknown';
            const dateRangeElement = document.getElementById('dateRange');
            if (dateRangeElement) {
                dateRangeElement.textContent = `${dataConfig.start_date || 'Unknown'} to ${dataConfig.end_date || 'Unknown'}`;
            }
            document.getElementById('totalIndicators').textContent = (monitorConfig.indicators || []).length;
            document.getElementById('entryConditions').textContent = (monitorConfig.enter_long || []).length;

            // Calculate and display metrics
            calculateAndDisplayMetrics(chartData);

            console.log('=== BEFORE INDICATOR CHART COMPONENT UPDATE ===');
            console.log('indicatorChartComponent exists:', !!indicatorChartComponent);
            console.log('chartData keys:', Object.keys(chartData));

            // Update indicator chart component with component data (MACD/SMA values)
            if (indicatorChartComponent) {
                console.log('=== CHART DATA DEBUG ===');
                console.log('Available chartData keys:', Object.keys(chartData));
                console.log('component_data available:', !!chartData.component_data);
                console.log('component_data keys:', Object.keys(chartData.component_data || {}));
                console.log('Sample component_data:', chartData.component_data);
                
                // Use component_data for indicator charts (MACD signal/histogram, SMA lines)
                const indicatorChartData = {
                    candlestick_data: chartData.candlestick_data,
                    // Component data contains the actual MACD/SMA values for charts
                    component_data: chartData.component_data || {}
                };
                console.log('Passing to indicator chart component:', {
                    candlestick_data_length: indicatorChartData.candlestick_data?.length || 0,
                    component_data_keys: Object.keys(indicatorChartData.component_data)
                });
                
                console.log('About to call setChartData...');
                try {
                    indicatorChartComponent.setChartData(indicatorChartData);
                    console.log('setChartData completed successfully');
                } catch (error) {
                    console.error('ERROR in setChartData:', error);
                }
                
                // Convert indicator_history to 0-1 trigger data for trigger charts
                const triggerData = convertIndicatorHistoryToTriggerData(chartData, monitorConfig);
                indicatorChartComponent.updateIndicatorData(chartData.current_indicators || {}, triggerData);
            }

            // Generate P&L chart (keep existing)
            createPnLChart(chartData);

            // Populate trade history table
            populateTradeHistory(chartData);
        }
        
        // Convert indicator history to proper 0-1 trigger data with detailed debugging
        function convertIndicatorHistoryToTriggerData(chartData, monitorConfig) {
            const triggerData = {};
            
            console.log('=== TRIGGER DATA CONVERSION DEBUG ===');
            console.log('Available chart data keys:', Object.keys(chartData));
            console.log('Bar scores history available:', !!chartData.bar_scores_history);
            console.log('Bar scores history length:', chartData.bar_scores_history?.length || 0);
            console.log('Indicator history available:', !!chartData.indicator_history);
            console.log('Raw indicator history available:', !!chartData.raw_indicator_history);
            console.log('Current indicators available:', !!chartData.current_indicators);
            console.log('Monitor indicators:', monitorConfig.indicators?.map(i => i.name));
            
            if (chartData.bar_scores_history && chartData.bar_scores_history.length > 0) {
                console.log('Sample bar score entry:', chartData.bar_scores_history[0]);
                console.log('Available bar score keys:', Object.keys(chartData.bar_scores_history[0].scores || {}));
            }
            
            if (chartData.raw_indicator_history && chartData.raw_indicator_history.length > 0) {
                console.log('Sample raw indicator entry:', chartData.raw_indicator_history[0]);
                console.log('Available raw indicator keys:', Object.keys(chartData.raw_indicator_history[0] || {}));
            }
            
            if (chartData.indicator_history && chartData.indicator_history.length > 0) {
                console.log('Sample indicator history entry:', chartData.indicator_history[0]);
                console.log('Available indicator history keys:', Object.keys(chartData.indicator_history[0] || {}));
            }
            
            if (monitorConfig.indicators) {
                // Try to use raw_indicator_history first, then fall back to indicator_history
                const indicatorSource = chartData.raw_indicator_history || chartData.indicator_history;
                
                if (indicatorSource && indicatorSource.length > 0) {
                    console.log('Using indicator source with', indicatorSource.length, 'entries');
                    
                    monitorConfig.indicators.forEach(indicator => {
                        const indicatorName = indicator.name;
                        const triggerPoints = [];
                        
                        console.log(`Processing indicator: ${indicatorName}`);
                        
                        // Check available keys in the indicator source
                        const sampleEntry = indicatorSource[0];
                        const availableKeys = Object.keys(sampleEntry || {});
                        console.log(`Available indicator keys: ${availableKeys.join(', ')}`);
                        console.log(`Looking for: ${indicatorName}`);
                        
                        indicatorSource.forEach((indicatorPoint, index) => {
                            const timestamp = new Date(indicatorPoint.timestamp).getTime();
                            
                            if (index < 3) {
                                console.log(`Indicator point ${index}:`, {
                                    timestamp: indicatorPoint.timestamp,
                                    indicatorValue: indicatorPoint[indicatorName],
                                    allKeys: Object.keys(indicatorPoint)
                                });
                            }
                            
                            // Use the time-decayed indicator values directly (not 0-1 conversion)
                            let triggerValue = 0;
                            if (indicatorPoint[indicatorName] !== undefined) {
                                // For indicator_history, this should already be time-decayed values
                                triggerValue = indicatorPoint[indicatorName];
                                
                                if (index < 3) {
                                    console.log(`Time-decayed value: ${triggerValue}`);
                                }
                            }
                            
                            triggerPoints.push([timestamp, triggerValue]);
                        });
                        
                        const triggerCount = triggerPoints.filter(p => p[1] === 1).length;
                        triggerData[indicatorName] = triggerPoints;
                        console.log(`${indicatorName}: ${triggerCount} triggers out of ${triggerPoints.length} points`);
                        console.log(`Sample trigger data:`, triggerPoints.slice(0, 10));
                    });
                } else {
                    console.warn('No raw indicator history or indicator history available');
                }
            } else {
                console.warn('No indicators configured');
            }
            
            console.log('=== END TRIGGER DATA CONVERSION ===');
            return triggerData;
        }

        // Calculate and display performance metrics
        function calculateAndDisplayMetrics(chartData) {
            const trades = chartData.pnl_history || [];
            const totalTrades = trades.length;

            let winningTrades = 0;
            let losingTrades = 0;
            let totalWinPnL = 0;
            let totalLossPnL = 0;

            trades.forEach(trade => {
                if (trade.trade_pnl > 0) {
                    winningTrades++;
                    totalWinPnL += trade.trade_pnl;
                } else if (trade.trade_pnl < 0) {
                    losingTrades++;
                    totalLossPnL += trade.trade_pnl;
                }
            });

            const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;
            const totalPnL = trades.length > 0 ? trades[trades.length - 1].cumulative_pnl : 0;
            const avgWin = winningTrades > 0 ? totalWinPnL / winningTrades : 0;
            const avgLoss = losingTrades > 0 ? totalLossPnL / losingTrades : 0;
            const profitFactor = Math.abs(totalLossPnL) > 0 ? totalWinPnL / Math.abs(totalLossPnL) : 0;

            // Update metrics display
            document.getElementById('totalTrades').textContent = totalTrades;
            document.getElementById('winningTrades').textContent = winningTrades;
            document.getElementById('losingTrades').textContent = losingTrades;
            document.getElementById('winRate').textContent = `${winRate.toFixed(1)}%`;
            
            const totalPnLElement = document.getElementById('totalPnL');
            totalPnLElement.textContent = `${totalPnL.toFixed(2)}%`;
            totalPnLElement.className = `metric-value ${totalPnL >= 0 ? 'positive' : 'negative'}`;
            
            document.getElementById('avgWin').textContent = `${avgWin.toFixed(2)}%`;
            document.getElementById('avgLoss').textContent = `${avgLoss.toFixed(2)}%`;
            document.getElementById('profitFactor').textContent = profitFactor.toFixed(2);
        }

        // Create price chart with buy/sell signals
        function createPriceChart(chartData) {
            const container = document.getElementById('priceChart');

            // Debug: Log the chart data structure
            console.log('Chart data received:', chartData);
            console.log('Available keys:', Object.keys(chartData));

            // The backend returns candlestick_data already in Highcharts format [timestamp, open, high, low, close]
            let priceData = chartData.candlestick_data || [];
            
            if (!priceData || priceData.length === 0) {
                container.innerHTML = '<div class="alert alert-warning">No price data available. Available data keys: ' + Object.keys(chartData).join(', ') + '</div>';
                return;
            }

            console.log('Candlestick data sample:', priceData.slice(0, 3));

            // Prepare trade entry/exit triangles with enhanced debugging
            console.log('=== TRADE TRIANGLE DEBUG ===');
            console.log('Trade history exists:', !!chartData.trade_history);
            console.log('Trade history length:', chartData.trade_history ? chartData.trade_history.length : 0);
            console.log('Trade history sample:', (chartData.trade_history || []).slice(0, 5));
            console.log('Full trade history structure:');
            (chartData.trade_history || []).forEach((trade, i) => {
                console.log(`Trade ${i}:`, {
                    timestamp: trade.timestamp,
                    type: trade.type,
                    price: trade.price,
                    quantity: trade.quantity,
                    reason: trade.reason
                });
            });
            
            // Filter for entry trades (buy)
            const buySignals = (chartData.trade_history || [])
                .filter(trade => {
                    const isEntry = trade.type === 'buy';
                    console.log(`Trade type "${trade.type}" === "buy"?`, isEntry, trade);
                    return isEntry;
                })
                .map(trade => {
                    const signal = {
                        x: new Date(trade.timestamp).getTime(),
                        y: trade.price,
                        marker: { fillColor: 'green', symbol: 'triangle' }
                    };
                    console.log('Creating buy signal:', signal);
                    return signal;
                });

            // Filter for exit trades (sell)
            const sellSignals = (chartData.trade_history || [])
                .filter(trade => {
                    const isExit = trade.type === 'sell';
                    console.log(`Trade type "${trade.type}" === "sell"?`, isExit, trade);
                    return isExit;
                })
                .map(trade => {
                    const signal = {
                        x: new Date(trade.timestamp).getTime(),
                        y: trade.price,
                        marker: { fillColor: 'red', symbol: 'triangle-down' }
                    };
                    console.log('Creating sell signal:', signal);
                    return signal;
                });

            console.log('FINAL: Buy signals found:', buySignals.length);
            console.log('FINAL: Buy signals data:', buySignals);
            console.log('FINAL: Sell signals found:', sellSignals.length);
            console.log('FINAL: Sell signals data:', sellSignals);
            console.log('=== END TRADE TRIANGLE DEBUG ===');

            const chartConfig = {
                chart: { 
                    height: 380,
                    zoomType: 'x',
                    events: {
                        selection: function(event) {
                            if (event.xAxis) {
                                // Sync zoom with all other charts
                                const extremes = event.xAxis[0];
                                syncAllCharts(extremes.min, extremes.max, 'price');
                            }
                        }
                    }
                },
                title: { text: 'Price Chart with Trading Signals' },
                xAxis: { 
                    type: 'datetime',
                    ordinal: true,  // Remove gaps between trading sessions
                    crosshair: true,
                    events: {
                        setExtremes: function(e) {
                            if (e.trigger !== 'syncExtremes') {
                                // Sync zoom with all other charts
                                syncAllCharts(e.min, e.max, 'price');
                            }
                        }
                    }
                },
                yAxis: { 
                    title: { text: 'Price' },
                    crosshair: true
                },
                rangeSelector: {
                    enabled: false
                },
                navigator: {
                    enabled: false
                },
                scrollbar: {
                    enabled: false
                },
                series: [
                    {
                        name: 'Price',
                        data: priceData,
                        type: 'candlestick',
                        color: '#dc3545',        // red for down candles
                        upColor: '#28a745',      // green for up candles
                        lineColor: '#dc3545',    // red outline for down candles
                        upLineColor: '#28a745'   // green outline for up candles
                    },
                    {
                        name: 'Entry Trades',
                        data: buySignals,
                        type: 'scatter',
                        color: '#28a745',
                        marker: { 
                            symbol: 'triangle',
                            radius: 10,
                            lineWidth: 3,
                            lineColor: '#ffffff',
                            fillColor: '#28a745'
                        },
                        tooltip: {
                            pointFormat: '<b>Trade Entry</b><br/>Price: ${point.y:.2f}'
                        },
                        enableMouseTracking: true,
                        stickyTracking: false,
                        states: {
                            hover: {
                                enabled: true,
                                marker: {
                                    radius: 12,
                                    lineWidth: 4
                                }
                            }
                        }
                    },
                    {
                        name: 'Exit Trades',
                        data: sellSignals,
                        type: 'scatter',
                        color: '#dc3545',
                        marker: { 
                            symbol: 'triangle-down',
                            radius: 10,
                            lineWidth: 3,
                            lineColor: '#ffffff',
                            fillColor: '#dc3545'
                        },
                        tooltip: {
                            pointFormat: '<b>Trade Exit</b><br/>Price: ${point.y:.2f}'
                        },
                        enableMouseTracking: true,
                        stickyTracking: false,
                        states: {
                            hover: {
                                enabled: true,
                                marker: {
                                    radius: 12,
                                    lineWidth: 4
                                }
                            }
                        }
                    }
                ],
                tooltip: {
                    split: false,
                    shared: true,
                    crosshairs: true
                },
                plotOptions: {
                    candlestick: {
                        color: '#dc3545',
                        upColor: '#28a745',
                        lineColor: '#dc3545',
                        upLineColor: '#28a745'
                    }
                },
                credits: {
                    enabled: false
                }
            };

            if (charts.price) {
                charts.price.destroy();
            }
            charts.price = Highcharts.chart(container, chartConfig);
        }

        // Create P&L evolution chart - Simple version matching exact requirements
        function createPnLChart(chartData) {
            const container = document.getElementById('pnlChart');

            if (!chartData.trade_history || chartData.trade_history.length === 0) {
                container.innerHTML = '<div class="alert alert-warning">No trade data available for P&L chart</div>';
                return;
            }

            // Get exact timeframe from candlestick data
            let minTime = null;
            let maxTime = null;
            if (chartData.candlestick_data && chartData.candlestick_data.length > 0) {
                minTime = chartData.candlestick_data[0][0];
                maxTime = chartData.candlestick_data[chartData.candlestick_data.length - 1][0];
            }

            console.log('P&L Chart timeframe:', new Date(minTime), 'to', new Date(maxTime));

            // Build P&L data from trade history - only exit trades affect P&L
            const pnlData = [];
            let cumulativePnL = 0.0;
            
            // Start at 0% at the beginning of timeframe
            if (minTime) {
                pnlData.push([minTime, 0]);
            }
            
            // Process trades to build cumulative P&L
            // Entry trades don't affect P&L, only exits do
            const exitTrades = chartData.trade_history.filter(trade => trade.type === 'sell');
            console.log('Exit trades found:', exitTrades.length, exitTrades);
            
            // For simplicity, let's use pnl_history if available, otherwise calculate from trade pairs
            if (chartData.pnl_history && chartData.pnl_history.length > 0) {
                chartData.pnl_history.forEach((pnlPoint, index) => {
                    const timestamp = new Date(pnlPoint.timestamp).getTime();
                    const cumPnL = pnlPoint.cumulative_pnl || 0;
                    
                    // Add point just before this trade at previous P&L level
                    if (index === 0 && timestamp > minTime) {
                        pnlData.push([timestamp - 60000, 0]); // 1 minute before first exit
                    } else if (index > 0) {
                        const prevPnL = chartData.pnl_history[index - 1].cumulative_pnl || 0;
                        pnlData.push([timestamp - 60000, prevPnL]); // 1 minute before this exit
                    }
                    
                    // Add the actual trade exit point
                    pnlData.push([timestamp, cumPnL]);
                    cumulativePnL = cumPnL;
                    
                    console.log(`P&L: ${new Date(timestamp).toISOString()} = ${cumPnL}%`);
                });
            } else {
                console.warn('No pnl_history found, P&L chart will show flat at 0%');
            }
            
            // Extend to end of timeframe with final P&L value
            if (maxTime && pnlData.length > 0) {
                const lastTimestamp = pnlData[pnlData.length - 1][0];
                if (maxTime > lastTimestamp) {
                    pnlData.push([maxTime, cumulativePnL]);
                }
            }

            // Generate 4-hour tick marks
            const fourHourTicks = [];
            if (minTime && maxTime) {
                const fourHoursMs = 4 * 60 * 60 * 1000; // 4 hours in milliseconds
                for (let time = minTime; time <= maxTime; time += fourHoursMs) {
                    fourHourTicks.push(time);
                }
            }

            console.log('Final P&L data:', pnlData);
            console.log('4-hour ticks:', fourHourTicks.map(t => new Date(t).toISOString()));

            const chartConfig = {
                chart: { 
                    type: 'line', 
                    height: 280,
                    zoomType: 'x',
                    events: {
                        selection: function(event) {
                            if (event.xAxis) {
                                const extremes = event.xAxis[0];
                                syncAllCharts(extremes.min, extremes.max, 'pnl');
                            }
                        }
                    }
                },
                title: { text: 'Cumulative P&L Evolution' },
                xAxis: { 
                    type: 'datetime',
                    min: minTime,
                    max: maxTime,
                    tickPositions: fourHourTicks, // Show ticks every 4 hours
                    events: {
                        setExtremes: function(e) {
                            if (e.trigger !== 'syncExtremes') {
                                syncAllCharts(e.min, e.max, 'pnl');
                            }
                        }
                    }
                },
                yAxis: { 
                    title: { text: 'Cumulative P&L (%)' },
                    plotLines: [{
                        value: 0,
                        color: '#999',
                        width: 1,
                        dashStyle: 'dash'
                    }]
                },
                series: [{
                    name: 'Cumulative P&L',
                    data: pnlData,
                    color: '#007bff',
                    lineWidth: 2,
                    step: 'left' // Create step-like appearance for P&L changes
                }],
                tooltip: {
                    pointFormat: '<b>{series.name}:</b> {point.y:.2f}%<br/>',
                    shared: true,
                    crosshairs: true
                },
                credits: { enabled: false }
            };

            if (charts.pnl) {
                charts.pnl.destroy();
            }
            charts.pnl = Highcharts.chart(container, chartConfig);
            
            // Sync initial extremes with price chart if it exists
            if (charts.price && minTime && maxTime) {
                setTimeout(() => {
                    try {
                        const priceExtremes = charts.price.xAxis[0].getExtremes();
                        if (priceExtremes.min !== minTime || priceExtremes.max !== maxTime) {
                            charts.pnl.xAxis[0].setExtremes(priceExtremes.min, priceExtremes.max, true, false);
                        }
                    } catch (e) {
                        console.log('Chart sync timing issue, will sync on user interaction');
                    }
                }, 100);
            }
        }

        // Populate trade history table
        function populateTradeHistory(chartData) {
            const tableBody = document.getElementById('tradeHistoryTable');

            if (!chartData.trade_history || chartData.trade_history.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No trades to display</td></tr>';
                return;
            }

            // Combine trade history with P&L data
            const pnlMap = new Map();
            (chartData.pnl_history || []).forEach(pnl => {
                pnlMap.set(pnl.timestamp, pnl);
            });

            const rows = chartData.trade_history.map(trade => {
                const pnlData = pnlMap.get(trade.timestamp);
                const tradePnL = pnlData ? pnlData.trade_pnl : 0;
                const cumulativePnL = pnlData ? pnlData.cumulative_pnl : 0;

                const pnlClass = tradePnL > 0 ? 'text-success' : (tradePnL < 0 ? 'text-danger' : '');

                return `
                    <tr>
                        <td>${new Date(trade.timestamp).toLocaleDateString()}</td>
                        <td>${trade.type}</td>
                        <td>$${trade.price.toFixed(2)}</td>
                        <td>${trade.quantity || trade.size}</td>
                        <td class="${pnlClass}">${tradePnL.toFixed(2)}%</td>
                        <td class="${cumulativePnL >= 0 ? 'text-success' : 'text-danger'}">${cumulativePnL.toFixed(2)}%</td>
                        <td class="small">${trade.reason || '-'}</td>
                    </tr>
                `;
            }).join('');

            tableBody.innerHTML = rows;
        }

        // Update status badge
        function updateStatus(text, type) {
            const statusElement = document.getElementById('appStatus');
            statusElement.textContent = text;
            statusElement.className = `status-badge status-${type}`;
        }
    </script>
</body>
</html>