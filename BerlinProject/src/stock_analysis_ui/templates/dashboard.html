<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f1419;
            color: #e6edf3;
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Layout with sidebar */
        .app-container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 250px;
            background: #161b22;
            border-right: 1px solid #30363d;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
        }

        .sidebar-header {
            padding: 1.5rem;
            border-bottom: 1px solid #30363d;
        }

        .sidebar-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 0.5rem;
        }

        .sidebar-subtitle {
            font-size: 0.875rem;
            color: #7d8590;
        }

        .sidebar-nav {
            padding: 1rem 0;
        }

        .nav-item {
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.875rem 1.5rem;
            color: #e6edf3;
            text-decoration: none;
            border-radius: 0 6px 6px 0;
            margin-right: 0.75rem;
            transition: all 0.2s ease;
            position: relative;
        }

        .nav-link:hover {
            background: #21262d;
            color: #58a6ff;
        }

        .nav-link.active {
            background: #1f2937;
            color: #58a6ff;
            border-right: 3px solid #58a6ff;
        }

        .nav-link.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #58a6ff;
        }

        .nav-icon {
            font-size: 1.125rem;
            width: 20px;
            text-align: center;
        }

        /* Main content area */
        .main-content {
            margin-left: 250px;
            flex: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .mobile-menu-toggle {
            display: none;
        }

        .header {
            background: #161b22;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #30363d;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
        }

        .header h1 {
            font-size: 1.875rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #f0f6fc;
        }

        .status-bar {
            display: flex;
            gap: 2rem;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.connected { background: #238636; }
        .status-dot.disconnected { background: #da3633; }

        /* Pip Saver Toggle */
        .pip-saver-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            cursor: pointer;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #21262d;
            border: 1px solid #30363d;
            border-radius: 24px;
            transition: all 0.3s ease;
        }

        .toggle-slider::before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: #7d8590;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: rgba(240, 136, 62, 0.3);
            border-color: #f0883e;
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(20px);
            background-color: #f0883e;
        }

        .toggle-label {
            color: #7d8590;
            font-size: 0.75rem;
        }

        /* Replay Controls Bar */
        .replay-controls-bar {
            display: none;
            background: linear-gradient(135deg, #1a1f29 0%, #161b22 100%);
            border-bottom: 1px solid #30363d;
            padding: 0.75rem 1.5rem;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .replay-controls-bar.active {
            display: flex;
        }

        .replay-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .replay-badge {
            background: #1f6feb;
            color: #fff;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .replay-ticker {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: #f0f6fc;
        }

        .replay-date {
            color: #7d8590;
            font-size: 0.875rem;
        }

        .replay-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .replay-btn {
            background: #21262d;
            border: 1px solid #30363d;
            color: #e6edf3;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .replay-btn:hover {
            background: #30363d;
            border-color: #484f58;
        }

        .replay-btn.primary {
            background: #238636;
            border-color: #238636;
        }

        .replay-btn.primary:hover {
            background: #2ea043;
        }

        .replay-btn.danger {
            background: #da3633;
            border-color: #da3633;
        }

        .replay-btn.danger:hover {
            background: #f85149;
        }

        .replay-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .replay-speed-select {
            background: #21262d;
            border: 1px solid #30363d;
            color: #e6edf3;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
        }

        .replay-speed-select:focus {
            outline: none;
            border-color: #1f6feb;
        }

        /* Pause on Trade Toggle */
        .pause-on-trade-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0 0.5rem;
        }

        .pause-on-trade-toggle label {
            font-size: 0.75rem;
            color: #7d8590;
            white-space: nowrap;
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #21262d;
            border: 1px solid #30363d;
            transition: 0.3s;
            border-radius: 20px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: #7d8590;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #238636;
            border-color: #238636;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(16px);
            background-color: #ffffff;
        }

        .trade-flash {
            animation: tradeFlash 0.5s ease-out;
        }

        @keyframes tradeFlash {
            0% { background-color: #f0ad4e; }
            100% { background-color: transparent; }
        }

        .replay-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #7d8590;
            font-size: 0.8rem;
        }

        .replay-progress-bar {
            width: 100px;
            height: 6px;
            background: #21262d;
            border-radius: 3px;
            overflow: hidden;
        }

        .replay-progress-fill {
            height: 100%;
            background: #238636;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Replay Complete Overlay */
        .replay-complete-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .replay-complete-overlay.active {
            display: flex;
        }

        .replay-complete-modal {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 2.5rem;
            text-align: center;
            max-width: 400px;
        }

        .replay-complete-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .replay-complete-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 0.5rem;
        }

        .replay-complete-subtitle {
            color: #7d8590;
            margin-bottom: 1.5rem;
        }

        .replay-complete-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .controls {
            padding: 1rem;
            background: #0d1117;
            border-bottom: 1px solid #21262d;
            text-align: center;
        }

        .add-card-button {
            background: #238636;
            color: #ffffff;
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-size: 1.125rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(35, 134, 54, 0.3);
        }

        .add-card-button:hover {
            background: #2ea043;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(35, 134, 54, 0.4);
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #30363d;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f0f6fc;
        }

        .modal-close {
            background: none;
            border: none;
            color: #7d8590;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #21262d;
            color: #ff7b72;
        }

        .form-section {
            margin-bottom: 2rem;
        }

        .form-section h3 {
            color: #f0f6fc;
            margin-bottom: 1rem;
            font-size: 1.125rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #f0f6fc;
            font-size: 0.875rem;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #0d1117;
            color: #e6edf3;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #1f6feb;
            box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.1);
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            padding-top: 1rem;
            border-top: 1px solid #30363d;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn.btn-primary {
            background: #238636;
            color: #ffffff;
        }

        .btn.btn-primary:hover:not(:disabled) {
            background: #2ea043;
        }

        .btn.btn-primary:disabled {
            background: #21262d;
            color: #7d8590;
            cursor: not-allowed;
        }

        .btn.btn-secondary {
            background: #21262d;
            color: #e6edf3;
            border: 1px solid #30363d;
        }

        .btn.btn-secondary:hover {
            background: #30363d;
        }

        /* Cards Container */
        .cards-container {
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            max-width: none;
            margin: 0 auto;
            align-items: flex-start;
        }

        .loading {
            width: 100%;
            text-align: center;
            padding: 4rem 2rem;
            color: #7d8590;
        }

        .loading p {
            margin-bottom: 0.5rem;
        }

        /* Trading Card Styles */
        .trading-card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .trading-card:hover {
            border-color: #7d8590;
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .trading-card.updating {
            box-shadow: 0 0 20px rgba(35, 134, 54, 0.3);
        }

        /* Data Warning */
        .data-warning {
            background-color: rgba(255, 193, 7, 0.15);
            border: 1px solid #ffc107;
            border-radius: 4px;
            color: #ffc107;
            font-size: 0.75rem;
            padding: 0.35rem 0.5rem;
            margin: 0.25rem 0;
            text-align: center;
        }

        /* Card Size Modes */
        .trading-card.size-big {
            width: 350px;
            flex: 0 0 350px;
        }

        .trading-card.size-medium {
            width: 280px;
            flex: 0 0 280px;
        }

        .trading-card.size-small {
            width: 220px;
            flex: 0 0 220px;
        }

        /* Size Control Icons */
        .size-controls {
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }

        .size-btn {
            background: none;
            border: 1px solid #30363d;
            color: #7d8590;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .size-btn:hover {
            background: #21262d;
            color: #e6edf3;
            border-color: #58a6ff;
        }

        .size-btn.active {
            background: #1f6feb;
            color: #ffffff;
            border-color: #1f6feb;
        }

        /* Hide elements based on card size - portfolio only (price always visible) */
        .trading-card.size-small .portfolio-section {
            display: none;
        }

        .trading-card.size-small .portfolio-section.expanded {
            display: block;
        }

        /* Collapsible sections for small cards */
        .collapsible-header {
            display: none;
            cursor: pointer;
            padding: 0.5rem;
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: #7d8590;
            text-align: center;
            transition: all 0.2s ease;
        }

        .trading-card.size-small .collapsible-header {
            display: block;
        }

        .collapsible-header:hover {
            background: #21262d;
            color: #e6edf3;
        }

        .collapsible-header .toggle-icon {
            float: right;
            transition: transform 0.2s ease;
        }

        .collapsible-header.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .card-controls {
            display: flex;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f0f6fc;
            font-family: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
        }

        .card-subtitle {
            font-size: 0.75rem;
            color: #7d8590;
            margin-top: 0.25rem;
        }

        .card-close {
            background: none;
            border: none;
            color: #7d8590;
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .card-close:hover {
            background: #21262d;
            color: #da3633;
        }

        .price-display {
            font-size: 2rem;
            font-weight: 700;
            color: #238636;
            margin-bottom: 1rem;
            text-align: center;
            font-family: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
        }

        .price-display.negative {
            color: #da3633;
        }

        .price-timestamp {
            font-size: 0.75rem;
            color: #7d8590;
            text-align: center;
            margin-bottom: 1rem;
        }

        /* Enhanced Portfolio Section Styles with Collapsible Feature */
        .portfolio-section {
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
        }

        .portfolio-header-static {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .portfolio-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #f0f6fc;
        }

        .position-status {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .position-status.in-position {
            background: rgba(35, 134, 54, 0.2);
            color: #56d364;
            border: 1px solid rgba(35, 134, 54, 0.3);
        }

        .position-status.no-position {
            background: rgba(125, 133, 144, 0.2);
            color: #8b949e;
            border: 1px solid rgba(125, 133, 144, 0.3);
        }

        .portfolio-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .metric-item {
            background: #161b22;
            border: 1px solid #21262d;
            border-radius: 6px;
            padding: 0.75rem;
            text-align: center;
        }

        .metric-label {
            font-size: 0.75rem;
            color: #7d8590;
            margin-bottom: 0.25rem;
        }

        .metric-value {
            font-size: 1rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
        }

        .metric-value.positive {
            color: #56d364;
        }

        .metric-value.negative {
            color: #ff7b72;
        }

        .metric-value.neutral {
            color: #e6edf3;
        }

        .bars-container {
            margin-bottom: 1.5rem;
        }

        .responsive-bar {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .responsive-bar:hover {
            border-color: #30363d;
            transform: scale(1.02);
        }

        .bar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .bar-label {
            font-weight: 500;
            color: #e6edf3;
            font-size: 0.875rem;
        }

        .bar-value-text {
            font-weight: 600;
            font-family: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
            font-size: 0.75rem;
        }

        .bar-track {
            height: 12px;
            background: #21262d;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            border: 1px solid #30363d;
        }

        .bar-fill {
            height: 100%;
            border-radius: 5px;
            transition: all 0.5s ease;
            position: relative;
            background: linear-gradient(90deg, var(--bar-color) 0%, var(--bar-color-light) 100%);
            box-shadow: 0 0 8px rgba(var(--bar-glow), 0.3);
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.1) 50%, transparent 100%);
            border-radius: 5px;
        }

        /* Messages */
        .success-message, .error-message, .info-message {
            position: fixed;
            top: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            z-index: 1001;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .success-message {
            background: rgba(35, 134, 54, 0.2);
            color: #56d364;
            border: 1px solid rgba(35, 134, 54, 0.3);
        }

        .error-message {
            background: rgba(248, 81, 73, 0.2);
            color: #ff7b72;
            border: 1px solid rgba(248, 81, 73, 0.3);
        }

        .info-message {
            background: rgba(31, 111, 235, 0.2);
            color: #79c0ff;
            border: 1px solid rgba(31, 111, 235, 0.3);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .mobile-menu-toggle {
                display: block;
                background: none;
                border: none;
                color: #e6edf3;
                font-size: 1.5rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-right: 1rem;
                margin-left: -0.5rem;
            }

            .cards-container {
                flex-direction: column;
                padding: 0.5rem;
                gap: 0.5rem;
            }

            .trading-card {
                padding: 0.75rem;
            }

            .trading-card.size-big,
            .trading-card.size-medium,
            .trading-card.size-small {
                width: 100% !important;
                flex: 1 1 auto !important;
            }

            .modal {
                width: 95%;
                margin: 1rem;
            }
        }

        /* Hide scrollbar but allow scrolling */
        .modal::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <nav class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Trading Dashboard</div>
                <div class="sidebar-subtitle">Navigation</div>
            </div>
            <div class="sidebar-nav">
                <div class="nav-item">
                    <a href="/dashboard" class="nav-link active">
                        <span class="nav-icon"></span>
                        <span>Dashboard</span>
                    </a>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="header">
                <button class="mobile-menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
                <h1>Trading Dashboard</h1>
                <div class="status-bar">
                    <div class="status-item">
                        <div class="status-dot disconnected" id="connectionStatus"></div>
                        <span id="connectionText">Connecting...</span>
                    </div>
                    <div class="status-item">
                        <div class="status-dot disconnected" id="streamingStatus"></div>
                        <span id="streamingText">Not Streaming</span>
                    </div>
                    <div class="status-item">
                        <span id="combinationsCount">0 Cards</span>
                    </div>
                    <div class="status-item pip-saver-toggle">
                        <span class="toggle-label">Save Pips:</span>
                        <label class="toggle-switch" title="Toggle pip saving to local files">
                            <input type="checkbox" id="pipSaverToggle" onchange="togglePipSaver()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="status-item sound-toggle">
                        <span class="toggle-label">üîä Sounds:</span>
                        <label class="toggle-switch" title="Play sound when bar scores cross thresholds">
                            <input type="checkbox" id="soundToggle" onchange="toggleSoundNotifications()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="status-item">
                        <span style="margin-right: 0.5rem; color: #7d8590;">Card Size:</span>
                        <div class="size-controls" id="globalSizeControls">
                            <button class="size-btn active" data-size="big" title="Large View">L</button>
                            <button class="size-btn" data-size="medium" title="Medium View">M</button>
                            <button class="size-btn" data-size="small" title="Small View">S</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Replay Controls Bar (only visible in replay mode) -->
            <div class="replay-controls-bar" id="replayControlsBar">
                <div class="replay-info">
                    <span class="replay-badge">Replay</span>
                    <span class="replay-ticker" id="replayTicker">--</span>
                    <span class="replay-date" id="replayDate">--</span>
                </div>
                <div class="replay-controls">
                    <div class="replay-progress">
                        <div class="replay-progress-bar">
                            <div class="replay-progress-fill" id="replayProgressFill"></div>
                        </div>
                        <span id="replayProgressText">0%</span>
                    </div>
                    <select class="replay-speed-select" id="replaySpeedSelect" onchange="changeReplaySpeed(this.value)">
                        <option value="0.5">0.5x</option>
                        <option value="1" selected>1x</option>
                        <option value="2">2x</option>
                        <option value="5">5x</option>
                        <option value="10">10x</option>
                        <option value="20">20x</option>
                        <option value="100">100x</option>
                    </select>
                    <div class="pause-on-trade-toggle">
                        <label class="toggle-switch" title="Pause playback when a trade occurs">
                            <input type="checkbox" id="pauseOnTradeToggle">
                            <span class="toggle-slider"></span>
                        </label>
                        <label for="pauseOnTradeToggle" title="Pause playback when a trade occurs">Pause on Trade</label>
                    </div>
                    <button class="replay-btn primary" id="replayPlayPauseBtn" onclick="toggleReplayPlayPause()">
                        <span id="playPauseIcon">‚è∏</span>
                        <span id="playPauseText">Pause</span>
                    </button>
                    <button class="replay-btn danger" onclick="stopReplay()">
                        ‚èπ Stop
                    </button>
                </div>
            </div>

            <!-- Replay Complete Overlay -->
            <div class="replay-complete-overlay" id="replayCompleteOverlay">
                <div class="replay-complete-modal">
                    <div class="replay-complete-icon">üé¨</div>
                    <h2 class="replay-complete-title">Replay Complete</h2>
                    <p class="replay-complete-subtitle">All historical data has been processed</p>
                    <div class="replay-complete-actions">
                        <button class="replay-btn" onclick="restartReplay()">Restart</button>
                        <a href="/replay" class="replay-btn primary">New Replay</a>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button class="add-card-button" onclick="openAddCardModal()">
                    + Add New Trading Card
                </button>
            </div>

            <!-- Modal for adding cards -->
            <div class="modal-overlay" id="modalOverlay">
                <div class="modal">
                    <div class="modal-header">
                        <h2 class="modal-title">Add New Trading Card</h2>
                        <button class="modal-close" onclick="closeAddCardModal()">&times;</button>
                    </div>

                    <div class="form-section">
                        <h3>Stock Symbol</h3>
                        <div class="form-group">
                            <label for="modalSymbolInput">Enter stock symbol</label>
                            <input type="text" id="modalSymbolInput" placeholder="e.g., AAPL, MSFT, NVDA" maxlength="10">
                        </div>
                    </div>

                    <div class="form-section">
                        <h3>Monitor Configuration File</h3>
                        <div class="form-group">
                            <label for="modalFileInput">Select a JSON configuration file</label>
                            <input type="file" id="modalFileInput" accept=".json" style="margin-bottom: 0.5rem;">
                            <div id="selectedFileName" style="font-size: 0.875rem; color: #7d8590; margin-top: 0.5rem;">
                                No file selected
                            </div>
                        </div>
                        <div style="margin-top: 1rem;">
                            <p style="font-size: 0.875rem; color: #7d8590;">
                                üí° <strong>Tip:</strong> You can also drag and drop a JSON file onto the file input above.
                            </p>
                        </div>
                    </div>

                    <div class="modal-actions">
                        <button class="btn btn-secondary" onclick="closeAddCardModal()">Cancel</button>
                        <button class="btn btn-primary" id="modalAddButton" onclick="addCombinationFromModal()" disabled>Add Card</button>
                    </div>
                </div>
            </div>

            <div id="messages"></div>

            <div class="cards-container" id="cardsContainer">
                <div class="loading">
                    <p>No trading cards added yet.</p>
                    <p>Click "Add New Trading Card" above to get started.</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        let cards = {};

        // Modal state
        let modalSelectedFile = null;

        // Pip saver state
        let pipSaverEnabled = false;

        // Connection handling
        socket.on('connect', function() {
            updateConnectionStatus(true);
        });

        socket.on('disconnect', function() {
            updateConnectionStatus(false);
        });

        // Card update handler
        socket.on('card_update', function(data) {
            console.log('Received card_update:', data);

            const cardId = data.card_id;
            if (cardId) {
                // Update threshold map if thresholds are present
                if (data.thresholds) {
                    updateCardThresholds(cardId, data.thresholds);
                }

                // Check for threshold crossings BEFORE updating card (to compare old vs new)
                if (data.bar_scores) {
                    checkThresholdCrossings(cardId, data.bar_scores);
                }

                updateOrCreateCard(cardId, data);

                // Check for new trades and handle pause-on-trade
                if (data.portfolio) {
                    const newTradeDetected = checkForNewTrade(cardId, data.portfolio);
                    if (newTradeDetected) {
                        handleTradeDetected(cardId, data.portfolio);
                    }
                }
            }
        });

        // Status updates
        socket.on('status_update', function(data) {
            updateStatus(data);
        });

        // Error handling
        socket.on('error', function(data) {
            showMessage(`Error: ${data.message}`, 'error');
        });

        // Initial data from server
        socket.on('initial_data', function(data) {
            console.log('Received initial_data:', data);
            updateConnectionStatus(true);
            updateStatus(data);

            if (data.combinations && data.combinations.length > 0) {
                data.combinations.forEach(combination => {
                    updateOrCreateCard(combination.card_id, combination);
                });
            }
        });

        // ============================================
        // Sound Notification System
        // ============================================
        let soundEnabled = false;
        let bullSound = null;
        let bearSound = null;
        const previousBarScores = {};  // {cardId: {barName: score}}
        const cardThresholds = {};     // {cardId: {barName: {value, type: 'entry'|'exit'}}}

        // Initialize sound system
        function initSoundSystem() {
            // Restore saved preference
            const savedPref = localStorage.getItem('soundNotificationsEnabled');
            soundEnabled = savedPref === 'true';

            const toggle = document.getElementById('soundToggle');
            if (toggle) {
                toggle.checked = soundEnabled;
            }

            // Pre-load audio elements
            bullSound = new Audio('/assets/BuyMartin.m4a');
            bearSound = new Audio('/assets/SellMartin.m4a');

            // Pre-load the sounds for responsive playback
            bullSound.load();
            bearSound.load();

            console.log('Sound notification system initialized, enabled:', soundEnabled);
        }

        // Toggle sound notifications
        function toggleSoundNotifications() {
            const toggle = document.getElementById('soundToggle');
            soundEnabled = toggle ? toggle.checked : false;
            localStorage.setItem('soundNotificationsEnabled', soundEnabled);
            console.log('Sound notifications:', soundEnabled ? 'enabled' : 'disabled');
        }

        // Build threshold map from card_update data
        function updateCardThresholds(cardId, thresholds) {
            if (!thresholds) return;

            // Only build the map once per card (thresholds don't change)
            if (cardThresholds[cardId]) return;

            cardThresholds[cardId] = {};

            // Map entry thresholds (bull signals)
            if (thresholds.enter_long && Array.isArray(thresholds.enter_long)) {
                thresholds.enter_long.forEach(condition => {
                    if (condition.name && condition.threshold !== undefined) {
                        cardThresholds[cardId][condition.name] = {
                            value: condition.threshold,
                            type: 'entry'
                        };
                    }
                });
            }

            // Map exit thresholds (bear signals)
            if (thresholds.exit_long && Array.isArray(thresholds.exit_long)) {
                thresholds.exit_long.forEach(condition => {
                    if (condition.name && condition.threshold !== undefined) {
                        cardThresholds[cardId][condition.name] = {
                            value: condition.threshold,
                            type: 'exit'
                        };
                    }
                });
            }

            console.log(`Threshold map built for ${cardId}:`, cardThresholds[cardId]);
        }

        // Check for threshold crossings and play appropriate sound
        function checkThresholdCrossings(cardId, barScores) {
            if (!soundEnabled || !barScores) return;

            const thresholdMap = cardThresholds[cardId];
            if (!thresholdMap || Object.keys(thresholdMap).length === 0) return;

            const prev = previousBarScores[cardId] || {};

            for (const [barName, currentScore] of Object.entries(barScores)) {
                const thresh = thresholdMap[barName];
                if (!thresh) continue;

                const prevScore = prev[barName];

                // Only detect upward crossings (from below to at/above threshold)
                // Skip if we don't have a previous score (first update)
                if (prevScore !== undefined && prevScore < thresh.value && currentScore >= thresh.value) {
                    console.log(`üîî Threshold crossed for ${cardId}/${barName}: ${prevScore.toFixed(3)} ‚Üí ${currentScore.toFixed(3)} (threshold: ${thresh.value}, type: ${thresh.type})`);
                    playSignalSound(thresh.type, cardId, barName);
                }
            }

            // Store current scores for next comparison
            previousBarScores[cardId] = {...barScores};
        }

        // Play the appropriate sound based on signal type
        function playSignalSound(signalType, cardId, barName) {
            const sound = (signalType === 'entry') ? bullSound : bearSound;
            const soundName = (signalType === 'entry') ? 'Bull' : 'Bear';

            if (sound) {
                sound.currentTime = 0;
                sound.play()
                    .then(() => console.log(`üîä ${soundName} sound played for ${cardId}/${barName}`))
                    .catch(e => console.log('Audio play failed (user interaction may be required):', e));
            }
        }

        // Pip Saver Functions
        async function togglePipSaver() {
            try {
                const response = await fetch('/api/pip-saver/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();

                if (result.success) {
                    updatePipSaverUI(result.status || result);
                    const action = result.enabled ? 'enabled' : 'disabled';
                    showMessage(`Pip saving ${action}`, 'success');
                } else {
                    showMessage(`Error: ${result.error}`, 'error');
                    // Revert toggle state on error
                    const toggle = document.getElementById('pipSaverToggle');
                    if (toggle) toggle.checked = pipSaverEnabled;
                }
            } catch (error) {
                showMessage(`Error toggling pip saver: ${error.message}`, 'error');
                // Revert toggle state on error
                const toggle = document.getElementById('pipSaverToggle');
                if (toggle) toggle.checked = pipSaverEnabled;
            }
        }

        function updatePipSaverUI(status) {
            pipSaverEnabled = status.enabled || false;

            // Update toggle checkbox
            const toggle = document.getElementById('pipSaverToggle');
            if (toggle) {
                toggle.checked = pipSaverEnabled;
            }
        }

        async function fetchPipSaverStatus() {
            try {
                const response = await fetch('/api/pip-saver/status');
                const data = await response.json();
                if (data.success) {
                    updatePipSaverUI(data);
                }
            } catch (error) {
                console.log('Could not fetch pip saver status:', error);
            }
        }

        function updateConnectionStatus(connected) {
            const statusDot = document.getElementById('connectionStatus');
            const statusText = document.getElementById('connectionText');

            statusDot.className = `status-dot ${connected ? 'connected' : 'disconnected'}`;
            statusText.textContent = connected ? 'Connected' : 'Disconnected';
        }

        function updateStatus(data) {
            const streamingDot = document.getElementById('streamingStatus');
            const streamingText = document.getElementById('streamingText');

            streamingDot.className = `status-dot ${data.streaming ? 'connected' : 'disconnected'}`;
            streamingText.textContent = data.streaming ? 'Streaming Active' : 'Not Streaming';

            updateCardsCount(data.combinations ? data.combinations.length : 0);
        }

        function updateCardsCount(count = null) {
            const combinationsCount = document.getElementById('combinationsCount');

            if (count === null) {
                count = document.querySelectorAll('.trading-card').length;
            }

            combinationsCount.textContent = `${count} Card${count !== 1 ? 's' : ''}`;
        }

        function updateOrCreateCard(cardId, data) {
            let card = document.getElementById(cardId);

            if (!card) {
                card = createCard(cardId, data);
            }

            updateCardData(card, data);
        }

        function createCard(cardId, data) {
            const container = document.getElementById('cardsContainer');

            // Remove loading message
            const loading = container.querySelector('.loading');
            if (loading) {
                loading.remove();
            }

            const card = document.createElement('div');
            card.className = 'trading-card size-big';
            card.id = cardId;

            // Make card clickable
            card.style.cursor = 'pointer';
            card.addEventListener('click', function(e) {
                // Don't trigger on close button or collapsible headers
                if (!e.target.classList.contains('card-close') &&
                    !e.target.closest('.collapsible-header')) {
                    openCardDetails(cardId);
                }
            });

            // Card title: TICKER on top, Monitor name below in smaller text
            const displayTitle = data.symbol || 'Unknown';
            const monitorName = data.monitor_config_name || data.test_name || '';

            card.innerHTML = `
                <div class="card-header">
                    <div>
                        <div class="card-title">${displayTitle}</div>
                        ${monitorName ? `<div class="card-subtitle">${monitorName}</div>` : ''}
                    </div>
                    <button class="card-close" onclick="removeCard('${cardId}')">&times;</button>
                </div>
                <div class="data-warning" style="display: none;"></div>
                <div class="price-display">$0.00</div>
                <div class="price-timestamp">Last updated: Never</div>
                <div class="collapsible-header" data-target="portfolio-section">
                    Portfolio <span class="toggle-icon">‚åÑ</span>
                </div>
                <div class="portfolio-container"></div>
                <div class="bars-container"></div>
            `;

            container.appendChild(card);
            
            // Setup collapsible headers for small mode
            setupCollapsibleHeaders(card, cardId);
            
            // Apply current global size
            applyGlobalSize(card);
            
            updateCardsCount();
            return card;
        }

        // Global size state
        let globalCardSize = 'big';

        // Setup collapsible headers for small cards
        function setupCollapsibleHeaders(card, cardId) {
            const headers = card.querySelectorAll('.collapsible-header');
            
            headers.forEach(header => {
                header.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent card click
                    toggleCollapsibleSection(card, cardId, this);
                });
            });
        }

        // Apply global size to a card
        function applyGlobalSize(card) {
            // Remove existing size classes
            card.classList.remove('size-big', 'size-medium', 'size-small');
            card.classList.add(`size-${globalCardSize}`);
        }

        // Set global card size for all cards
        function setGlobalCardSize(size) {
            globalCardSize = size;
            
            // Update global size button states
            const globalButtons = document.querySelectorAll('#globalSizeControls .size-btn');
            globalButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.size === size);
            });
            
            // Apply to all existing cards
            const allCards = document.querySelectorAll('.trading-card');
            allCards.forEach(card => {
                applyGlobalSize(card);
            });
            
            // Save global preference
            localStorage.setItem('global-card-size', size);
        }

        // Toggle collapsible sections in small mode with state preservation
        function toggleCollapsibleSection(card, cardId, header) {
            const target = header.dataset.target;
            const targetElement = card.querySelector(`.${target}`);
            const toggleIcon = header.querySelector('.toggle-icon');
            
            if (targetElement) {
                targetElement.classList.toggle('expanded');
                header.classList.toggle('expanded');
                
                // Update toggle icon
                toggleIcon.textContent = header.classList.contains('expanded') ? '‚åÉ' : '‚åÑ';
                
                // Save expanded state
                const isExpanded = targetElement.classList.contains('expanded');
                localStorage.setItem(`${cardId}-${target}-expanded`, isExpanded);
            }
        }

        // Restore expanded states for small mode elements
        function restoreExpandedStates(card, cardId) {
            if (globalCardSize !== 'small') return;
            
            const headers = card.querySelectorAll('.collapsible-header');
            headers.forEach(header => {
                const target = header.dataset.target;
                const isExpanded = localStorage.getItem(`${cardId}-${target}-expanded`) === 'true';
                
                if (isExpanded) {
                    const targetElement = card.querySelector(`.${target}`);
                    const toggleIcon = header.querySelector('.toggle-icon');
                    
                    if (targetElement) {
                        targetElement.classList.add('expanded');
                        header.classList.add('expanded');
                        toggleIcon.textContent = '‚åÉ';
                    }
                }
            });
        }

        // Function to open card details
        async function openCardDetails(cardId) {
            try {
                // Show loading indicator
                showMessage(`Loading details for ${cardId}...`, 'info');

                // Fetch card details
                const response = await fetch(`/api/combinations/${cardId}/details`);
                const data = await response.json();

                if (data.success) {
                    // Navigate to details page
                    window.location.href = `/card-details.html?card_id=${cardId}`;
                } else {
                    showMessage(`Error loading details: ${data.error}`, 'error');
                }

            } catch (error) {
                showMessage(`Error: ${error.message}`, 'error');
            }
        }

        function updateCardData(card, data) {
            console.log("UPDATE CARD DATA - Received data:", data);
            
            const cardId = card.id;

            // Preserve expanded state for price display before updating
            const priceExpanded = card.querySelector('.price-display')?.classList.contains('expanded');

            // Update price with timestamp
            const priceDisplay = card.querySelector('.price-display');
            const timestampDisplay = card.querySelector('.price-timestamp');

            if (priceDisplay && data.price !== undefined) {
                const priceClass = data.price >= 0 ? '' : 'negative';
                priceDisplay.className = `price-display ${priceClass}`;
                if (priceExpanded) priceDisplay.classList.add('expanded');
                priceDisplay.textContent = `${data.price.toFixed(2)}`;
            }

            // Update timestamp
            if (timestampDisplay && data.timestamp) {
                const updateTime = new Date(data.timestamp);
                timestampDisplay.textContent = `Last updated: ${updateTime.toLocaleTimeString()}`;
            }

            // Update portfolio section
            const portfolioContainer = card.querySelector('.portfolio-container');
            if (portfolioContainer) {
                portfolioContainer.innerHTML = renderPortfolioSection(data.portfolio, cardId);
            }

            // Update bar scores
            const barsContainer = card.querySelector('.bars-container');
            if (barsContainer && data.bar_scores) {
                console.log("UPDATE CARD DATA - Updating bars with:", data.bar_scores);
                barsContainer.innerHTML = renderBarScores(data.bar_scores);
            }

            // Update data warning for insufficient ticks
            const warningDiv = card.querySelector('.data-warning');
            if (warningDiv && data.data_status) {
                const warnings = data.data_status.warnings || [];
                if (warnings.length > 0 && !data.data_status.has_sufficient_data) {
                    warningDiv.textContent = `‚ö†Ô∏è ${warnings.join(', ')}`;
                    warningDiv.style.display = 'block';
                } else {
                    warningDiv.style.display = 'none';
                }
            }

            // Restore expanded states for small mode elements
            restoreExpandedStates(card, cardId);

            // Add updating animation
            card.classList.add('updating');
            setTimeout(() => card.classList.remove('updating'), 1000);

            // Store card data
            cards[card.id] = data;
        }

        // Portfolio section - always visible (no collapsible)
        function renderPortfolioSection(portfolio, cardId) {
            if (!portfolio) {
                return `
                    <div class="portfolio-section">
                        <div class="portfolio-header-static">
                            <span class="portfolio-title">Portfolio</span>
                            <span class="position-status no-position">NO DATA</span>
                        </div>
                        <div class="portfolio-metrics">
                            <div class="metric-item" style="grid-column: 1 / -1;">
                                <div class="metric-label">No Portfolio Data</div>
                                <div class="metric-value neutral">--</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            const position = portfolio.position || {};
            const pnl = portfolio.pnl || {};

            const isInPosition = position.is_in_position || false;
            const entryPrice = position.entry_price || 0;
            const currentPrice = position.current_price || 0;
            const positionSize = position.position_size || 0;

            // Use PERCENT values instead of dollar values
            const realizedPnlPercent = pnl.realized_pnl_percent || 0;
            const unrealizedPnlPercent = pnl.unrealized_pnl_percent || 0;
            const totalPnlPercent = pnl.total_pnl_percent || 0;

            const statusClass = isInPosition ? 'in-position' : 'no-position';
            const statusText = isInPosition ? 'IN POSITION' : 'NO POSITION';

            return `
                <div class="portfolio-section">
                    <div class="portfolio-header-static">
                        <span class="portfolio-title">Portfolio</span>
                        <span class="position-status ${statusClass}">${statusText}</span>
                    </div>
                    <div class="portfolio-metrics">
                        <div class="metric-item">
                            <div class="metric-label">Entry Price</div>
                            <div class="metric-value neutral">${entryPrice.toFixed(2)}</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Position Size</div>
                            <div class="metric-value neutral">${positionSize.toFixed(1)}</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Realized P&L</div>
                            <div class="metric-value ${realizedPnlPercent >= 0 ? 'positive' : 'negative'}">${realizedPnlPercent.toFixed(2)}%</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Unrealized P&L</div>
                            <div class="metric-value ${unrealizedPnlPercent >= 0 ? 'positive' : 'negative'}">${unrealizedPnlPercent.toFixed(2)}%</div>
                        </div>
                        <div class="metric-item" style="grid-column: 1 / -1;">
                            <div class="metric-label">Total P&L</div>
                            <div class="metric-value ${totalPnlPercent >= 0 ? 'positive' : 'negative'}">${totalPnlPercent.toFixed(2)}%</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderBarScores(barScores) {
            if (!barScores || Object.keys(barScores).length === 0) {
                return '<div style="text-align: center; color: #7d8590; padding: 1rem;">No bar data available</div>';
            }

            return Object.entries(barScores).map(([barName, score]) => {
                const displayName = formatBarName(barName);
                const percentage = (score * 100).toFixed(1);
                const clampedScore = Math.max(0, Math.min(1, score));

                // Determine color based on score
                let colorClass = '';
                let barColor = '';
                let barColorLight = '';
                let barGlow = '';

                if (score >= 0.7) {
                    colorClass = 'positive';
                    barColor = '#238636';
                    barColorLight = '#2ea043';
                    barGlow = '35, 134, 54';
                } else if (score >= 0.4) {
                    colorClass = 'neutral';
                    barColor = '#1f6feb';
                    barColorLight = '#388bfd';
                    barGlow = '31, 111, 235';
                } else {
                    colorClass = 'negative';
                    barColor = '#da3633';
                    barColorLight = '#ff7b72';
                    barGlow = '248, 81, 73';
                }

                return `
                    <div class="responsive-bar" style="--bar-color: ${barColor}; --bar-color-light: ${barColorLight}; --bar-glow: ${barGlow};">
                        <div class="bar-header">
                            <span class="bar-label">${displayName}</span>
                            <span class="bar-value-text ${colorClass}">${percentage}%</span>
                        </div>
                        <div class="bar-track">
                            <div class="bar-fill" style="width: ${clampedScore * 100}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function formatBarName(name) {
            return name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        async function removeCard(cardId) {
            if (!confirm(`Are you sure you want to remove ${cardId}?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/combinations/${cardId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    // Remove card from UI immediately
                    const card = document.getElementById(cardId);
                    if (card) {
                        card.remove();
                        delete cards[cardId];
                        updateCardsCount();

                        // Clean up localStorage
                        localStorage.removeItem(`portfolio-${cardId}`);
                        localStorage.removeItem(`card-size-${cardId}`);

                        // Show loading message if no cards left
                        const container = document.getElementById('cardsContainer');
                        if (container.children.length === 0) {
                            container.innerHTML = `
                                <div class="loading">
                                    <p>No trading cards active.</p>
                                    <p>Click "Add New Trading Card" above to get started.</p>
                                </div>
                            `;
                        }
                    }
                    showMessage(`Removed ${cardId}`, 'success');
                } else {
                    showMessage(`Error removing card: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`Error removing card: ${error.message}`, 'error');
            }
        }

        function showMessage(message, type) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `${type}-message`;
            messageDiv.textContent = message;

            messagesDiv.appendChild(messageDiv);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                messageDiv.remove();
            }, 5000);
        }

        // Modal functions
        function openAddCardModal() {
            document.getElementById('modalOverlay').style.display = 'block';
            document.body.style.overflow = 'hidden';
            document.getElementById('modalFileInput').value = '';
            updateSelectedFileName();
        }

        function closeAddCardModal() {
            document.getElementById('modalOverlay').style.display = 'none';
            document.body.style.overflow = 'auto';
            document.getElementById('modalSymbolInput').value = '';
            document.getElementById('modalFileInput').value = '';
            modalSelectedFile = null;
            updateSelectedFileName();
            updateModalAddButton();
        }

        function updateSelectedFileName() {
            const fileInput = document.getElementById('modalFileInput');
            const fileNameDiv = document.getElementById('selectedFileName');

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                fileNameDiv.textContent = `Selected: ${file.name}`;
                fileNameDiv.style.color = '#56d364';
                modalSelectedFile = file;
            } else {
                fileNameDiv.textContent = 'No file selected';
                fileNameDiv.style.color = '#7d8590';
                modalSelectedFile = null;
            }

            updateModalAddButton();
        }

        function updateModalAddButton() {
            const symbol = document.getElementById('modalSymbolInput').value.trim();
            const button = document.getElementById('modalAddButton');

            const isValid = symbol.length > 0 && modalSelectedFile;
            button.disabled = !isValid;
        }

        async function addCombinationFromModal() {
            const symbol = document.getElementById('modalSymbolInput').value.trim().toUpperCase();

            if (!symbol || !modalSelectedFile) {
                showMessage('Please enter a symbol and select a configuration file', 'error');
                return;
            }

            try {
                const configContent = await readFileAsText(modalSelectedFile);
                const configName = modalSelectedFile.name;

                const response = await fetch('/api/combinations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        config_content: configContent,
                        config_name: configName
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showMessage(`Added ${symbol} successfully!`, 'success');
                    closeAddCardModal();
                } else {
                    showMessage(`Error: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`Error adding combination: ${error.message}`, 'error');
            }
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        // Mobile sidebar toggle
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(e) {
            const sidebar = document.getElementById('sidebar');
            const toggle = document.querySelector('.mobile-menu-toggle');

            if (window.innerWidth <= 768 &&
                !sidebar.contains(e.target) &&
                !toggle.contains(e.target)) {
                sidebar.classList.remove('open');
            }
        });

        // Initialize global size controls
        function initializeGlobalSizeControls() {
            // Restore saved global size preference
            const savedSize = localStorage.getItem('global-card-size') || 'big';
            globalCardSize = savedSize;
            
            // Set up global size control buttons
            const globalButtons = document.querySelectorAll('#globalSizeControls .size-btn');
            globalButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.size === savedSize);
                
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    setGlobalCardSize(this.dataset.size);
                });
            });
        }

        // Event listeners that need to be set up after DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize global size controls
            initializeGlobalSizeControls();

            // Initialize pause-on-trade toggle
            initPauseOnTrade();

            // Initialize sound notification system
            initSoundSystem();

            // Fetch initial pip saver status
            fetchPipSaverStatus();
            // Add input listener for symbol field
            const symbolInput = document.getElementById('modalSymbolInput');
            if (symbolInput) {
                symbolInput.addEventListener('input', updateModalAddButton);

                // Enter key handler for symbol input
                symbolInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter' && !document.getElementById('modalAddButton').disabled) {
                        addCombinationFromModal();
                    }
                });
            }

            // Add file input listener
            const fileInput = document.getElementById('modalFileInput');
            if (fileInput) {
                fileInput.addEventListener('change', updateSelectedFileName);

                // Add drag and drop support
                fileInput.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.style.borderColor = '#1f6feb';
                });

                fileInput.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.style.borderColor = '#30363d';
                });

                fileInput.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.style.borderColor = '#30363d';

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.files = files;
                        updateSelectedFileName();
                    }
                });
            }

            // Modal overlay click to close
            document.getElementById('modalOverlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeAddCardModal();
                }
            });

            // Escape key to close modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('modalOverlay').style.display === 'block') {
                    closeAddCardModal();
                }
            });

            // Check if in replay mode and initialize replay controls
            initializeReplayMode();
        });

        // ============================================
        // Replay Mode Functions
        // ============================================

        let isReplayMode = false;
        let isReplayPaused = false;
        let pauseOnTradeEnabled = false;
        let lastTradeCountByCard = {};  // Track trade count per card to detect new trades

        // Initialize pause on trade toggle from localStorage
        function initPauseOnTrade() {
            const saved = localStorage.getItem('pauseOnTradeEnabled');
            pauseOnTradeEnabled = saved === 'true';
            const toggle = document.getElementById('pauseOnTradeToggle');
            if (toggle) {
                toggle.checked = pauseOnTradeEnabled;
                toggle.addEventListener('change', function() {
                    pauseOnTradeEnabled = this.checked;
                    localStorage.setItem('pauseOnTradeEnabled', pauseOnTradeEnabled);
                    console.log('Pause on Trade:', pauseOnTradeEnabled ? 'enabled' : 'disabled');
                });
            }
        }

        // Check if a new trade occurred and handle pause-on-trade
        function checkForNewTrade(cardId, portfolioData) {
            if (!portfolioData || !portfolioData.trade_history) return false;

            const currentTradeCount = portfolioData.trade_history.length;
            const previousTradeCount = lastTradeCountByCard[cardId] || 0;

            // Update tracked count
            lastTradeCountByCard[cardId] = currentTradeCount;

            // Check if new trade occurred
            if (currentTradeCount > previousTradeCount && previousTradeCount > 0) {
                console.log(`üîî New trade detected for ${cardId}! Trade count: ${previousTradeCount} ‚Üí ${currentTradeCount}`);

                // Flash the card to indicate a trade
                const cardElement = document.getElementById(`card-${cardId}`);
                if (cardElement) {
                    cardElement.classList.add('trade-flash');
                    setTimeout(() => cardElement.classList.remove('trade-flash'), 500);
                }

                return true;
            }
            return false;
        }

        // Handle pause-on-trade when a trade is detected
        function handleTradeDetected(cardId, tradeInfo) {
            if (!pauseOnTradeEnabled || !isReplayMode || isReplayPaused) return;

            console.log(`‚è∏Ô∏è Pausing replay due to trade on ${cardId}`);

            // Pause the replay
            socket.emit('replay_pause');
            isReplayPaused = true;
            updatePlayPauseButton();

            // Show a notification
            const lastTrade = tradeInfo?.trade_history?.[tradeInfo.trade_history.length - 1];
            const action = lastTrade?.action || 'Trade';
            const price = lastTrade?.price ? `@ $${lastTrade.price.toFixed(2)}` : '';
            showMessage(`${action} executed ${price} - Playback paused`, 'info');
        }

        function initializeReplayMode() {
            // Check session for replay mode
            fetch('/api/replay_status')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.is_replay_mode) {
                        isReplayMode = true;
                        showReplayControls(data);

                        // Set up socket listeners for replay events
                        setupReplaySocketListeners();
                    }
                })
                .catch(error => {
                    console.log('Not in replay mode or error checking:', error);
                });
        }

        function showReplayControls(data) {
            const controlsBar = document.getElementById('replayControlsBar');
            controlsBar.classList.add('active');

            // Update replay info
            if (data.ticker) {
                document.getElementById('replayTicker').textContent = data.ticker;
            }
            if (data.date) {
                document.getElementById('replayDate').textContent = data.date;
            }
            if (data.playback_speed) {
                document.getElementById('replaySpeedSelect').value = data.playback_speed;
            }
        }

        function setupReplaySocketListeners() {
            // Listen for replay progress updates
            socket.on('replay_progress', function(data) {
                updateReplayProgress(data.current, data.total, data.progress);
            });

            // Listen for replay complete
            socket.on('replay_complete', function() {
                showReplayComplete();
            });

            // Listen for replay state changes
            socket.on('replay_state', function(data) {
                if (data.paused !== undefined) {
                    isReplayPaused = data.paused;
                    updatePlayPauseButton();
                }
            });
        }

        function updateReplayProgress(current, total, progress) {
            const progressFill = document.getElementById('replayProgressFill');
            const progressText = document.getElementById('replayProgressText');

            if (progressFill) {
                progressFill.style.width = progress + '%';
            }
            if (progressText) {
                progressText.textContent = Math.round(progress) + '%';
            }
        }

        function toggleReplayPlayPause() {
            if (isReplayPaused) {
                socket.emit('replay_resume');
                isReplayPaused = false;
            } else {
                socket.emit('replay_pause');
                isReplayPaused = true;
            }
            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            const icon = document.getElementById('playPauseIcon');
            const text = document.getElementById('playPauseText');
            const btn = document.getElementById('replayPlayPauseBtn');

            if (isReplayPaused) {
                icon.textContent = '‚ñ∂';
                text.textContent = 'Resume';
                btn.classList.remove('primary');
                btn.classList.add('primary');
            } else {
                icon.textContent = '‚è∏';
                text.textContent = 'Pause';
                btn.classList.add('primary');
            }
        }

        function changeReplaySpeed(speed) {
            socket.emit('replay_speed', { speed: parseFloat(speed) });
        }

        function stopReplay() {
            if (confirm('Are you sure you want to stop the replay? This will end the current session.')) {
                socket.emit('replay_stop');
                // Redirect to replay setup
                window.location.href = '/replay';
            }
        }

        function showReplayComplete() {
            document.getElementById('replayCompleteOverlay').classList.add('active');
        }

        function restartReplay() {
            document.getElementById('replayCompleteOverlay').classList.remove('active');
            socket.emit('replay_restart');
            // Reset progress
            updateReplayProgress(0, 100, 0);
        }
    </script>
</body>
</html>