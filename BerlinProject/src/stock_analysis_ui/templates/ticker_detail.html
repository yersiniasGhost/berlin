{% extends 'base.html' %}

{% block title %}{{ symbol }} Analysis{% endblock %}

{% block head_extra %}
<style>
    .indicator-card {
        transition: all 0.3s ease;
    }
    .indicator-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    .candle-history {
        max-height: 500px;
        overflow-y: auto;
    }
    .chart-container {
        height: 400px;
    }
    .price-up {
        color: #28a745;
    }
    .price-down {
        color: #dc3545;
    }
    .indicator-progress {
        height: 8px;
    }
    .indicator-value {
        font-size: 1.25rem;
        font-weight: bold;
    }
    .raw-value {
        font-size: 0.8rem;
    }
    .ticker-header {
        display: flex;
        align-items: center;
    }
    .ticker-header .price {
        font-size: 2rem;
        font-weight: bold;
    }
    /* Visual indicators for candle types */
    .historical-candle {
        background-color: rgba(240, 240, 240, 0.5);
    }
    .live-candle {
        background-color: rgba(255, 250, 220, 0.5);
        font-weight: 500;
    }
</style>
{% endblock %}

{% block content %}
<div class="mb-4">
    <div class="d-flex justify-content-between align-items-center">
        <div>
            <a href="/" class="btn btn-outline-secondary mb-3">
                <i class="fas fa-arrow-left me-1"></i> Back to Dashboard
            </a>
        </div>
        <div>
            <div class="dropdown">
                <button class="btn btn-outline-primary dropdown-toggle" type="button" id="timeframeDropdown" data-bs-toggle="dropdown">
                    Timeframe: <span id="currentTimeframe">1m</span>
                </button>
                <ul class="dropdown-menu">
                    <li><a class="dropdown-item timeframe-option" href="#" data-timeframe="1m">1 Minute</a></li>
                    <li><a class="dropdown-item timeframe-option" href="#" data-timeframe="5m">5 Minutes</a></li>
                    <li><a class="dropdown-item timeframe-option" href="#" data-timeframe="15m">15 Minutes</a></li>
                    <li><a class="dropdown-item timeframe-option" href="#" data-timeframe="1h">1 Hour</a></li>
                </ul>
            </div>
        </div>
    </div>

    <div class="ticker-header mb-4">
        <h1 class="me-3">{{ symbol }}</h1>
        <div id="tickerPrice" class="price me-3">--</div>
        <div id="tickerChange" class="change"></div>
        <div class="ms-auto text-muted" id="lastUpdate"></div>
    </div>
</div>

<div class="row">
    <div class="col-lg-8">
        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Price Chart</h5>
                <span class="badge bg-secondary" id="chartStatus">Waiting for data...</span>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="priceChart"></canvas>
                    <div id="chartLoading" class="loading-overlay">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-white">
                <h5 class="mb-0">Signal Indicators</h5>
            </div>
            <div class="card-body">
                <div class="row" id="indicatorContainer">
                    <div class="col-12 text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div class="mt-3">Loading indicators...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="col-lg-4">
        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-white">
                <h5 class="mb-0">Overall Signal Strength</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label class="d-flex justify-content-between">
                        <span>Bullish Signal</span>
                        <span id="bullScore">0%</span>
                    </label>
                    <div class="progress mb-2" style="height: 20px;">
                        <div id="bullProgress" class="progress-bar bg-success" role="progressbar"
                             style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                </div>

                <div class="mb-3">
                    <label class="d-flex justify-content-between">
                        <span>Bearish Signal</span>
                        <span id="bearScore">0%</span>
                    </label>
                    <div class="progress mb-2" style="height: 20px;">
                        <div id="bearProgress" class="progress-bar bg-danger" role="progressbar"
                             style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Recent Candles</h5>
                <span class="badge bg-secondary" id="candleCount">0</span>
            </div>
            <div class="card-body p-0">
                <div class="candle-history" id="candleHistory">
                    <div class="text-center py-5">
                        <div class="text-muted">No candle data available</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mb-4 shadow-sm">
            <div class="card-header bg-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Latest Price Updates</h5>
                <span class="badge bg-primary" id="updateCount">0</span>
            </div>
            <div class="card-body p-0">
                <div class="candle-history" id="priceUpdates">
                    <div class="text-center py-5">
                        <div class="text-muted">No price updates available</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Initialize variables
    let symbol = "{{ symbol }}";  // From Flask template
    let tickerData = null;
    let priceChart = null;
    let chartData = {
        labels: [],
        prices: [],
        isHistorical: []  // Track if data point is historical
    };
    let indicators = {};
    let rawIndicators = {};
    let overallScores = {
        bull: 0,
        bear: 0
    };
    let lastCompletedCandleTime = null;

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', function() {
        console.log(`Initializing page for symbol: ${symbol}`);

        // Initialize chart
        initChart();

        // Load initial data
        loadInitialData();

        // Setup timeframe selector
        setupTimeframeSelector();

        // Set up debug testing functions
        setupDebugFunctions();
    });

    function initChart() {
        const ctx = document.getElementById('priceChart').getContext('2d');

        // Hide loading indicator
        document.getElementById('chartLoading').style.display = 'none';

        // Create empty data arrays
        const labels = [];
        const data = [];

        // Initialize the chart with better options for candle display
        priceChart = new Chart(ctx, {
            type: 'candlestick',  // Use candlestick if you have the financial plugin, otherwise 'line'
            data: {
                labels: labels,
                datasets: [{
                    label: `${symbol} Price`,
                    data: data,
                    borderColor: function(context) {
                        const index = context.dataIndex;
                        const value = context.dataset.data[index];
                        // For candlestick: green for bullish (close > open), red for bearish
                        return value && value.c > value.o ? 'rgba(75, 192, 92, 1)' : 'rgba(255, 92, 92, 1)';
                    },
                    backgroundColor: function(context) {
                        const index = context.dataIndex;
                        const value = context.dataset.data[index];
                        // For candlestick: green for bullish (close > open), red for bearish
                        return value && value.c > value.o ? 'rgba(75, 192, 92, 0.2)' : 'rgba(255, 92, 92, 0.2)';
                    },
                    borderWidth: 2,
                    pointStyle: 'candlestick',
                    pointRadius: 5,
                    pointHoverRadius: 7
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 0  // Disable animation for better performance with streaming data
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            displayFormats: {
                                minute: 'HH:mm'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        ticks: {
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 10
                        }
                    },
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: 'Price'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                // Format the time for display
                                const time = new Date(tooltipItems[0].parsed.x);
                                return time.toLocaleTimeString();
                            },
                            label: function(context) {
                                let label = context.dataset.label || '';

                                // For candlestick data
                                const dataPoint = context.raw;
                                if (dataPoint && (dataPoint.o !== undefined)) {
                                    return [
                                        `Open: $${dataPoint.o.toFixed(2)}`,
                                        `High: $${dataPoint.h.toFixed(2)}`,
                                        `Low: $${dataPoint.l.toFixed(2)}`,
                                        `Close: $${dataPoint.c.toFixed(2)}`
                                    ];
                                }

                                // For line chart fallback
                                if (context.parsed.y !== null) {
                                    label += `: $${context.parsed.y.toFixed(2)}`;
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });

        console.log("Chart initialized with empty data");
        document.getElementById('chartStatus').textContent = 'Chart ready';
        document.getElementById('chartStatus').className = 'badge bg-success';
    }

    function loadInitialData() {
        console.log("Loading initial data for symbol:", symbol);

        fetch(`/api/tickers?symbol=${symbol}`)
            .then(response => response.json())
            .then(data => {
                console.log("API data received:", data);

                // Check if we have history
                if (data.history && data.history[symbol]) {
                    console.log(`Found ${data.history[symbol].length} historical candles`);

                    // Update chart with history
                    updateChartWithHistoricalData(data.history[symbol]);

                    // Update candle table
                    updateCandleTable(data.history[symbol], true);

                    // Display the first few candles for debugging
                    if (data.history[symbol].length > 0) {
                        console.log("First candle:", data.history[symbol][0]);
                        console.log("Last candle:", data.history[symbol][data.history[symbol].length - 1]);

                        // Update ticker info from last candle
                        const lastCandle = data.history[symbol][data.history[symbol].length - 1];
                        updateTickerInfo(lastCandle);

                        // Set last completed candle time
                        if (lastCandle.timestamp) {
                            lastCompletedCandleTime = new Date(lastCandle.timestamp);
                            console.log("Set last completed candle time:", lastCompletedCandleTime);
                        }

                        // Update candle count
                        const countElem = document.getElementById('candleCount');
                        if (countElem) {
                            countElem.textContent = data.history[symbol].length;
                        }
                    }
                } else {
                    console.warn("No historical data found in API response");
                }

                // Check if we have indicators
                if (data.indicators && data.indicators[symbol]) {
                    indicators = data.indicators[symbol];
                    rawIndicators = (data.raw_indicators && data.raw_indicators[symbol])
                        ? data.raw_indicators[symbol] : {};
                    updateIndicatorUI();
                }

                // Check if we have overall scores
                if (data.overall_scores && data.overall_scores[symbol]) {
                    overallScores = data.overall_scores[symbol];
                    updateOverallScores();
                }
            })
            .catch(error => {
                console.error("Error fetching initial data:", error);
                document.getElementById('chartStatus').textContent = 'Error loading data';
                document.getElementById('chartStatus').className = 'badge bg-danger';
            });
    }

    function updateChartWithHistoricalData(candles) {
        console.log("Updating chart with historical data:", candles.length);

        if (!priceChart || !candles || candles.length === 0) {
            console.warn("Cannot update chart: missing data");
            return;
        }

        // Convert the candles to the format expected by the chart
        const chartData = candles.map(candle => {
            // Ensure the timestamp is a Date object
            const timestamp = new Date(candle.timestamp);

            // For candlestick chart
            return {
                t: timestamp,
                o: candle.open,
                h: candle.high,
                l: candle.low,
                c: candle.close,
                isHistorical: true
            };
        });

        // Update chart data
        priceChart.data.datasets[0].data = chartData;

        // Update chart
        priceChart.update();

        // Update chart status
        document.getElementById('chartStatus').textContent = `Loaded ${candles.length} historical candles`;
        document.getElementById('chartStatus').className = 'badge bg-info';

        console.log("Chart updated with historical data");
    }

    function updateTickerInfo(data) {
        // Update ticker price display
        const priceElem = document.getElementById('tickerPrice');
        if (priceElem && data.close) {
            priceElem.textContent = `$${parseFloat(data.close).toFixed(2)}`;
        }

        // Update change (if we have open price)
        const changeElem = document.getElementById('tickerChange');
        if (changeElem && data.open && data.close) {
            const change = data.close - data.open;
            const changePercent = (change / data.open) * 100;

            let changeClass = '';
            let changeSign = '';

            if (change > 0) {
                changeClass = 'price-up';
                changeSign = '+';
            } else if (change < 0) {
                changeClass = 'price-down';
                changeSign = '';
            }

            changeElem.textContent = `${changeSign}${change.toFixed(2)} (${changeSign}${changePercent.toFixed(2)}%)`;
            changeElem.className = `change ${changeClass}`;
        }

        // Update last update time
        const lastUpdateElem = document.getElementById('lastUpdate');
        if (lastUpdateElem && data.timestamp) {
            const time = new Date(data.timestamp);
            lastUpdateElem.textContent = `Last update: ${time.toLocaleTimeString()}`;
        }
    }

function updateCandleTable(candles, isHistorical = false) {
    const container = document.getElementById('candleHistory');
    if (!container) return;

    // Create table if it doesn't exist
    if (!container.querySelector('table')) {
        container.innerHTML = `
            <table class="table table-sm table-hover mb-0">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Open</th>
                        <th>High</th>
                        <th>Low</th>
                        <th>Close</th>
                        <th>Vol</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        `;
    }

    const tbody = container.querySelector('tbody');

    if (Array.isArray(candles)) {
        // For multiple candles (e.g., historical data load)
        // Clear existing rows if this is historical data
        if (isHistorical) {
            tbody.innerHTML = '';
        }

        // Add rows for each candle (most recent first)
        candles.slice().reverse().slice(0, 20).forEach(candle => {
            addCandleToTable(tbody, candle, isHistorical);
        });
    } else {
        // For single candle update
        addCandleToTable(tbody, candles, isHistorical);

        // Limit number of rows
        while (tbody.children.length > 20) {
            tbody.removeChild(tbody.lastChild);
        }
    }

    // Display candle count
    const countElem = document.getElementById('candleCount');
    if (countElem) {
        countElem.textContent = tbody.children.length;
    }
}

function addCandleToTable(tbody, candle, isHistorical) {
    const time = new Date(candle.timestamp).toLocaleTimeString();

    // Determine price direction
    const priceClass = candle.close > candle.open ? 'price-up' :
                     candle.close < candle.open ? 'price-down' : '';

    // Create new row
    const row = document.createElement('tr');
    row.className = isHistorical ? 'historical-candle' : 'live-candle';

    row.innerHTML = `
        <td>${time}</td>
        <td>${parseFloat(candle.open).toFixed(2)}</td>
        <td>${parseFloat(candle.high).toFixed(2)}</td>
        <td>${parseFloat(candle.low).toFixed(2)}</td>
        <td class="${priceClass}">${parseFloat(candle.close).toFixed(2)}</td>
        <td>${candle.volume || 0}</td>
    `;

    // Add at the top
    if (tbody.firstChild) {
        tbody.insertBefore(row, tbody.firstChild);
    } else {
        tbody.appendChild(row);
    }
}

// Socket.IO event handler for indicator updates
socket.on('indicator_update', function(data) {
    if (data.symbol !== symbol) {
        return;
    }

    console.log('Received indicator update:', data);

    // Store all indicator data
    indicators = data.indicators || {};
    rawIndicators = data.raw_indicators || {};
    overallScores = data.overall_scores || { bull: 0, bear: 0 };

    // Debug - check what indicators we're receiving
    console.log('Indicator data received:', indicators);
    console.log('Raw indicator data:', rawIndicators);

    // Update UI with indicator data
    updateIndicatorUI();

    // Update overall scores
    updateOverallScores();
});

// Function to update the indicator UI
function updateIndicatorUI() {
    const container = document.getElementById('indicatorContainer');

    // Clear container first
    container.innerHTML = '';

    // Check if we have indicator data
    if (!indicators || Object.keys(indicators).length === 0) {
        container.innerHTML = `
            <div class="col-12 text-center py-4">
                <div class="text-muted">No indicator data available</div>
            </div>
        `;
        return;
    }

    // Debug - log what indicators we're trying to display
    console.log('Updating UI with indicators:', indicators);

    // Create cards for each indicator
    for (const [name, value] of Object.entries(indicators)) {
        // Skip empty indicators
        if (value === undefined || value === null) {
            continue;
        }

        // Get raw value if available
        const rawValue = rawIndicators[name];

        // Create card column
        const col = document.createElement('div');
        col.className = 'col-md-6 col-lg-4 mb-3';

        // Determine indicator color based on value
        let indicatorColor = 'bg-secondary';
        let textColor = 'text-muted';

        // Check if this is a bullish or bearish indicator
        const isBearish = name.toLowerCase().includes('bear');

        if (isBearish) {
            // Bearish indicators
            if (value > 0.7) {
                indicatorColor = 'bg-danger';
                textColor = 'text-danger';
            } else if (value > 0.3) {
                indicatorColor = 'bg-warning';
                textColor = 'text-warning';
            }
        } else {
            // Bullish indicators
            if (value > 0.7) {
                indicatorColor = 'bg-success';
                textColor = 'text-success';
            } else if (value > 0.3) {
                indicatorColor = 'bg-info';
                textColor = 'text-primary';
            }
        }

        // Format display name
        const displayName = name
            .replace(/_/g, ' ')
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase());

        // Create card
        col.innerHTML = `
            <div class="card h-100 indicator-card">
                <div class="card-body">
                    <h6 class="card-title">${displayName}</h6>
                    <div class="badge ${isBearish ? 'bg-danger' : 'bg-success'} mb-1">
                        ${isBearish ? 'Bearish' : 'Bullish'}
                    </div>
                    <div class="progress mb-2 indicator-progress">
                        <div class="progress-bar ${indicatorColor}" role="progressbar"
                             style="width: ${value * 100}%"
                             aria-valuenow="${value * 100}"
                             aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                    <div class="d-flex align-items-center">
                        <div class="indicator-value ${textColor} me-2">${(value * 100).toFixed(1)}%</div>
                        ${rawValue !== undefined ? `<div class="raw-value text-muted">(Raw: ${rawValue.toFixed(4)})</div>` : ''}
                    </div>
                </div>
            </div>
        `;

        container.appendChild(col);
    }
}

    function updateOverallScores() {
        // Update bull/bear scores
        const bullScore = overallScores.bull || 0;
        const bearScore = overallScores.bear || 0;

        // Update UI
        document.getElementById('bullScore').textContent = `${(bullScore * 100).toFixed(1)}%`;
        document.getElementById('bullProgress').style.width = `${bullScore * 100}%`;
        document.getElementById('bullProgress').setAttribute('aria-valuenow', bullScore * 100);

        document.getElementById('bearScore').textContent = `${(bearScore * 100).toFixed(1)}%`;
        document.getElementById('bearProgress').style.width = `${bearScore * 100}%`;
        document.getElementById('bearProgress').setAttribute('aria-valuenow', bearScore * 100);
    }

    function setupTimeframeSelector() {
        const timeframeOptions = document.querySelectorAll('.timeframe-option');
        const currentTimeframeElem = document.getElementById('currentTimeframe');

        timeframeOptions.forEach(option => {
            option.addEventListener('click', function(e) {
                e.preventDefault();

                const timeframe = this.getAttribute('data-timeframe');
                currentTimeframeElem.textContent = timeframe;

                // Reload data with new timeframe
                console.log(`Changing timeframe to ${timeframe}`);
                loadDataWithTimeframe(timeframe);
            });
        });
    }

    function loadDataWithTimeframe(timeframe) {
        fetch(`/api/tickers?symbol=${symbol}&timeframe=${timeframe}`)
            .then(response => response.json())
            .then(data => {
                // Check for historical data
                if (data.history && data.history[symbol] && data.history[symbol].length > 0) {
                    const history = data.history[symbol];
                    console.log(`Found ${history.length} historical points for timeframe ${timeframe}`);

                    // Update chart with historical data
                    updateChartWithHistoricalData(history);

                    // Update candle table
                    updateCandleTable(history, true);

                    // Reset last completed candle time
                    if (history.length > 0) {
                        const lastCandle = history[history.length - 1];
                        if (lastCandle.timestamp) {
                            lastCompletedCandleTime = new Date(lastCandle.timestamp);
                            console.log("Reset last completed candle time:", lastCompletedCandleTime);
                        }
                    }
                } else {
                    console.warn(`No historical data found for timeframe ${timeframe}`);
                }
            })
            .catch(error => {
                console.error(`Error loading data for timeframe ${timeframe}:`, error);
            });
    }

    function updatePriceUpdatesTable(priceUpdate) {
        const container = document.getElementById('priceUpdates');
        if (!container) return;

        // Create table if it doesn't exist
        if (!container.querySelector('table')) {
            container.innerHTML = `
                <table class="table table-sm table-hover mb-0">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Price</th>
                            <th>Volume</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            `;
        }

        const tbody = container.querySelector('tbody');

        // Create new row
        const row = document.createElement('tr');
        const time = new Date(priceUpdate.timestamp).toLocaleTimeString();
        const price = parseFloat(priceUpdate.close).toFixed(2);
        const volume = priceUpdate.volume || 0;

        row.innerHTML = `
            <td>${time}</td>
            <td>${price}</td>
            <td>${volume}</td>
        `;

        // Add at the top
        if (tbody.firstChild) {
            tbody.insertBefore(row, tbody.firstChild);
        } else {
            tbody.appendChild(row);
        }

        // Limit number of rows
        while (tbody.children.length > 20) {
            tbody.removeChild(tbody.lastChild);
        }

        // Update count
        const countElem = document.getElementById('updateCount');
        if (countElem) {
            countElem.textContent = parseInt(countElem.textContent || '0') + 1;
        }
    }

    function appendCandleToChart(candle) {
        if (!priceChart || !candle) return;

        // Ensure timestamp is a Date object
        const timestamp = new Date(candle.timestamp);

        // Create data point for candlestick
        const dataPoint = {
            t: timestamp,
            o: candle.open,
            h: candle.high,
            l: candle.low,
            c: candle.close,
            isHistorical: false
        };

        // Check if this candle already exists in our data (by comparing timestamps)
        const existingIndex = priceChart.data.datasets[0].data.findIndex(d =>
            d.t && d.t.getTime() === timestamp.getTime()
        );

        if (existingIndex >= 0) {
            // Update existing candle
            priceChart.data.datasets[0].data[existingIndex] = dataPoint;
        } else {
            // Add new candle
            priceChart.data.datasets[0].data.push(dataPoint);

            // Limit data points to keep chart responsive
            if (priceChart.data.datasets[0].data.length > 100) {
                priceChart.data.datasets[0].data.shift();
            }
        }

        // Sort data by timestamp
        priceChart.data.datasets[0].data.sort((a, b) => a.t - b.t);

        // Update the chart
        priceChart.update();

        console.log("Chart updated with new candle");
    }

    function setupDebugFunctions() {
        // Expose for debugging in browser console
        window.debugFunctions = {
            showAllData: function() {
                console.log("All Chart Data:", priceChart ? priceChart.data : "Chart not initialized");
                console.log("Indicator Data:", indicators);
                console.log("Raw Indicators:", rawIndicators);
                console.log("Overall Scores:", overallScores);
            },
            simulateCandle: function() {
                // Create a simulated candle
                const now = new Date();
                const candle = {
                    timestamp: now.toISOString(),
                    open: 100 + Math.random() * 10,
                    high: 100 + Math.random() * 15,
                    low: 100 - Math.random() * 5,
                    close: 100 + Math.random() * 10,
                    volume: Math.floor(Math.random() * 1000)
                };

// Process the candle
                appendCandleToChart(candle);
                updateCandleTable(candle, false);
                updateTickerInfo(candle);

                console.log("Simulated candle:", candle);
            }
        };
    }

    // Socket.IO event handlers
    socket.on('ticker_update', function(data) {
        if (data.symbol !== symbol) {
            return;
        }

        console.log('Received ticker update:', data);

        // Update ticker info display
        if (data.data) {
            updateTickerInfo(data.data);

            // Also update the price updates table
            updatePriceUpdatesTable(data.data);
        }
    });

    // Handle current (in-progress) candle updates
    socket.on('current_candle_update', function(data) {
        if (data.symbol !== symbol) {
            return;
        }

        console.log('Received current candle update:', data);

        const candle = data.candle;

        // Update the ticker price display
        updateTickerInfo(candle);

        // If we have a chart, update the last candle as an in-progress one
        if (priceChart && priceChart.data.datasets[0].data.length > 0) {
            // Create a datapoint for the current in-progress candle
            const timestamp = new Date(candle.timestamp);
            const dataPoint = {
                t: timestamp,
                o: candle.open,
                h: candle.high,
                l: candle.low,
                c: candle.close,
                isHistorical: false,
                isCurrent: true
            };

            // Check if this is for the current minute/period
            // If we already have a completed candle for this period, don't overwrite it
            if (lastCompletedCandleTime) {
                // For 1m candles, round to the minute
                const currentPeriodStart = new Date(timestamp);
                currentPeriodStart.setSeconds(0);
                currentPeriodStart.setMilliseconds(0);

                const lastCompletedPeriodStart = new Date(lastCompletedCandleTime);
                lastCompletedPeriodStart.setSeconds(0);
                lastCompletedPeriodStart.setMilliseconds(0);

                // If this is for a newer period than our last completed candle
                if (currentPeriodStart > lastCompletedPeriodStart) {
                    // Find the last datapoint
                    const lastDataPoint = priceChart.data.datasets[0].data[priceChart.data.datasets[0].data.length - 1];

                    // If the last datapoint is not marked as current
                    if (!lastDataPoint.isCurrent) {
                        // Add a new datapoint for the current period
                        priceChart.data.datasets[0].data.push(dataPoint);
                    } else {
                        // Update the existing current datapoint
                        priceChart.data.datasets[0].data[priceChart.data.datasets[0].data.length - 1] = dataPoint;
                    }

                    // Update the chart
                    priceChart.update();
                }
            } else {
                // No completed candles yet, just add the current one
                priceChart.data.datasets[0].data.push(dataPoint);
                priceChart.update();
            }
        }
    });

    // Handle completed candles
    socket.on('candle_completed', function(data) {
        if (data.symbol !== symbol) {
            return;
        }

        console.log('Received completed candle:', data);

        const candle = data.candle;

        // Create date object from the timestamp string
        const timestamp = new Date(candle.timestamp);
        console.log('Converted timestamp:', timestamp);

        // Set last completed candle time
        lastCompletedCandleTime = timestamp;

        // Update the chart with the new completed candle
        appendCandleToChart(candle);

        // Update ticker display
        updateTickerInfo(candle);

        // Add to candle history table
        updateCandleTable(candle, false);

        // Update candle count
        const countElem = document.getElementById('candleCount');
        if (countElem) {
            countElem.textContent = parseInt(countElem.textContent || '0') + 1;
        }

        // Update chart status
        document.getElementById('chartStatus').textContent = 'Live data streaming';
        document.getElementById('chartStatus').className = 'badge bg-success';
    });


// Function to update indicators with detailed information
function updateIndicatorUIWithDetails(indicatorDetails) {
    const container = document.getElementById('indicatorContainer');

    // Clear loading spinner
    container.innerHTML = '';

    if (Object.keys(indicatorDetails).length === 0) {
        container.innerHTML = `
            <div class="col-12 text-center py-4">
                <div class="text-muted">No indicator data available</div>
            </div>
        `;
        return;
    }

    // Create cards for each indicator with detailed information
    for (const [name, details] of Object.entries(indicatorDetails)) {
        // Skip empty indicators
        if (details.value === undefined || details.value === null) {
            continue;
        }

        // Create card column
        const col = document.createElement('div');
        col.className = 'col-md-6 col-lg-4 mb-3';

        // Determine indicator color based on value
        let indicatorColor = 'bg-secondary';
        let textColor = 'text-muted';

        // Check if this is a bullish or bearish indicator
        const isBearish = name.toLowerCase().includes('bear');

        if (isBearish) {
            // Bearish indicators
            if (details.value > 0.7) {
                indicatorColor = 'bg-danger';
                textColor = 'text-danger';
            } else if (details.value > 0.3) {
                indicatorColor = 'bg-warning';
                textColor = 'text-warning';
            }
        } else {
            // Bullish indicators
            if (details.value > 0.7) {
                indicatorColor = 'bg-success';
                textColor = 'text-success';
            } else if (details.value > 0.3) {
                indicatorColor = 'bg-info';
                textColor = 'text-primary';
            }
        }

        // Format display name
        const displayName = name
            .replace(/_/g, ' ')
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase());

        // Create card with detailed transformation info
        let detailsHtml = '';
        if (details.raw_value !== undefined) {
            detailsHtml += `<div class="raw-value mb-1">Raw value: <strong>${typeof details.raw_value === 'number' ? details.raw_value.toFixed(4) : details.raw_value}</strong></div>`;
        }

        if (details.ratio !== undefined) {
            detailsHtml += `<div class="small text-muted">Scaling factor: ${details.ratio.toFixed(4)}</div>`;
        }

        if (details.strength_pct !== undefined) {
            detailsHtml += `<div class="small text-muted">Strength: ${details.strength_pct}%</div>`;
        }

        if (details.decay !== undefined && details.decay < 1) {
            detailsHtml += `<div class="small text-muted">Time decay factor: ${details.decay.toFixed(4)}</div>`;
        }

        // Create card
        col.innerHTML = `
            <div class="card h-100 indicator-card">
                <div class="card-body">
                    <h6 class="card-title">${displayName}</h6>
                    <div class="badge ${isBearish ? 'bg-danger' : 'bg-success'} mb-1">
                        ${isBearish ? 'Bearish' : 'Bullish'}
                    </div>
                    <div class="progress mb-2 indicator-progress">
                        <div class="progress-bar ${indicatorColor}" role="progressbar"
                             style="width: ${details.value * 100}%"
                             aria-valuenow="${details.value * 100}"
                             aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                    <div class="d-flex align-items-center mb-1">
                        <div class="indicator-value ${textColor} me-2">${(details.value * 100).toFixed(1)}%</div>
                    </div>
                    ${detailsHtml}
                </div>
            </div>
        `;

        container.appendChild(col);
    }
}

</script>
{% endblock %}