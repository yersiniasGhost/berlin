{% extends "base.html" %}

{% block title %}Optimizer Visualization{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h2 class="mb-4">
                <i class="fas fa-dna me-2"></i>Optimizer Visualization
            </h2>
        </div>
    </div>
    
    <!-- Configuration Section -->
    <div class="row">
        <div class="col-12">
            {% set file_types = [
                {'key': 'ga_config', 'title': 'GA Configuration', 'description': 'Upload your genetic algorithm configuration JSON file'},
                {'key': 'data_config', 'title': 'Data Configuration', 'description': 'Upload your data configuration JSON file'}
            ] %}
            {% include 'components/file_upload.html' %}
        </div>
    </div>
    
    <!-- Configuration Editor -->
    <div class="row">
        <div class="col-12">
            {% set config_tabs = [
                {'key': 'ga_config', 'title': 'GA Config', 'icon': 'fas fa-dna'},
                {'key': 'data_config', 'title': 'Data Config', 'icon': 'fas fa-database'}
            ] %}
            {% include 'components/config_editor.html' %}
        </div>
    </div>
    
    <!-- Control Panel -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="row align-items-center">
                        <div class="col-md-8">
                            <button type="button" class="btn btn-success btn-lg me-3" id="startOptimizerBtn" disabled>
                                <i class="fas fa-play me-2"></i>Start Optimization
                            </button>
                            <button type="button" class="btn btn-warning btn-lg me-3" id="pauseOptimizerBtn" disabled>
                                <i class="fas fa-pause me-2"></i>Pause
                            </button>
                            <button type="button" class="btn btn-danger btn-lg me-3" id="stopOptimizerBtn" disabled>
                                <i class="fas fa-stop me-2"></i>Stop
                            </button>
                            <button type="button" class="btn btn-primary btn-lg" id="saveOptimizedConfigsBtn" disabled style="display: none;">
                                <i class="fas fa-trophy me-2"></i>Save Optimized Configs
                            </button>
                        </div>
                        <div class="col-md-4">
                            <div class="progress mb-2" style="height: 25px;">
                                <div class="progress-bar" id="optimizationProgress" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                                    <span id="progressText">Ready</span>
                                </div>
                            </div>
                            <small class="text-muted" id="optimizationStatus">Generation: 0 / 0</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Charts Section - Modular 2x3 Grid -->
    <div class="row" id="chartsSection" style="display: none;">
        <!-- Chart Grid Container -->
        <div class="col-12">
            <!-- Fixed Layout: Objective Evolution, Generation Performance Metrics, Candlestick Chart, Winning/Losing Trades -->
            
            <!-- 1. Objective Evolution and Parallel Coordinates - Side by Side with Fixed Widths -->
            <div class="row mb-4">
                <div class="col-auto">
                    <div class="card" style="width: 900px;">
                        <div class="card-header">
                            <h6 class="mb-0">Objective Evolution</h6>
                        </div>
                        <div class="card-body">
                            <div id="objectiveChart" style="height: 400px; width: 100%;"></div>
                        </div>
                    </div>
                </div>
                <div class="col-auto">
                    <div class="card" style="width: 900px;">
                        <div class="card-header">
                            <h6 class="mb-0">Elite Population - Parallel Coordinates</h6>
                        </div>
                        <div class="card-body">
                            <div id="parallelCoordsChart" style="height: 400px; width: 100%;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 2. Generation Performance Metrics and Candlestick Chart - Side by Side with Fixed Widths -->
            <div class="row mb-4">
                <div class="col-auto">
                    <div class="card" style="width: 900px;">
                        <div class="card-header">
                            <h6 class="mb-0">Generation Performance Metrics</h6>
                        </div>
                        <div class="card-body">
                            <div class="table-responsive" style="max-height: 400px; overflow-y: auto;">
                                <table class="table table-striped table-sm">
                                    <thead class="sticky-top bg-white">
                                        <tr>
                                            <th>Gen</th>
                                            <th>Total Trades</th>
                                            <th>Winning</th>
                                            <th>Losing</th>
                                            <th>Total P&L (%)</th>
                                            <th>Avg Win (%)</th>
                                            <th>Avg Loss (%)</th>
                                        </tr>
                                    </thead>
                                    <tbody id="metricsTable">
                                        <tr>
                                            <td colspan="7" class="text-center text-muted">No performance data yet</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-auto">
                    <div class="card" style="width: 900px;">
                        <div class="card-header">
                            <h6 class="mb-0">Current Best Strategy</h6>
                        </div>
                        <div class="card-body">
                            <div id="bestStrategyChart" style="height: 400px; width: 100%;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 5. Winning and Losing Trades Distribution - Side by Side -->
            <div class="row mb-4">
                <div class="col-lg-6">
                    <div class="card h-100">
                        <div class="card-header">
                            <h6 class="mb-0 text-success">Winning Trades Distribution</h6>
                        </div>
                        <div class="card-body">
                            <div id="winningTradesChart" style="height: 400px;"></div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-6">
                    <div class="card h-100">
                        <div class="card-header">
                            <h6 class="mb-0 text-danger">Losing Trades Distribution</h6>
                        </div>
                        <div class="card-body">
                            <div id="losingTradesChart" style="height: 400px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    

</div>
{% endblock %}

{% block extra_scripts %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const startOptimizerBtn = document.getElementById('startOptimizerBtn');
    const pauseOptimizerBtn = document.getElementById('pauseOptimizerBtn');
    const stopOptimizerBtn = document.getElementById('stopOptimizerBtn');
    const chartsSection = document.getElementById('chartsSection');
    const saveOptimizedConfigsBtn = document.getElementById('saveOptimizedConfigsBtn');
    
    let charts = {};
    let optimizationRunning = false;
    let pollInterval = null;
    let addedGenerations = new Set(); // Track which generations have been added to the table
    
    // Initialize WebSocket connection
    function initializeWebSocket() {
        window.socket = io();
        
        window.socket.on('optimization_started', function(data) {
            showAlert('Optimization started successfully!', 'success');
            console.log('Optimization started:', data);
        });
        
        window.socket.on('generation_complete', function(data) {
            console.log('Generation complete:', data.generation);
            updateProgressBar(data.progress);
            updateCharts(data.optimizer_charts || data.chart_data || {});
        });
        
        window.socket.on('optimization_complete', function(data) {
            showAlert('Optimization completed!', 'success');
            optimizationRunning = false;
            saveOptimizedConfigsBtn.style.display = 'inline-block';
            saveOptimizedConfigsBtn.disabled = false;
            startOptimizerBtn.disabled = false;
            pauseOptimizerBtn.disabled = true;
            stopOptimizerBtn.disabled = true;
        });
        
        window.socket.on('optimization_error', function(data) {
            showAlert(`Optimization error: ${data.error}`, 'danger');
            resetButtons();
        });
        
        window.socket.on('optimization_paused', function(data) {
            showAlert('Optimization paused', 'info');
        });
        
        window.socket.on('optimization_resumed', function(data) {
            showAlert('Optimization resumed', 'info');
        });
        
        window.socket.on('optimization_stopped', function(data) {
            showAlert('Optimization fully stopped', 'warning');
            saveOptimizedConfigsBtn.style.display = 'inline-block';
            saveOptimizedConfigsBtn.disabled = false;
            startOptimizerBtn.disabled = false;
            pauseOptimizerBtn.disabled = true;
            stopOptimizerBtn.disabled = true;
        });
    }
    
    // Initialize WebSocket on page load
    initializeWebSocket();
    
    // Listen for config changes to enable/disable start button
    document.addEventListener('configurationsLoaded', function(e) {
        console.log('üîß configurationsLoaded event triggered');
        console.log('üîß Event detail:', e.detail);
        console.log('üîß window.currentConfigs:', window.currentConfigs);
        console.log('üîß Button element:', startOptimizerBtn);
        console.log('üîß Button disabled before:', startOptimizerBtn.disabled);
        
        startOptimizerBtn.disabled = false;
        console.log('üîß Button disabled after:', startOptimizerBtn.disabled);
        console.log('üîß Button classes:', startOptimizerBtn.className);
    });
    
    // Add debug logging for page load
    console.log('üîß Optimizer page JavaScript loaded');
    console.log('üîß Start button element:', startOptimizerBtn);
    console.log('üîß Start button initially disabled:', startOptimizerBtn.disabled);
    
    // Start optimization
    startOptimizerBtn.addEventListener('click', async function() {
        if (!window.currentConfigs || !window.currentConfigs.ga_config || !window.currentConfigs.data_config) {
            showAlert('Please load both GA and data configurations first', 'warning');
            return;
        }
        
        try {
            this.disabled = true;
            pauseOptimizerBtn.disabled = false;
            stopOptimizerBtn.disabled = false;

            // Reset pause button to "Pause" state when starting new optimization
            pauseOptimizerBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Pause';
            pauseOptimizerBtn.className = 'btn btn-warning btn-lg me-3';

            hideElitesButton(); // Hide save button when starting new optimization
            clearAllChartsAndData(); // Clear previous optimization data
            
            const response = await fetch('/optimizer/api/start_optimization', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ga_config: window.currentConfigs.ga_config,
                    data_config: window.currentConfigs.data_config
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                optimizationRunning = true;
                showAlert('Configurations prepared, starting optimization...', 'info');
                
                // Now trigger the WebSocket to actually start the optimization
                if (window.socket) {
                    window.socket.emit('start_optimization', {
                        ga_config_path: result.ga_config_path,
                        data_config_path: result.data_config_path
                    });
                } else {
                    // Initialize socket if not already done
                    initializeWebSocket();
                    setTimeout(() => {
                        window.socket.emit('start_optimization', {
                            ga_config_path: result.ga_config_path,
                            data_config_path: result.data_config_path
                        });
                    }, 100);
                }
                
                startPolling();
                showCharts();
            } else {
                throw new Error(result.error || 'Failed to start optimization');
            }
            
        } catch (error) {
            showAlert(`Failed to start optimization: ${error.message}`, 'danger');
            resetButtons();
        }
    });
    
    // Pause/Resume optimization
    pauseOptimizerBtn.addEventListener('click', async function() {
        const isPaused = this.innerHTML.includes('Resume');
        
        try {
            let response;
            if (isPaused) {
                // Resume optimization
                response = await fetch('/optimizer/api/resume_optimization', {
                    method: 'POST'
                });
            } else {
                // Pause optimization
                response = await fetch('/optimizer/api/pause_optimization', {
                    method: 'POST'
                });
            }
            
            const result = await response.json();
            
            if (result.success) {
                if (isPaused) {
                    // Changed from Resume back to Pause
                    this.innerHTML = '<i class="fas fa-pause me-2"></i>Pause';
                    this.className = 'btn btn-warning btn-lg me-3';
                    optimizationRunning = true;
                    startOptimizerBtn.disabled = true;
                    hideElitesButton(); // Hide save button when resuming
                    showAlert('Optimization resumed', 'info');
                    startPolling();
                } else {
                    // Changed from Pause to Resume
                    this.innerHTML = '<i class="fas fa-play me-2"></i>Resume';
                    this.className = 'btn btn-success btn-lg me-3';
                    optimizationRunning = false;
                    startOptimizerBtn.disabled = true; // Keep start disabled when paused
                    
                    // Show save button when paused (user might want to save current elites)
                    saveOptimizedConfigsBtn.style.display = 'inline-block';
                    saveOptimizedConfigsBtn.disabled = false;
                    
                    showAlert('Optimization paused', 'info');
                    stopPolling();
                }
            } else {
                throw new Error(result.error || `Failed to ${isPaused ? 'resume' : 'pause'} optimization`);
            }
            
        } catch (error) {
            showAlert(`Failed to ${isPaused ? 'resume' : 'pause'} optimization: ${error.message}`, 'danger');
        }
    });
    
    // Stop optimization
    stopOptimizerBtn.addEventListener('click', async function() {
        try {
            const response = await fetch('/optimizer/api/stop_optimization', {
                method: 'POST'
            });
            
            const result = await response.json();
            
            if (result.success) {
                showAlert('Optimization stopped', 'warning');
                resetButtons(); // This will reset pause button to "Pause" state
                saveOptimizedConfigsBtn.style.display = 'inline-block';
                saveOptimizedConfigsBtn.disabled = false;
            } else {
                throw new Error(result.error || 'Failed to stop optimization');
            }
            
        } catch (error) {
            showAlert(`Failed to stop optimization: ${error.message}`, 'danger');
        }
    });
    
    function resetButtons() {
        startOptimizerBtn.disabled = false;
        pauseOptimizerBtn.disabled = true;
        stopOptimizerBtn.disabled = true;
        optimizationRunning = false;
        
        // Reset pause button to original state
        pauseOptimizerBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Pause';
        pauseOptimizerBtn.className = 'btn btn-warning btn-lg me-3';
        
        // Clear all data when stopping/resetting
        clearAllChartsAndData();
    }
    
    function showCharts() {
        chartsSection.style.display = 'block';
        initializeCharts();
    }
    
    function initializeCharts() {
        // Initialize empty charts
        charts.objective = Highcharts.chart('objectiveChart', {
            chart: { type: 'line' },
            title: { text: 'Objective Evolution' },
            xAxis: { title: { text: 'Generation' } },
            yAxis: { title: { text: 'Objective Value' } },
            series: [], // Will be dynamically populated
            credits: { enabled: false },
            legend: { enabled: true }
        });
        
        // Initialize parallel coordinates chart (like old app)
        charts.parallelCoords = Highcharts.chart('parallelCoordsChart', {
            chart: {
                type: 'line',
                parallelCoordinates: true,
                parallelAxes: {
                    lineWidth: 2,
                    gridlinesWidth: 1
                }
            },
            title: { text: 'Elite Population Analysis' },
            plotOptions: {
                series: {
                    animation: { duration: 500 },
                    lineWidth: 2.5,
                    opacity: 0.75,
                    marker: { enabled: false }
                }
            },
            legend: { enabled: false },
            credits: { enabled: false }
        });
        
        // Initialize winning trades distribution chart
        charts.winningTrades = Highcharts.chart('winningTradesChart', {
            chart: { type: 'column' },
            title: { text: 'Winning Trades Distribution' },
            xAxis: { 
                title: { text: 'Percentage Gain (%)' },
                categories: []
            },
            yAxis: { 
                title: { text: 'Number of Trades' },
                min: 0 
            },
            series: [{
                name: 'Winning Trades',
                data: [],
                color: '#28a745'
            }],
            credits: { enabled: false }
        });

        // Initialize losing trades distribution chart
        charts.losingTrades = Highcharts.chart('losingTradesChart', {
            chart: { type: 'column' },
            title: { text: 'Losing Trades Distribution' },
            xAxis: { 
                title: { text: 'Percentage Loss (%)' },
                categories: []
            },
            yAxis: { 
                title: { text: 'Number of Trades' },
                min: 0 
            },
            series: [{
                name: 'Losing Trades',
                data: [],
                color: '#dc3545'
            }],
            credits: { enabled: false }
        });
        
        charts.bestStrategy = Highcharts.chart('bestStrategyChart', {
            chart: { 
                type: 'candlestick',
                zoomType: 'xy',
                panKey: 'shift',
                panning: {
                    enabled: true,
                    type: 'xy'
                },
                events: {
                    load: function() {
                        // Add mouse wheel zoom support
                        const chartContainer = this.container;
                        
                        chartContainer.addEventListener('wheel', function(e) {
                            // Only zoom on wheel over chart area
                            if (e.target.closest('.highcharts-container')) {
                                e.preventDefault();
                                
                                const chart = chartContainer.chart || chartContainer.hcChart;
                                if (chart && chart.xAxis && chart.xAxis[0] && chart.yAxis && chart.yAxis[0]) {
                                    const xAxis = chart.xAxis[0];
                                    const yAxis = chart.yAxis[0];
                                    
                                    // Get current extremes
                                    const currentXMin = xAxis.min;
                                    const currentXMax = xAxis.max;
                                    const currentYMin = yAxis.min;
                                    const currentYMax = yAxis.max;
                                    
                                    const xRange = currentXMax - currentXMin;
                                    const yRange = currentYMax - currentYMin;
                                    
                                    // Zoom factor
                                    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                                    const newXRange = xRange * zoomFactor;
                                    const newYRange = yRange * zoomFactor;
                                    
                                    // Get mouse position for zoom center
                                    const rect = chartContainer.getBoundingClientRect();
                                    const mouseX = e.clientX - rect.left;
                                    const mouseY = e.clientY - rect.top;
                                    const plotLeft = chart.plotLeft;
                                    const plotTop = chart.plotTop;
                                    const plotWidth = chart.plotWidth;
                                    const plotHeight = chart.plotHeight;
                                    
                                    // Calculate zoom centers
                                    let xCenterRatio = 0.5;
                                    let yCenterRatio = 0.5;
                                    
                                    if (mouseX >= plotLeft && mouseX <= plotLeft + plotWidth) {
                                        xCenterRatio = (mouseX - plotLeft) / plotWidth;
                                    }
                                    if (mouseY >= plotTop && mouseY <= plotTop + plotHeight) {
                                        yCenterRatio = 1 - ((mouseY - plotTop) / plotHeight); // Invert Y
                                    }
                                    
                                    // Calculate new extremes
                                    const xCenter = currentXMin + (xRange * xCenterRatio);
                                    const yCenter = currentYMin + (yRange * yCenterRatio);
                                    
                                    const newXMin = xCenter - (newXRange * xCenterRatio);
                                    const newXMax = xCenter + (newXRange * (1 - xCenterRatio));
                                    const newYMin = yCenter - (newYRange * yCenterRatio);
                                    const newYMax = yCenter + (newYRange * (1 - yCenterRatio));
                                    
                                    // Apply zoom
                                    xAxis.setExtremes(newXMin, newXMax, false);
                                    yAxis.setExtremes(newYMin, newYMax, true);
                                }
                            }
                        });
                    }
                }
            },
            title: { text: 'Best Strategy Performance' },
            xAxis: { 
                type: 'datetime',
                ordinal: true, // Use ordinal axis to remove all gaps
                breaks: [], // Clear any default breaks
                crosshair: true
            },
            yAxis: { 
                title: { text: 'Price' },
                crosshair: true
            },
            plotOptions: {
                candlestick: {
                    upColor: '#28a745',
                    color: '#dc3545',
                    upLineColor: '#28a745',
                    lineColor: '#dc3545'
                }
            },
            series: [{
                name: 'Price',
                data: [],
                type: 'candlestick'
            }],
            credits: { enabled: false },
            tooltip: {
                xDateFormat: '%Y-%m-%d %H:%M',
                shared: true
            }
        });
    }
    
    function startPolling() {
<!--        pollInterval = setInterval(updateProgress, 2000); // Poll every 2 seconds-->
    }
    
    function stopPolling() {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }
    }
    
    async function updateProgress() {
        try {
            const response = await fetch('/optimizer/api/get_progress');
            const data = await response.json();
            
            if (data.success) {
                updateProgressBar(data.progress);
                updateCharts(data.charts);
                
                // Show save button if we have elites
                if (data.elites && data.elites.length > 0) {
                    saveOptimizedConfigsBtn.style.display = 'inline-block';
                    saveOptimizedConfigsBtn.disabled = false;
                }
                
                if (data.progress.completed) {
                    showAlert('Optimization completed!', 'success');
                    // Show completion popup for saving elites
                    showCompletionSavePopup();
                    resetButtons();
                    stopPolling();
                }
            }
            
        } catch (error) {
            console.error('Failed to update progress:', error);
        }
    }
    
    function updateProgressBar(progress) {
        const progressBar = document.getElementById('optimizationProgress');
        const progressText = document.getElementById('progressText');
        const statusText = document.getElementById('optimizationStatus');
        
        const percentage = Math.round((progress.current_generation / progress.total_generations) * 100);
        
        progressBar.style.width = `${percentage}%`;
        progressBar.setAttribute('aria-valuenow', percentage);
        progressText.textContent = `${percentage}%`;
        statusText.textContent = `Generation: ${progress.current_generation} / ${progress.total_generations}`;
    }
    
    function updateCharts(chartData) {
        console.log('Updating charts with data:', chartData);
        
        // 1. Update Objective Evolution Chart - Multiple objectives as separate lines
        if (chartData.objective_evolution && charts.objective) {
            console.log('Updating objective evolution with:', chartData.objective_evolution);
            
            // Colors for different objectives
            const objectiveColors = {
                'MaximizeProfit': '#28a745',
                'MinimizeLoss': '#dc3545',
                'MaximizeNetPnL': '#007bff',
                'MaximizeWinRate': '#ffc107',
                'MinimizeDrawdown': '#6f42c1'
            };
            
            // Clear existing series
            while(charts.objective.series.length > 0) {
                charts.objective.series[0].remove(false);
            }
            
            // Add series for each objective
            Object.keys(chartData.objective_evolution).forEach((objectiveName, index) => {
                const data = chartData.objective_evolution[objectiveName];
                const color = objectiveColors[objectiveName] || Highcharts.getOptions().colors[index];
                
                charts.objective.addSeries({
                    name: objectiveName,
                    data: data,
                    color: color,
                    lineWidth: 2
                }, false);
            });
            
            charts.objective.redraw();
        }
        
        // 2. Update Parallel Coordinates Chart (like old app)
        if (chartData.elite_population_data && chartData.objective_names && charts.parallelCoords) {
            console.log('Updating parallel coordinates with:', chartData.elite_population_data);
            
            const eliteData = chartData.elite_population_data;
            const objectiveNames = chartData.objective_names;
            
            if (eliteData.length > 0 && objectiveNames.length > 0) {
                // Destroy and recreate chart with proper configuration (like old app)
                if (charts.parallelCoords) {
                    charts.parallelCoords.destroy();
                }
                
                const colors = Highcharts.getOptions().colors;
                const colorCount = colors.length;

                // Normalize data for single y-axis display
                const normalizedData = [];
                const originalData = [];
                const objectiveRanges = [];
                
                // Calculate ranges for each objective
                objectiveNames.forEach((objName, objIndex) => {
                    const values = eliteData.map(elite => elite[objIndex]);
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    objectiveRanges.push({ min, max, range: max - min || 1 });
                });
                
                // Normalize each elite's data to [0,1] range
                eliteData.forEach((elite, eliteIndex) => {
                    const normalizedElite = elite.map((value, objIndex) => {
                        const { min, range } = objectiveRanges[objIndex];
                        return range > 0 ? (value - min) / range : 0.5;
                    });
                    normalizedData.push(normalizedElite);
                    originalData.push(elite);
                });

                const chartConfig = {
                    chart: {
                        type: 'line',
                        parallelCoordinates: true,
                        parallelAxes: {
                            lineWidth: 2,
                            gridlinesWidth: 1
                        }
                    },
                    title: {
                        text: `Elite Population Analysis (${eliteData.length} Individuals)`,
                        style: { fontSize: '14px', fontWeight: 'bold' }
                    },
                    plotOptions: {
                        series: {
                            animation: { duration: 500 },
                            lineWidth: 2.5,
                            opacity: 0.75,
                            states: {
                                hover: { lineWidth: 4, opacity: 1 }
                            },
                            marker: {
                                enabled: false,
                                states: {
                                    hover: { enabled: true, radius: 4 }
                                }
                            }
                        }
                    },
                    tooltip: {
                        formatter: function() {
                            let tooltipText = '<b>Elite Individual #' + (this.series.index + 1) + '</b><br/>';
                            const individualData = originalData[this.series.index];
                            objectiveNames.forEach(function(objName, i) {
                                tooltipText += objName + ': ' + Highcharts.numberFormat(individualData[i], 4) + '<br/>';
                            });
                            return tooltipText;
                        }
                    },
                    legend: { enabled: false },
                    credits: { enabled: false },
                    xAxis: {
                        categories: objectiveNames,
                        lineWidth: 0,
                        labels: {
                            style: { fontWeight: 'bold', fontSize: '11px' },
                            rotation: -45
                        }
                    },
                    yAxis: {
                        min: 0,
                        max: 1,
                        title: { text: 'Normalized Values' },
                        labels: {
                            format: '{value:.1f}'
                        },
                        gridLineWidth: 1
                    },
                    series: normalizedData.map((elite, index) => ({
                        name: `Elite ${index + 1}`,
                        data: elite,
                        color: colors[index % colorCount],
                        lineWidth: index === 0 ? 3 : 2.5,
                        opacity: index === 0 ? 0.9 : 0.75
                    }))
                };

                charts.parallelCoords = Highcharts.chart('parallelCoordsChart', chartConfig);
            }
        }
        
        // 3. Update Winning Trades Distribution Chart
        if (chartData.winning_trades_distribution && charts.winningTrades) {
            const categories = chartData.winning_trades_distribution.map(item => item[0]);
            const data = chartData.winning_trades_distribution.map(item => item[1]);
            
            charts.winningTrades.update({
                xAxis: { categories: categories }
            }, false);
            charts.winningTrades.series[0].setData(data, true);
        }
        
        // 4. Update Losing Trades Distribution Chart  
        if (chartData.losing_trades_distribution && charts.losingTrades) {
            const categories = chartData.losing_trades_distribution.map(item => item[0]);
            const data = chartData.losing_trades_distribution.map(item => item[1]);
            
            charts.losingTrades.update({
                xAxis: { categories: categories }
            }, false);
            charts.losingTrades.series[0].setData(data, true);
        }
        
        // 4. Update Best Strategy Chart
        if (chartData.best_strategy && charts.bestStrategy) {
            // Update with candlestick data and trade triggers
            const candlestickData = chartData.best_strategy.candlestick_data || [];
            const triggers = chartData.best_strategy.triggers || [];
            const trades = chartData.best_strategy.trades || [];
            
            charts.bestStrategy.series[0].setData(candlestickData, false);
            
            // Remove old signal series if they exist (we're replacing triangles with background bands)
            while (charts.bestStrategy.series.length > 1) {
                charts.bestStrategy.series[charts.bestStrategy.series.length - 1].remove(false);
            }
            
            // Clear existing plot bands
            if (charts.bestStrategy.xAxis[0].plotLinesAndBands) {
                charts.bestStrategy.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                    if (band.options.className && band.options.className.includes('trade-band')) {
                        band.destroy();
                    }
                });
            }
            
            // Add background shading bands for complete trades
            if (trades && trades.length > 0) {
                trades.forEach((trade, index) => {
                    if (trade.entry_time && trade.exit_time) {
                        const isProfit = trade.pnl > 0;
                        const bandColor = isProfit ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)'; // Green or red with transparency
                        
                        charts.bestStrategy.xAxis[0].addPlotBand({
                            from: new Date(trade.entry_time).getTime(),
                            to: new Date(trade.exit_time).getTime(),
                            color: bandColor,
                            className: `trade-band trade-${index}`,
                            id: `trade-band-${index}`,
                            zIndex: 0, // Behind the candlesticks
                            label: {
                                text: `${isProfit ? '+' : ''}${trade.pnl.toFixed(2)}%`,
                                align: 'center',
                                style: {
                                    color: isProfit ? '#28a745' : '#dc3545',
                                    fontWeight: 'bold',
                                    fontSize: '10px'
                                }
                            }
                        });
                    }
                });
            } else if (triggers && triggers.length > 0) {
                // Fallback: If no complete trades, try to pair buy/sell signals
                const buySignals = triggers.filter(t => t.type === 'buy').sort((a, b) => a.timestamp - b.timestamp);
                const sellSignals = triggers.filter(t => t.type === 'sell').sort((a, b) => a.timestamp - b.timestamp);
                
                // Pair buy and sell signals to create trade bands
                let buyIndex = 0, sellIndex = 0;
                let tradeCount = 0;
                
                while (buyIndex < buySignals.length && sellIndex < sellSignals.length) {
                    const buySignal = buySignals[buyIndex];
                    const sellSignal = sellSignals[sellIndex];
                    
                    if (buySignal.timestamp < sellSignal.timestamp) {
                        // Found a valid trade pair
                        const estimatedPnl = ((sellSignal.price - buySignal.price) / buySignal.price) * 100;
                        const isProfit = estimatedPnl > 0;
                        const bandColor = isProfit ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)';
                        
                        charts.bestStrategy.xAxis[0].addPlotBand({
                            from: buySignal.timestamp,
                            to: sellSignal.timestamp,
                            color: bandColor,
                            className: `trade-band trade-${tradeCount}`,
                            id: `trade-band-${tradeCount}`,
                            zIndex: 0,
                            label: {
                                text: `${isProfit ? '+' : ''}${estimatedPnl.toFixed(2)}%`,
                                align: 'center',
                                style: {
                                    color: isProfit ? '#28a745' : '#dc3545',
                                    fontWeight: 'bold',
                                    fontSize: '10px'
                                }
                            }
                        });
                        
                        buyIndex++;
                        sellIndex++;
                        tradeCount++;
                    } else {
                        sellIndex++;
                    }
                }
            }
            
            charts.bestStrategy.redraw();
        }
        
        // 5. Update Performance Metrics Table
        if (chartData.performance_metrics) {
            updatePerformanceMetricsTable(chartData.performance_metrics);
        }
    }
    
    function updatePerformanceMetricsTable(metricsData) {
        const tableBody = document.getElementById('metricsTable');
        
        if (!metricsData || metricsData.length === 0) {
            return; // Don't clear existing data, just don't add new data
        }
        
        // Clear the "No performance data yet" message if it exists
        if (tableBody.innerHTML.includes('No performance data yet')) {
            tableBody.innerHTML = '';
        }
        
        // Only add new generations that haven't been added before
        metricsData.forEach(metric => {
            const generation = metric.generation;
            
            if (!addedGenerations.has(generation)) {
                addedGenerations.add(generation);
                
                const pnlClass = metric.total_pnl >= 0 ? 'text-success' : 'text-danger';
                
                const newRow = `
                    <tr id="generation-${generation}">
                        <td><strong>${generation}</strong></td>
                        <td>${metric.total_trades}</td>
                        <td class="text-success">${metric.winning_trades}</td>
                        <td class="text-danger">${metric.losing_trades}</td>
                        <td class="${pnlClass}">${metric.total_pnl.toFixed(2)}%</td>
                        <td class="text-success">${metric.avg_win.toFixed(2)}%</td>
                        <td class="text-danger">${metric.avg_loss.toFixed(2)}%</td>
                    </tr>
                `;
                
                tableBody.insertAdjacentHTML('beforeend', newRow);
                
                // Scroll to bottom to show latest generation
                const tableContainer = tableBody.closest('.table-responsive');
                if (tableContainer) {
                    tableContainer.scrollTop = tableContainer.scrollHeight;
                }
            }
        });
    }
    
    // Initialize charts when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // No layout management needed for fixed layout
        console.log('Optimizer visualization page loaded with fixed layout');
    });
    
    
    // Show completion popup for saving optimized configs
    function showCompletionSavePopup() {
        if (confirm('üèÜ Optimization completed!\n\nWould you like to save the optimized configurations and results?')) {
            saveOptimizedConfigs();
        }
    }
    
    // Save Optimized Configs function
    async function saveOptimizedConfigs() {
        const saveBtn = document.getElementById('saveOptimizedConfigsBtn');
        const originalText = saveBtn.innerHTML;
        
        try {
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Saving...';
            
            // Get complete optimization package (like old system)
            const response = await fetch('/optimizer/api/export_optimized_configs');
            const result = await response.json();
            
            if (result.success) {
                const package = result.package;
                const folderName = package.folder_name;
                
                console.log('üèÜ Received optimization package:', package);
                
                // Download all files organized with folder prefix in filenames
                const confirmDownload = confirm(
                    `Save optimization results to Downloads folder?\n\n` +
                    `Folder: ${folderName}\n` +
                    `Elite configs: ${package.elites_count}\n` +
                    `Total files: ${Object.keys(package.files).length + 3}\n\n` +
                    `Files will be saved with folder prefix for easy organization.`
                );
                
                if (!confirmDownload) return;
                
                // Download all files with folder prefix for easy organization
                const allFiles = [];
                
                // Add elite configs
                for (const [filename, config] of Object.entries(package.files)) {
                    allFiles.push({
                        filename: `${folderName}/${filename}`,
                        content: JSON.stringify(config, null, 2),
                        type: 'application/json'
                    });
                }
                
                // Add objectives CSV
                if (package.objectives_csv) {
                    allFiles.push({
                        filename: `${folderName}/${package.objectives_filename}`,
                        content: package.objectives_csv,
                        type: 'text/csv'
                    });
                }
                
                // Add GA config
                allFiles.push({
                    filename: `${folderName}/${package.ga_config_filename}`,
                    content: JSON.stringify(package.ga_config, null, 2),
                    type: 'application/json'
                });
                
                // Add summary
                allFiles.push({
                    filename: `${folderName}/${package.summary_filename}`,
                    content: package.summary,
                    type: 'text/plain'
                });
                
                // Download all files with folder structure in filename
                for (const file of allFiles) {
                    const blob = new Blob([file.content], { type: file.type });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = file.filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    await new Promise(resolve => setTimeout(resolve, 150)); // Small delay between downloads
                }
                
                showAlert(
                    `üèÜ Optimization results downloaded!\n\n` +
                    `${allFiles.length} files saved to Downloads folder.\n` +
                    `Files are prefixed with "${folderName}/" for easy organization.\n\n` +
                    `Elite configs: ${package.elites_count} (top performers)`, 
                    'success'
                );
            } else {
                showAlert(`Failed to get elite configurations: ${result.error || 'Unknown error'}`, 'danger');
            }
            
        } catch (error) {
            showAlert(`Failed to save best elite: ${error.message}`, 'danger');
        } finally {
            saveBtn.disabled = false;
            saveBtn.innerHTML = originalText;
        }
    }
    
    // Add click listener for save button
    saveOptimizedConfigsBtn.addEventListener('click', saveOptimizedConfigs);
    
    // Reset buttons state
    function resetButtons() {
        startOptimizerBtn.disabled = false;
        pauseOptimizerBtn.disabled = true;
        stopOptimizerBtn.disabled = true;
        optimizationRunning = false;
        // Keep save button visible if it was shown (user might still want to save)
    }
    
    // Hide save button when starting new optimization
    function hideElitesButton() {
        saveOptimizedConfigsBtn.style.display = 'none';
        saveOptimizedConfigsBtn.disabled = true;
    }
    
    // Clear all charts and data from previous optimization runs
    function clearAllChartsAndData() {
        console.log('üßπ Clearing all charts and data from previous run');
        
        // Clear the generations tracking set
        addedGenerations.clear();
        
        // Clear the performance metrics table
        const tableBody = document.getElementById('metricsTable');
        if (tableBody) {
            tableBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No performance data yet</td></tr>';
        }
        
        // Clear all chart data if charts exist
        if (charts.objective) {
            // Clear objective evolution chart
            while(charts.objective.series.length > 0) {
                charts.objective.series[0].remove(false);
            }
            charts.objective.redraw();
        }
        
        if (charts.parallelCoords) {
            // Clear parallel coordinates chart
            charts.parallelCoords.destroy();
            charts.parallelCoords = Highcharts.chart('parallelCoordsChart', {
                chart: {
                    type: 'line',
                    parallelCoordinates: true,
                    parallelAxes: {
                        lineWidth: 2,
                        gridlinesWidth: 1
                    }
                },
                title: { text: 'Elite Population Analysis' },
                plotOptions: {
                    series: {
                        animation: { duration: 500 },
                        lineWidth: 2.5,
                        opacity: 0.75,
                        marker: { enabled: false }
                    }
                },
                legend: { enabled: false },
                credits: { enabled: false }
            });
        }
        
        if (charts.winningTrades) {
            // Clear winning trades chart
            charts.winningTrades.series[0].setData([], true);
            charts.winningTrades.update({
                xAxis: { categories: [] }
            }, false);
        }
        
        if (charts.losingTrades) {
            // Clear losing trades chart
            charts.losingTrades.series[0].setData([], true);
            charts.losingTrades.update({
                xAxis: { categories: [] }
            }, false);
        }
        
        if (charts.bestStrategy) {
            // Clear best strategy chart
            charts.bestStrategy.series[0].setData([], false);
            
            // Clear any existing plot bands
            if (charts.bestStrategy.xAxis[0].plotLinesAndBands) {
                charts.bestStrategy.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                    if (band.options.className && band.options.className.includes('trade-band')) {
                        band.destroy();
                    }
                });
            }
            
            charts.bestStrategy.redraw();
        }
        
        // Reset progress bar
        const progressBar = document.getElementById('optimizationProgress');
        const progressText = document.getElementById('progressText');
        const statusText = document.getElementById('optimizationStatus');
        
        if (progressBar) {
            progressBar.style.width = '0%';
            progressBar.setAttribute('aria-valuenow', 0);
        }
        if (progressText) {
            progressText.textContent = 'Starting...';
        }
        if (statusText) {
            statusText.textContent = 'Generation: 0 / 0';
        }
        
        console.log('‚úÖ All charts and data cleared');
    }
});
</script>
{% endblock %}