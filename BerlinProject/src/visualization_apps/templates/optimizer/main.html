{% extends "base.html" %}

{% block title %}Optimizer Visualization{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/optimizer.css') }}">
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h2 class="mb-4">
                <i class="fas fa-dna me-2"></i>Optimizer Visualization
            </h2>
        </div>
    </div>

    {# File Selector Component #}
    {% include 'optimizer/components/_file_selector.html' %}

    {# Configuration Editor Component #}
    {% include 'optimizer/components/_config_editor.html' %}

    {# Control Panel Component #}
    {% include 'optimizer/components/_control_panel.html' %}

    {# Charts Section Component #}
    {% include 'optimizer/components/_charts_section.html' %}

    {# Test Evaluations Component #}
    {% include 'optimizer/components/_test_evaluations.html' %}

    {# Elite Selection Modal Component #}
    {% include 'optimizer/components/_elite_modal.html' %}

</div>
{% endblock %}

{% block extra_scripts %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
<script src="{{ url_for('static', filename='js/talib-patterns.js') }}"></script>
<script src="{{ url_for('static', filename='js/optimizer-config.js') }}"></script>
{# Performance optimization modules - load BEFORE WebSocket and UI integration #}
<script src="{{ url_for('static', filename='js/performance-monitor.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart-update-manager.js') }}"></script>
<script src="{{ url_for('static', filename='js/optimizer-websocket.js') }}"></script>
<script src="{{ url_for('static', filename='js/optimizer-ui-integration.js') }}"></script>

{# TODO: Split the massive inline script into modular files #}
{# Recommended structure:
   - static/js/optimizer/websocket.js - WebSocket connection and event handlers
   - static/js/optimizer/charts.js - Chart initialization and updates
   - static/js/optimizer/controls.js - Button handlers and UI controls
   - static/js/optimizer/parameters.js - Parameter histogram and evolution
   - static/js/optimizer/test-eval.js - Test evaluations table updates
   - static/js/optimizer/replay.js - Send to replay functionality
   - static/js/optimizer/main.js - Main initialization and coordination
#}

{# TEMPORARY: Include the original inline script until JavaScript refactoring is complete #}
{# TODO: Split this into modular files as documented in claudedocs/20251103_optimizer_template_refactoring.md #}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const startOptimizerBtn = document.getElementById('startOptimizerBtn');
    const pauseOptimizerBtn = document.getElementById('pauseOptimizerBtn');
    const stopOptimizerBtn = document.getElementById('stopOptimizerBtn');
    const chartsSection = document.getElementById('chartsSection');
    const saveOptimizedConfigsBtn = document.getElementById('saveOptimizedConfigsBtn');
    const loadEliteToFormsBtn = document.getElementById('loadEliteToFormsBtn');

    let charts = {};
    let optimizationRunning = false;
    let pollInterval = null;
    let addedGenerations = new Set(); // Track which generations have been added to the table

    // NOTE: WebSocket initialization moved to optimizer-websocket.js and optimizer-ui-integration.js
    // The old initializeWebSocket() function has been replaced with a robust connection manager
    // that handles reconnection, heartbeats, and connection monitoring

    // Listen for config changes to enable/disable start button
    document.addEventListener('configurationsLoaded', function(e) {
        console.log('üîß configurationsLoaded event triggered');
        console.log('üîß Event detail:', e.detail);
        console.log('üîß window.currentConfigs:', window.currentConfigs);
        console.log('üîß Button element:', startOptimizerBtn);
        console.log('üîß Button disabled before:', startOptimizerBtn.disabled);

        startOptimizerBtn.disabled = false;
        console.log('üîß Button disabled after:', startOptimizerBtn.disabled);
        console.log('üîß Button classes:', startOptimizerBtn.className);
    });

    // Add debug logging for page load
    console.log('üîß Optimizer page JavaScript loaded');
    console.log('üîß Start button element:', startOptimizerBtn);
    console.log('üîß Start button initially disabled:', startOptimizerBtn.disabled);

    // NOTE: Button event handlers moved to optimizer-ui-integration.js
    // Old start/pause/stop button handlers are now in OptimizerUIIntegration class

    /* OLD CODE - Replaced by optimizer-ui-integration.js
    // Start optimization
    startOptimizerBtn.addEventListener('click', async function() {
        if (!window.currentConfigs || !window.currentConfigs.ga_config || !window.currentConfigs.data_config) {
            showAlert('Please load both GA and data configurations first', 'warning');
            return;
        }

        try {
            this.disabled = true;
            pauseOptimizerBtn.disabled = false;
            stopOptimizerBtn.disabled = false;

            // Reset pause button to "Pause" state when starting new optimization
            pauseOptimizerBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Pause';
            pauseOptimizerBtn.className = 'btn btn-warning btn-lg me-3';

            hideEliteButtons(); // Hide save and load buttons when starting new optimization
            clearAllChartsAndData(); // Clear previous optimization data

            // IMPORTANT: Re-collect all configs from the UI to capture any edits made after loading
            // This ensures that date/ticker changes and other edits are reflected in the optimization
            const updatedGAConfig = collectAllConfigs();
            collectDataConfigData(); // Updates the global dataConfig with current UI values
            collectTestDataConfigData(); // Updates the global testDataConfig with current UI values

            const response = await fetch('/optimizer/api/start_optimization', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ga_config: updatedGAConfig,
                    data_config: dataConfig,
                    test_data_config: testDataConfig
                })
            });

            const result = await response.json();

            if (result.success) {
                optimizationRunning = true;
                showAlert('Configurations prepared, starting optimization...', 'info');

                // Now trigger the WebSocket to actually start the optimization
                if (window.socket) {
                    window.socket.emit('start_optimization', {
                        ga_config_path: result.ga_config_path,
                        data_config_path: result.data_config_path
                    });
                } else {
                    // Initialize socket if not already done
                    initializeWebSocket();
                    setTimeout(() => {
                        window.socket.emit('start_optimization', {
                            ga_config_path: result.ga_config_path,
                            data_config_path: result.data_config_path
                        });
                    }, 100);
                }

                startPolling();
                showCharts();
            } else {
                throw new Error(result.error || 'Failed to start optimization');
            }

        } catch (error) {
            showAlert(`Failed to start optimization: ${error.message}`, 'danger');
            resetButtons();
        }
    });

    // Pause/Resume optimization
    pauseOptimizerBtn.addEventListener('click', async function() {
        const isPaused = this.innerHTML.includes('Resume');

        try {
            let response;
            if (isPaused) {
                // Resume optimization
                response = await fetch('/optimizer/api/resume_optimization', {
                    method: 'POST'
                });
            } else {
                // Pause optimization
                response = await fetch('/optimizer/api/pause_optimization', {
                    method: 'POST'
                });
            }

            const result = await response.json();

            if (result.success) {
                if (isPaused) {
                    // Changed from Resume back to Pause
                    this.innerHTML = '<i class="fas fa-pause me-2"></i>Pause';
                    this.className = 'btn btn-warning btn-lg me-3';
                    optimizationRunning = true;
                    startOptimizerBtn.disabled = true;
                    hideEliteButtons(); // Hide save and load buttons when resuming
                    showAlert('Optimization resumed', 'info');
                    startPolling();
                } else {
                    // Changed from Pause to Resume
                    this.innerHTML = '<i class="fas fa-play me-2"></i>Resume';
                    this.className = 'btn btn-success btn-lg me-3';
                    optimizationRunning = false;
                    startOptimizerBtn.disabled = true; // Keep start disabled when paused

                    // Show save and load buttons when paused (user might want to save current elites or load them to forms)
                    saveOptimizedConfigsBtn.style.display = 'inline-block';
                    saveOptimizedConfigsBtn.disabled = false;
                    loadEliteToFormsBtn.style.display = 'inline-block';
                    loadEliteToFormsBtn.disabled = false;

                    showAlert('Optimization paused', 'info');
                    stopPolling();
                }
            } else {
                throw new Error(result.error || `Failed to ${isPaused ? 'resume' : 'pause'} optimization`);
            }

        } catch (error) {
            showAlert(`Failed to ${isPaused ? 'resume' : 'pause'} optimization: ${error.message}`, 'danger');
        }
    });

    // Stop optimization
    stopOptimizerBtn.addEventListener('click', async function() {
        try {
            const response = await fetch('/optimizer/api/stop_optimization', {
                method: 'POST'
            });

            const result = await response.json();

            if (result.success) {
                showAlert('Optimization stopped', 'warning');
                resetButtons(); // This will reset pause button to "Pause" state
                saveOptimizedConfigsBtn.style.display = 'inline-block';
                saveOptimizedConfigsBtn.disabled = false;
            } else {
                throw new Error(result.error || 'Failed to stop optimization');
            }

        } catch (error) {
            showAlert(`Failed to stop optimization: ${error.message}`, 'danger');
        }
    });
    END OF OLD CODE BEING REPLACED */

    function resetButtons() {
        startOptimizerBtn.disabled = false;
        pauseOptimizerBtn.disabled = true;
        stopOptimizerBtn.disabled = true;
        optimizationRunning = false;

        // Reset pause button to original state
        pauseOptimizerBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Pause';
        pauseOptimizerBtn.className = 'btn btn-warning btn-lg me-3';

        // Clear all data when stopping/resetting
        clearAllChartsAndData();
    }

    function showCharts() {
        chartsSection.style.display = 'block';
        document.getElementById('testEvaluationsSection').style.display = 'block';
        initializeCharts();
    }

    function initializeCharts() {
        console.log('üé¨ Initializing all charts...');

        // Initialize empty charts
        console.log('üìä Initializing objective chart...');
        charts.objective = Highcharts.chart('objectiveChart', {
            chart: { type: 'line' },
            title: { text: 'Objective Evolution' },
            xAxis: { title: { text: 'Generation' } },
            yAxis: { title: { text: 'Objective Value' } },
            series: [], // Will be dynamically populated
            credits: { enabled: false },
            legend: { enabled: true }
        });

        // Initialize parallel coordinates chart (like old app)
        charts.parallelCoords = Highcharts.chart('parallelCoordsChart', {
            chart: {
                type: 'line',
                parallelCoordinates: true,
                parallelAxes: {
                    lineWidth: 2,
                    gridlinesWidth: 1
                }
            },
            title: { text: 'Elite Population Analysis' },
            plotOptions: {
                series: {
                    animation: { duration: 500 },
                    lineWidth: 2.5,
                    opacity: 0.75,
                    marker: { enabled: false }
                }
            },
            legend: { enabled: false },
            credits: { enabled: false }
        });

        // Initialize winning trades distribution chart
        charts.winningTrades = Highcharts.chart('winningTradesChart', {
            chart: { type: 'column' },
            title: { text: 'Winning Trades Distribution' },
            xAxis: {
                title: { text: 'Percentage Gain (%)' },
                categories: []
            },
            yAxis: {
                title: { text: 'Number of Trades' },
                min: 0
            },
            series: [{
                name: 'Winning Trades',
                data: [],
                color: '#28a745'
            }],
            credits: { enabled: false }
        });

        // Initialize losing trades distribution chart
        charts.losingTrades = Highcharts.chart('losingTradesChart', {
            chart: { type: 'column' },
            title: { text: 'Losing Trades Distribution' },
            xAxis: {
                title: { text: 'Percentage Loss (%)' },
                categories: []
            },
            yAxis: {
                title: { text: 'Number of Trades' },
                min: 0
            },
            series: [{
                name: 'Losing Trades',
                data: [],
                color: '#dc3545'
            }],
            credits: { enabled: false }
        });

        charts.bestStrategy = Highcharts.chart('bestStrategyChart', {
            chart: {
                type: 'candlestick',
                zoomType: 'xy',
                panKey: 'shift',
                panning: {
                    enabled: true,
                    type: 'xy'
                },
                events: {
                    load: function() {
                        // Add mouse wheel zoom support
                        const chartContainer = this.container;

                        chartContainer.addEventListener('wheel', function(e) {
                            // Only zoom on wheel over chart area
                            if (e.target.closest('.highcharts-container')) {
                                e.preventDefault();

                                const chart = chartContainer.chart || chartContainer.hcChart;
                                if (chart && chart.xAxis && chart.xAxis[0] && chart.yAxis && chart.yAxis[0]) {
                                    const xAxis = chart.xAxis[0];
                                    const yAxis = chart.yAxis[0];

                                    // Get current extremes
                                    const currentXMin = xAxis.min;
                                    const currentXMax = xAxis.max;
                                    const currentYMin = yAxis.min;
                                    const currentYMax = yAxis.max;

                                    const xRange = currentXMax - currentXMin;
                                    const yRange = currentYMax - currentYMin;

                                    // Zoom factor
                                    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                                    const newXRange = xRange * zoomFactor;
                                    const newYRange = yRange * zoomFactor;

                                    // Get mouse position for zoom center
                                    const rect = chartContainer.getBoundingClientRect();
                                    const mouseX = e.clientX - rect.left;
                                    const mouseY = e.clientY - rect.top;
                                    const plotLeft = chart.plotLeft;
                                    const plotTop = chart.plotTop;
                                    const plotWidth = chart.plotWidth;
                                    const plotHeight = chart.plotHeight;

                                    // Calculate zoom centers
                                    let xCenterRatio = 0.5;
                                    let yCenterRatio = 0.5;

                                    if (mouseX >= plotLeft && mouseX <= plotLeft + plotWidth) {
                                        xCenterRatio = (mouseX - plotLeft) / plotWidth;
                                    }
                                    if (mouseY >= plotTop && mouseY <= plotTop + plotHeight) {
                                        yCenterRatio = 1 - ((mouseY - plotTop) / plotHeight); // Invert Y
                                    }

                                    // Calculate new extremes
                                    const xCenter = currentXMin + (xRange * xCenterRatio);
                                    const yCenter = currentYMin + (yRange * yCenterRatio);

                                    const newXMin = xCenter - (newXRange * xCenterRatio);
                                    const newXMax = xCenter + (newXRange * (1 - xCenterRatio));
                                    const newYMin = yCenter - (newYRange * yCenterRatio);
                                    const newYMax = yCenter + (newYRange * (1 - yCenterRatio));

                                    // Apply zoom
                                    xAxis.setExtremes(newXMin, newXMax, false);
                                    yAxis.setExtremes(newYMin, newYMax, true);
                                }
                            }
                        });
                    }
                }
            },
            title: { text: 'Best Strategy Performance' },
            xAxis: {
                type: 'datetime',
                ordinal: true, // Use ordinal axis to remove all gaps
                breaks: [], // Clear any default breaks
                crosshair: true
            },
            yAxis: {
                title: { text: 'Price' },
                crosshair: true
            },
            plotOptions: {
                candlestick: {
                    upColor: '#28a745',
                    color: '#dc3545',
                    upLineColor: '#28a745',
                    lineColor: '#dc3545'
                }
            },
            series: [{
                name: 'Price',
                data: [],
                type: 'candlestick'
            }],
            credits: { enabled: false },
            tooltip: {
                xDateFormat: '%Y-%m-%d %H:%M',
                shared: true
            }
        });

        // Initialize parameter histogram chart
        console.log('üìä Initializing parameter histogram chart...');
        charts.parameterHistogram = Highcharts.chart('parameterHistogramChart', {
            chart: { type: 'column' },
            title: {
                text: 'Select a parameter from the dropdown above',
                style: { fontSize: '14px', color: '#999' }
            },
            subtitle: { text: '' },
            xAxis: {
                title: { text: 'Parameter Value' },
                categories: [],
                labels: {
                    rotation: -45,
                    style: { fontSize: '10px' }
                }
            },
            yAxis: {
                title: { text: 'Frequency' },
                min: 0
            },
            series: [{
                name: 'Population',
                data: [],
                color: '#3498db',
                borderWidth: 0
            }, {
                name: 'Elites',
                data: [],
                color: '#e74c3c',
                borderWidth: 0
            }],
            plotOptions: {
                column: {
                    borderWidth: 0,
                    groupPadding: 0.1,
                    pointPadding: 0.05
                }
            },
            legend: {
                enabled: true,
                align: 'right',
                verticalAlign: 'top',
                layout: 'vertical',
                x: 0,
                y: 50
            },
            credits: { enabled: false },
            tooltip: {
                formatter: function() {
                    const total = this.series.data.reduce((sum, point) => sum + point.y, 0);
                    const percentage = ((this.y / total) * 100).toFixed(1);
                    return '<b>' + this.x + '</b><br/>' +
                           this.series.name + ': <b>' + this.y + '</b><br/>' +
                           'Percentage: <b>' + percentage + '%</b>';
                }
            }
        });

        // Initialize parameter evolution chart
        console.log('üìä Initializing parameter evolution chart...');
        charts.parameterEvolution = Highcharts.chart('parameterEvolutionChart', {
            chart: {
                type: 'line',
                zoomType: 'x'
            },
            title: {
                text: 'Select a parameter from the dropdown above',
                style: { fontSize: '14px', color: '#999' }
            },
            subtitle: { text: '' },
            xAxis: {
                title: { text: 'Generation' },
                min: 0,
                allowDecimals: false
            },
            yAxis: {
                title: { text: 'Parameter Value' }
            },
            series: [{
                name: 'Mean',
                data: [],
                color: '#3498db',
                lineWidth: 2,
                marker: { enabled: true, radius: 3 }
            }, {
                name: 'Elite Mean',
                data: [],
                color: '#e74c3c',
                lineWidth: 2,
                marker: { enabled: true, radius: 3 },
                dashStyle: 'ShortDash'
            }, {
                name: 'Std Dev',
                data: [],
                color: '#95a5a6',
                lineWidth: 1,
                marker: { enabled: false },
                dashStyle: 'Dot'
            }, {
                name: 'Min',
                data: [],
                color: '#27ae60',
                lineWidth: 1,
                marker: { enabled: false },
                dashStyle: 'ShortDot'
            }, {
                name: 'Max',
                data: [],
                color: '#e67e22',
                lineWidth: 1,
                marker: { enabled: false },
                dashStyle: 'ShortDot'
            }],
            plotOptions: {
                line: {
                    animation: true
                }
            },
            legend: {
                enabled: true,
                align: 'right',
                verticalAlign: 'middle',
                layout: 'vertical'
            },
            credits: { enabled: false },
            tooltip: {
                shared: true,
                crosshairs: true,
                formatter: function() {
                    let tooltip = '<b>Generation ' + this.x + '</b><br/>';
                    this.points.forEach(point => {
                        tooltip += '<span style="color:' + point.color + '">\u25CF</span> ' +
                                   point.series.name + ': <b>' + point.y.toFixed(4) + '</b><br/>';
                    });
                    return tooltip;
                }
            }
        });

        console.log('‚úÖ All charts initialized successfully!');
        console.log('Charts object:', {
            objective: !!charts.objective,
            parallelCoords: !!charts.parallelCoords,
            winningTrades: !!charts.winningTrades,
            losingTrades: !!charts.losingTrades,
            bestStrategy: !!charts.bestStrategy,
            parameterHistogram: !!charts.parameterHistogram,
            parameterEvolution: !!charts.parameterEvolution
        });

        // Register all charts with the performance-optimized chart update manager
        if (window.chartUpdateManager) {
            console.log('üìä Registering charts with performance-optimized update manager...');
            window.chartUpdateManager.registerChart('objective', charts.objective);
            window.chartUpdateManager.registerChart('parallelCoords', charts.parallelCoords);
            window.chartUpdateManager.registerChart('winningTrades', charts.winningTrades);
            window.chartUpdateManager.registerChart('losingTrades', charts.losingTrades);
            window.chartUpdateManager.registerChart('bestStrategy', charts.bestStrategy);
            window.chartUpdateManager.registerChart('parameterHistogram', charts.parameterHistogram);
            window.chartUpdateManager.registerChart('parameterEvolution', charts.parameterEvolution);
            console.log('‚úÖ All charts registered with update manager');
        } else {
            console.warn('‚ö†Ô∏è Chart update manager not available - performance optimizations disabled');
        }

        // Enable performance monitoring HUD for development
        if (window.perfMonitor && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) {
            console.log('üí° Performance monitoring available. Call perfMonitor.showHUD() to display metrics.');
        }
    }

    function startPolling() {
<!--        pollInterval = setInterval(updateProgress, 2000); // Poll every 2 seconds-->
    }

    function stopPolling() {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }
    }

    async function updateProgress() {
        try {
            const response = await fetch('/optimizer/api/get_progress');
            const data = await response.json();

            if (data.success) {
                updateProgressBar(data.progress);
                updateCharts(data.charts);

                // Show save button if we have elites
                if (data.elites && data.elites.length > 0) {
                    saveOptimizedConfigsBtn.style.display = 'inline-block';
                    saveOptimizedConfigsBtn.disabled = false;
                }

                if (data.progress.completed) {
                    showAlert('Optimization completed!', 'success');
                    // Show completion popup for saving elites
                    showCompletionSavePopup();
                    resetButtons();
                    stopPolling();
                }
            }

        } catch (error) {
            console.error('Failed to update progress:', error);
        }
    }

    function updateProgressBar(progress) {
        const progressBar = document.getElementById('optimizationProgress');
        const progressText = document.getElementById('progressText');
        const statusText = document.getElementById('optimizationStatus');

        const percentage = Math.round((progress.current_generation / progress.total_generations) * 100);

        progressBar.style.width = `${percentage}%`;
        progressBar.setAttribute('aria-valuenow', percentage);
        progressText.textContent = `${percentage}%`;
        statusText.textContent = `Generation: ${progress.current_generation} / ${progress.total_generations}`;
    }

    function updateCharts(chartData) {
        console.log('üìä updateCharts called with data:', chartData);
        console.log('üìä Charts object state:', {
            objective: !!charts.objective,
            parallelCoords: !!charts.parallelCoords,
            bestStrategy: !!charts.bestStrategy
        });

        // Check if charts are initialized
        if (!charts.objective || !charts.parallelCoords) {
            console.warn('‚ö†Ô∏è Charts not initialized! Calling initializeCharts()...');
            initializeCharts();
        }

        // 1. Update Objective Evolution Chart - Multiple objectives as separate lines
        if (chartData.objective_evolution) {
            if (!charts.objective) {
                console.error('‚ùå charts.objective is not initialized!');
            } else {
                console.log('üìà Updating objective evolution chart');
                console.log('üìà Data keys:', Object.keys(chartData.objective_evolution));
                console.log('üìà Data sample:', chartData.objective_evolution);

                // Colors for different objectives
                const objectiveColors = {
                    'MaximizeProfit': '#28a745',
                    'MinimizeLoss': '#dc3545',
                    'MaximizeNetPnL': '#007bff',
                    'MaximizeWinRate': '#ffc107',
                    'MinimizeDrawdown': '#6f42c1'
                };

                // Clear existing series
                while(charts.objective.series.length > 0) {
                    charts.objective.series[0].remove(false);
                }

                // Add series for each objective
                Object.keys(chartData.objective_evolution).forEach((objectiveName, index) => {
                    const data = chartData.objective_evolution[objectiveName];
                    const color = objectiveColors[objectiveName] || Highcharts.getOptions().colors[index];

                    charts.objective.addSeries({
                        name: objectiveName,
                        data: data,
                        color: color,
                        lineWidth: 2
                    }, false);
                });

                charts.objective.redraw();
                console.log('‚úÖ Objective evolution chart updated');
            }
        } else {
            console.log('‚è≠Ô∏è No objective_evolution data in chartData');
        }

        // 2. Update Parallel Coordinates Chart (like old app)
        if (chartData.elite_population_data && chartData.objective_names && charts.parallelCoords) {
            console.log('üìä Updating parallel coordinates chart');
            console.log('üìä Elite data count:', chartData.elite_population_data.length);
            console.log('üìä Objectives:', chartData.objective_names);

            const eliteData = chartData.elite_population_data;
            const objectiveNames = chartData.objective_names;

            if (eliteData.length > 0 && objectiveNames.length > 0) {
                // Destroy and recreate chart with proper configuration (like old app)
                if (charts.parallelCoords) {
                    charts.parallelCoords.destroy();
                }

                const colors = Highcharts.getOptions().colors;
                const colorCount = colors.length;

                // Normalize data for single y-axis display
                const normalizedData = [];
                const originalData = [];
                const objectiveRanges = [];

                // Calculate ranges for each objective
                objectiveNames.forEach((objName, objIndex) => {
                    const values = eliteData.map(elite => elite[objIndex]);
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    objectiveRanges.push({ min, max, range: max - min || 1 });
                });

                // Normalize each elite's data to [0,1] range
                eliteData.forEach((elite, eliteIndex) => {
                    const normalizedElite = elite.map((value, objIndex) => {
                        const { min, range } = objectiveRanges[objIndex];
                        return range > 0 ? (value - min) / range : 0.5;
                    });
                    normalizedData.push(normalizedElite);
                    originalData.push(elite);
                });

                const chartConfig = {
                    chart: {
                        type: 'line',
                        parallelCoordinates: true,
                        parallelAxes: {
                            lineWidth: 2,
                            gridlinesWidth: 1
                        }
                    },
                    title: {
                        text: `Elite Population Analysis (${eliteData.length} Individuals)`,
                        style: { fontSize: '14px', fontWeight: 'bold' }
                    },
                    plotOptions: {
                        series: {
                            animation: { duration: 500 },
                            lineWidth: 2.5,
                            opacity: 0.75,
                            states: {
                                hover: { lineWidth: 4, opacity: 1 }
                            },
                            marker: {
                                enabled: false,
                                states: {
                                    hover: { enabled: true, radius: 4 }
                                }
                            }
                        }
                    },
                    tooltip: {
                        formatter: function() {
                            let tooltipText = '<b>Elite Individual #' + (this.series.index + 1) + '</b><br/>';
                            const individualData = originalData[this.series.index];
                            objectiveNames.forEach(function(objName, i) {
                                tooltipText += objName + ': ' + Highcharts.numberFormat(individualData[i], 4) + '<br/>';
                            });
                            return tooltipText;
                        }
                    },
                    legend: { enabled: false },
                    credits: { enabled: false },
                    xAxis: {
                        categories: objectiveNames,
                        lineWidth: 0,
                        labels: {
                            style: { fontWeight: 'bold', fontSize: '11px' },
                            rotation: -45
                        }
                    },
                    yAxis: {
                        min: 0,
                        max: 1,
                        title: { text: 'Normalized Values' },
                        labels: {
                            format: '{value:.1f}'
                        },
                        gridLineWidth: 1
                    },
                    series: normalizedData.map((elite, index) => ({
                        name: `Elite ${index + 1}`,
                        data: elite,
                        color: colors[index % colorCount],
                        lineWidth: index === 0 ? 3 : 2.5,
                        opacity: index === 0 ? 0.9 : 0.75
                    }))
                };

                charts.parallelCoords = Highcharts.chart('parallelCoordsChart', chartConfig);

                // Re-register with chartUpdateManager after recreation
                if (window.chartUpdateManager) {
                    window.chartUpdateManager.registerChart('parallelCoords', charts.parallelCoords);
                    console.log('‚úÖ Parallel coordinates chart re-registered with update manager');
                }

                console.log('‚úÖ Parallel coordinates chart updated');
            }
        }

        // 3. Update Winning Trades Distribution Chart
        if (chartData.winning_trades_distribution && charts.winningTrades) {
            const categories = chartData.winning_trades_distribution.map(item => item[0]);
            const data = chartData.winning_trades_distribution.map(item => item[1]);

            charts.winningTrades.update({
                xAxis: { categories: categories }
            }, false);
            charts.winningTrades.series[0].setData(data, true);
        }

        // 4. Update Losing Trades Distribution Chart
        if (chartData.losing_trades_distribution && charts.losingTrades) {
            const categories = chartData.losing_trades_distribution.map(item => item[0]);
            const data = chartData.losing_trades_distribution.map(item => item[1]);

            charts.losingTrades.update({
                xAxis: { categories: categories }
            }, false);
            charts.losingTrades.series[0].setData(data, true);
        }

        // 5. Update Best Strategy Chart
        if (chartData.best_strategy && charts.bestStrategy) {
            // Update with candlestick data and trade triggers
            const candlestickData = chartData.best_strategy.candlestick_data || [];
            const triggers = chartData.best_strategy.triggers || [];
            const trades = chartData.best_strategy.trades || [];

            charts.bestStrategy.series[0].setData(candlestickData, false);

            // Remove old signal series if they exist (we're replacing triangles with background bands)
            while (charts.bestStrategy.series.length > 1) {
                charts.bestStrategy.series[charts.bestStrategy.series.length - 1].remove(false);
            }

            // Clear existing plot bands
            if (charts.bestStrategy.xAxis[0].plotLinesAndBands) {
                charts.bestStrategy.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                    if (band.options.className && band.options.className.includes('trade-band')) {
                        band.destroy();
                    }
                });
            }

            // Add background shading bands for complete trades
            if (trades && trades.length > 0) {
                trades.forEach((trade, index) => {
                    if (trade.entry_time && trade.exit_time) {
                        const isProfit = trade.pnl > 0;
                        const bandColor = isProfit ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)'; // Green or red with transparency

                        charts.bestStrategy.xAxis[0].addPlotBand({
                            from: new Date(trade.entry_time).getTime(),
                            to: new Date(trade.exit_time).getTime(),
                            color: bandColor,
                            className: `trade-band trade-${index}`,
                            id: `trade-band-${index}`,
                            zIndex: 0, // Behind the candlesticks
                            label: {
                                text: `${isProfit ? '+' : ''}${trade.pnl.toFixed(2)}%`,
                                align: 'center',
                                style: {
                                    color: isProfit ? '#28a745' : '#dc3545',
                                    fontWeight: 'bold',
                                    fontSize: '10px'
                                }
                            }
                        });
                    }
                });
            } else if (triggers && triggers.length > 0) {
                // Fallback: If no complete trades, try to pair buy/sell signals
                const buySignals = triggers.filter(t => t.type === 'buy').sort((a, b) => a.timestamp - b.timestamp);
                const sellSignals = triggers.filter(t => t.type === 'sell').sort((a, b) => a.timestamp - b.timestamp);

                // Pair buy and sell signals to create trade bands
                let buyIndex = 0, sellIndex = 0;
                let tradeCount = 0;

                while (buyIndex < buySignals.length && sellIndex < sellSignals.length) {
                    const buySignal = buySignals[buyIndex];
                    const sellSignal = sellSignals[sellIndex];

                    if (buySignal.timestamp < sellSignal.timestamp) {
                        // Found a valid trade pair
                        const estimatedPnl = ((sellSignal.price - buySignal.price) / buySignal.price) * 100;
                        const isProfit = estimatedPnl > 0;
                        const bandColor = isProfit ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)';

                        charts.bestStrategy.xAxis[0].addPlotBand({
                            from: buySignal.timestamp,
                            to: sellSignal.timestamp,
                            color: bandColor,
                            className: `trade-band trade-${tradeCount}`,
                            id: `trade-band-${tradeCount}`,
                            zIndex: 0,
                            label: {
                                text: `${isProfit ? '+' : ''}${estimatedPnl.toFixed(2)}%`,
                                align: 'center',
                                style: {
                                    color: isProfit ? '#28a745' : '#dc3545',
                                    fontWeight: 'bold',
                                    fontSize: '10px'
                                }
                            }
                        });

                        buyIndex++;
                        sellIndex++;
                        tradeCount++;
                    } else {
                        sellIndex++;
                    }
                }
            }

            charts.bestStrategy.redraw();
        }

        // 5. Update Performance Metrics Table
        if (chartData.performance_metrics) {
            updatePerformanceMetricsTable(chartData.performance_metrics, chartData.table_columns);
        }

        // 6. Auto-update Parameter Histogram and Evolution charts if a parameter is selected
        const parameterSelector = document.getElementById('parameterSelector');
        const selectedParameter = parameterSelector ? parameterSelector.value : null;

        if (selectedParameter) {
            console.log(`üîÑ Auto-updating parameter charts for selected parameter: ${selectedParameter}`);
            // Reload both histogram and evolution charts with the currently selected parameter
            loadParameterHistogram(selectedParameter);
            loadParameterEvolution(selectedParameter);
        }
    }

    function updatePerformanceMetricsTable(metricsData, tableColumns) {
        const tableBody = document.getElementById('metricsTable');
        const tableHead = tableBody.closest('table').querySelector('thead tr');

        if (!metricsData || metricsData.length === 0) {
            return; // Don't clear existing data, just don't add new data
        }

        // Build table header dynamically if we have column definitions
        if (tableColumns && tableColumns.length > 0) {
            let headerHtml = '';
            tableColumns.forEach(column => {
                headerHtml += `<th>${column.title}</th>`;
            });
            tableHead.innerHTML = headerHtml;
        }

        // Clear the "No performance data yet" message if it exists
        if (tableBody.innerHTML.includes('No performance data yet')) {
            tableBody.innerHTML = '';
        }

        // Only add new generations that haven't been added before
        metricsData.forEach(metric => {
            const generation = metric.generation;

            if (!addedGenerations.has(generation)) {
                addedGenerations.add(generation);

                let rowHtml = `<tr id="generation-${generation}">`;

                if (tableColumns && tableColumns.length > 0) {
                    // Build row dynamically based on column definitions
                    tableColumns.forEach(column => {
                        const value = metric[column.key];
                        const formattedValue = formatTableValue(value, column.type, column.key);
                        const cellClass = getTableCellClass(column.key, value);
                        rowHtml += `<td class="${cellClass}">${formattedValue}</td>`;
                    });
                } else {
                    // Fallback to hardcoded structure if no column definitions
                    const pnlClass = metric.total_pnl >= 0 ? 'text-success' : 'text-danger';
                    rowHtml += `
                        <td><strong>${generation}</strong></td>
                        <td>${metric.total_trades}</td>
                        <td class="text-success">${metric.winning_trades}</td>
                        <td class="text-danger">${metric.losing_trades}</td>
                        <td class="${pnlClass}">${metric.total_pnl.toFixed(2)}%</td>
                        <td class="text-success">${metric.avg_win.toFixed(2)}%</td>
                        <td class="text-danger">${metric.avg_loss.toFixed(2)}%</td>
                    `;
                }

                rowHtml += '</tr>';
                tableBody.insertAdjacentHTML('beforeend', rowHtml);

                // Scroll to bottom to show latest generation
                const tableContainer = tableBody.closest('.table-responsive');
                if (tableContainer) {
                    tableContainer.scrollTop = tableContainer.scrollHeight;
                }
            }
        });
    }

    function formatTableValue(value, type, key) {
        if (value == null || value === undefined) {
            return '-';
        }

        switch (type) {
            case 'percentage':
                return `${parseFloat(value).toFixed(2)}%`;
            case 'decimal':
                return parseFloat(value).toFixed(3);
            case 'number':
            default:
                // Special handling for generation (make bold)
                if (key === 'generation') {
                    return `<strong>${parseInt(value)}</strong>`;
                }
                return parseInt(value);
        }
    }

    function getTableCellClass(key, value) {
        // Apply Bootstrap classes based on column type and value
        switch (key) {
            case 'total_pnl':
                return value >= 0 ? 'text-success' : 'text-danger';
            case 'winning_trades':
                return 'text-success';
            case 'losing_trades':
                return 'text-danger';
            case 'avg_win':
                return 'text-success';
            case 'avg_loss':
                return 'text-danger';
            default:
                return '';
        }
    }

    // Initialize charts when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // No layout management needed for fixed layout
        console.log('Optimizer visualization page loaded with fixed layout');
    });


    // Show completion popup for saving optimized configs
    function showCompletionSavePopup() {
        if (confirm('üèÜ Optimization completed!\n\nWould you like to save the optimized configurations and results?')) {
            saveOptimizedConfigs();
        }
    }

    // Save Optimized Configs function
    async function saveOptimizedConfigs() {
        const saveBtn = document.getElementById('saveOptimizedConfigsBtn');
        const originalText = saveBtn.innerHTML;

        try {
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Saving...';

            // Get complete optimization package (like old system)
            const response = await fetch('/optimizer/api/export_optimized_configs');
            const result = await response.json();

            if (result.success) {
                const package = result.package;
                const folderName = package.folder_name;

                console.log('üèÜ Received optimization package:', package);

                // Download all files organized with folder prefix in filenames
                const confirmDownload = confirm(
                    `Save optimization results to Downloads folder?\n\n` +
                    `Folder: ${folderName}\n` +
                    `Elite configs: ${package.elites_count}\n` +
                    `Total files: ${Object.keys(package.files).length + 3}\n\n` +
                    `Files will be saved with folder prefix for easy organization.`
                );

                if (!confirmDownload) return;

                // Download all files with folder prefix for easy organization
                const allFiles = [];

                // Add elite configs
                for (const [filename, config] of Object.entries(package.files)) {
                    allFiles.push({
                        filename: `${folderName}/${filename}`,
                        content: JSON.stringify(config, null, 2),
                        type: 'application/json'
                    });
                }

                // Add objectives CSV
                if (package.objectives_csv) {
                    allFiles.push({
                        filename: `${folderName}/${package.objectives_filename}`,
                        content: package.objectives_csv,
                        type: 'text/csv'
                    });
                }

                // Add GA config
                allFiles.push({
                    filename: `${folderName}/${package.ga_config_filename}`,
                    content: JSON.stringify(package.ga_config, null, 2),
                    type: 'application/json'
                });

                // Add summary
                allFiles.push({
                    filename: `${folderName}/${package.summary_filename}`,
                    content: package.summary,
                    type: 'text/plain'
                });

                // Download all files with folder structure in filename
                for (const file of allFiles) {
                    const blob = new Blob([file.content], { type: file.type });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = file.filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    await new Promise(resolve => setTimeout(resolve, 150)); // Small delay between downloads
                }

                showAlert(
                    `üèÜ Optimization results downloaded!\n\n` +
                    `${allFiles.length} files saved to Downloads folder.\n` +
                    `Files are prefixed with "${folderName}/" for easy organization.\n\n` +
                    `Elite configs: ${package.elites_count} (top performers)`,
                    'success'
                );
            } else {
                showAlert(`Failed to get elite configurations: ${result.error || 'Unknown error'}`, 'danger');
            }

        } catch (error) {
            showAlert(`Failed to save best elite: ${error.message}`, 'danger');
        } finally {
            saveBtn.disabled = false;
            saveBtn.innerHTML = originalText;
        }
    }

    // Add click listener for load elite button
    loadEliteToFormsBtn.addEventListener('click', async function() {
        try {
            const response = await fetch('/optimizer/api/export_optimized_configs');
            const result = await response.json();

            if (!result.success) {
                showAlert(`Error loading elite: ${result.error}`, 'danger');
                return;
            }

            const elitePackage = result.package;

            if (!elitePackage || !elitePackage.files) {
                showAlert('No elite configurations available', 'warning');
                return;
            }

            // Get the first elite (best elite)
            const eliteFiles = elitePackage.files;
            const firstEliteKey = Object.keys(eliteFiles)[0];

            if (!firstEliteKey) {
                showAlert('No elite configuration found', 'warning');
                return;
            }

            const bestElite = eliteFiles[firstEliteKey];

            // Store in the same variables used by config loading
            monitorConfig = bestElite;

            // Render the elite configuration to the forms
            renderMonitorConfiguration();

            // Switch to Monitor tab to show loaded config
            const monitorTab = document.querySelector('[data-bs-target="#monitor"]');
            if (monitorTab) {
                const tab = new bootstrap.Tab(monitorTab);
                tab.show();
            }

            showAlert('Elite configuration loaded to forms successfully!', 'success');

        } catch (error) {
            console.error('Error loading elite to forms:', error);
            showAlert(`Error loading elite: ${error.message}`, 'danger');
        }
    });

    // Add click listener for save button
    saveOptimizedConfigsBtn.addEventListener('click', saveOptimizedConfigs);

    // Reset buttons state
    function resetButtons() {
        startOptimizerBtn.disabled = false;
        pauseOptimizerBtn.disabled = true;
        stopOptimizerBtn.disabled = true;
        optimizationRunning = false;
        // Keep save button visible if it was shown (user might still want to save)
    }

    // Hide save button when starting new optimization
    function hideEliteButtons() {
        saveOptimizedConfigsBtn.style.display = 'none';
        saveOptimizedConfigsBtn.disabled = true;
        loadEliteToFormsBtn.style.display = 'none';
        loadEliteToFormsBtn.disabled = true;
        document.getElementById('sendToReplayBtn').style.display = 'none';
        document.getElementById('sendToReplayBtn').disabled = true;
    }

    // Keep old function for backward compatibility
    function hideElitesButton() {
        hideEliteButtons();
    }

    // Clear all charts and data from previous optimization runs
    function clearAllChartsAndData() {
        console.log('üßπ Clearing all charts and data from previous run');

        // Clear the generations tracking set
        addedGenerations.clear();

        // Clear the performance metrics table
        const tableBody = document.getElementById('metricsTable');
        if (tableBody) {
            tableBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No performance data yet</td></tr>';
        }

        // Clear the test evaluations table
        const testEvaluationsTableBody = document.getElementById('testEvaluationsTable');
        if (testEvaluationsTableBody) {
            testEvaluationsTableBody.innerHTML = '<tr><td colspan="9" class="text-center text-muted">No test evaluation data yet</td></tr>';
        }

        // Clear all chart data if charts exist
        if (charts.objective) {
            // Clear objective evolution chart
            while(charts.objective.series.length > 0) {
                charts.objective.series[0].remove(false);
            }
            charts.objective.redraw();
        }

        if (charts.parallelCoords) {
            // Clear parallel coordinates chart
            charts.parallelCoords.destroy();
            charts.parallelCoords = Highcharts.chart('parallelCoordsChart', {
                chart: {
                    type: 'line',
                    parallelCoordinates: true,
                    parallelAxes: {
                        lineWidth: 2,
                        gridlinesWidth: 1
                    }
                },
                title: { text: 'Elite Population Analysis' },
                plotOptions: {
                    series: {
                        animation: { duration: 500 },
                        lineWidth: 2.5,
                        opacity: 0.75,
                        marker: { enabled: false }
                    }
                },
                legend: { enabled: false },
                credits: { enabled: false }
            });

            // Re-register with chartUpdateManager after recreation
            if (window.chartUpdateManager) {
                window.chartUpdateManager.registerChart('parallelCoords', charts.parallelCoords);
            }
        }

        if (charts.winningTrades) {
            // Clear winning trades chart
            charts.winningTrades.series[0].setData([], true);
            charts.winningTrades.update({
                xAxis: { categories: [] }
            }, false);
        }

        if (charts.losingTrades) {
            // Clear losing trades chart
            charts.losingTrades.series[0].setData([], true);
            charts.losingTrades.update({
                xAxis: { categories: [] }
            }, false);
        }

        if (charts.bestStrategy) {
            // Clear best strategy chart
            charts.bestStrategy.series[0].setData([], false);

            // Clear any existing plot bands
            if (charts.bestStrategy.xAxis[0].plotLinesAndBands) {
                charts.bestStrategy.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                    if (band.options.className && band.options.className.includes('trade-band')) {
                        band.destroy();
                    }
                });
            }

            charts.bestStrategy.redraw();
        }

        // Reset progress bar
        const progressBar = document.getElementById('optimizationProgress');
        const progressText = document.getElementById('progressText');
        const statusText = document.getElementById('optimizationStatus');

        if (progressBar) {
            progressBar.style.width = '0%';
            progressBar.setAttribute('aria-valuenow', 0);
        }
        if (progressText) {
            progressText.textContent = 'Starting...';
        }
        if (statusText) {
            statusText.textContent = 'Generation: 0 / 0';
        }

        console.log('‚úÖ All charts and data cleared');
    }

    // Parameter Histogram Functions
    function updateParameterSelector(parameterList) {
        const selector = document.getElementById('parameterSelector');
        const currentSelection = selector.value;

        // Group parameters by source for organized dropdown
        const groupedParams = {};
        parameterList.forEach(param => {
            const source = param.source.split('.')[0];
            if (!groupedParams[source]) {
                groupedParams[source] = [];
            }
            groupedParams[source].push(param);
        });

        // Rebuild selector options with groups
        selector.innerHTML = '<option value="">Select a parameter...</option>';

        Object.keys(groupedParams).sort().forEach(source => {
            const group = document.createElement('optgroup');
            group.label = source.charAt(0).toUpperCase() + source.slice(1) + 's';

            groupedParams[source].forEach(param => {
                const option = document.createElement('option');
                option.value = param.name;
                option.textContent = `${param.name} (${param.value_count} values)`;
                group.appendChild(option);
            });

            selector.appendChild(group);
        });

        // Restore previous selection if it still exists
        if (currentSelection && parameterList.some(p => p.name === currentSelection)) {
            selector.value = currentSelection;
        }
    }

    async function loadParameterHistogram(paramName) {
        if (!paramName) return;

        console.log(`üìä Loading histogram for parameter: ${paramName}`);

        // Check if chart is initialized
        if (!charts.parameterHistogram) {
            console.error('‚ùå Parameter histogram chart not initialized');
            showAlert('Charts not initialized. Please start an optimization first.', 'warning');
            return;
        }

        try {
            const response = await fetch('/optimizer/api/get_parameter_histogram', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    parameter_name: paramName,
                    num_bins: 20
                })
            });

            const result = await response.json();
            console.log('üìä Histogram API response:', result);

            if (result.success && result.histogram) {
                console.log('‚úÖ Updating histogram chart with data:', result.histogram);
                updateParameterHistogramChart(result.histogram);
            } else {
                console.error('‚ùå Error loading parameter histogram:', result.error);
                showAlert(`Failed to load parameter histogram: ${result.error}`, 'warning');
            }
        } catch (error) {
            console.error('‚ùå Exception loading parameter histogram:', error);
            showAlert(`Failed to load parameter histogram: ${error.message}`, 'danger');
        }
    }

    function updateParameterHistogramChart(histogramData) {
        const populationData = histogramData.population;
        const eliteData = histogramData.elites;
        const paramType = histogramData.type;
        const paramRange = histogramData.range;

        // Get all unique categories from both population and elites
        const populationCategories = Object.keys(populationData.bins);
        const eliteCategories = eliteData ? Object.keys(eliteData.bins) : [];
        let allCategories = [...new Set([...populationCategories, ...eliteCategories])];

        // If parameter has a range and type is int, fill in missing values for full range display
        if (paramRange && paramRange.length === 2 && paramType === 'int') {
            const [minRange, maxRange] = paramRange;
            const fullRange = [];
            for (let i = minRange; i <= maxRange; i++) {
                fullRange.push(String(i));
            }
            // Merge with existing categories to ensure we don't lose any actual data
            allCategories = [...new Set([...fullRange, ...allCategories])];
        }

        // Sort categories numerically (handles both int and float strings)
        allCategories.sort((a, b) => {
            // Handle range formats like "0.5000-0.6000"
            const aVal = parseFloat(a.split('-')[0]);
            const bVal = parseFloat(b.split('-')[0]);
            return aVal - bVal;
        });

        // Create data arrays aligned with categories
        const populationValues = allCategories.map(cat => populationData.bins[cat] || 0);
        const eliteValues = allCategories.map(cat => eliteData ? (eliteData.bins[cat] || 0) : 0);

        const popStats = populationData.statistics;
        const eliteStats = eliteData ? eliteData.statistics : null;

        // Build subtitle with statistics
        let subtitleText = `Type: ${histogramData.type} | Range: [${histogramData.range.join(', ')}]<br/>` +
                          `Population (${populationData.total_values}): ` +
                          `Min: ${popStats.min.toFixed(2)}, Max: ${popStats.max.toFixed(2)}, ` +
                          `Mean: ${popStats.mean.toFixed(2)}, Median: ${popStats.median.toFixed(2)}`;

        if (eliteStats) {
            subtitleText += `<br/>Elites (${eliteData.total_values}): ` +
                           `Min: ${eliteStats.min.toFixed(2)}, Max: ${eliteStats.max.toFixed(2)}, ` +
                           `Mean: ${eliteStats.mean.toFixed(2)}, Median: ${eliteStats.median.toFixed(2)}`;
        }

        // Update chart with new data
        charts.parameterHistogram.update({
            title: {
                text: histogramData.parameter_name,
                style: { fontSize: '16px', fontWeight: 'bold', color: '#333' }
            },
            subtitle: {
                text: subtitleText,
                style: { fontSize: '11px', color: '#666' }
            },
            xAxis: { categories: allCategories }
        }, false);

        // Update both series
        charts.parameterHistogram.series[0].setData(populationValues, false);
        charts.parameterHistogram.series[1].setData(eliteValues, true);
    }

    // Parameter Evolution Functions
    async function loadParameterEvolution(paramName) {
        if (!paramName) return;

        console.log(`üìà Loading evolution data for parameter: ${paramName}`);

        // Check if chart is initialized
        if (!charts.parameterEvolution) {
            console.error('‚ùå Parameter evolution chart not initialized');
            showAlert('Charts not initialized. Please start an optimization first.', 'warning');
            return;
        }

        try {
            const response = await fetch('/optimizer/api/get_parameter_evolution', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    parameter_name: paramName
                })
            });

            const result = await response.json();

            if (result.success && result.evolution) {
                console.log('‚úÖ Updating evolution chart with data:', result.evolution);
                updateParameterEvolutionChart(result.evolution);
            } else {
                console.error('‚ùå Error loading parameter evolution:', result.error);
                showAlert(`Failed to load parameter evolution: ${result.error}`, 'warning');
            }
        } catch (error) {
            console.error('‚ùå Exception loading parameter evolution:', error);
            showAlert(`Failed to load parameter evolution: ${error.message}`, 'danger');
        }
    }

    function updateParameterEvolutionChart(evolutionData) {
        const generations = evolutionData.generations;
        const mean = evolutionData.mean;
        const std = evolutionData.std;
        const min = evolutionData.min;
        const max = evolutionData.max;
        const eliteMean = evolutionData.elite_mean;
        const convergence = evolutionData.convergence_detected;
        const jumps = evolutionData.jumps;

        // Prepare data series in [x, y] format
        const meanData = generations.map((gen, i) => [gen, mean[i]]);
        const eliteMeanData = generations.map((gen, i) => eliteMean[i] !== null ? [gen, eliteMean[i]] : null).filter(p => p !== null);
        const stdData = generations.map((gen, i) => [gen, std[i]]);
        const minData = generations.map((gen, i) => [gen, min[i]]);
        const maxData = generations.map((gen, i) => [gen, max[i]]);

        // Build subtitle with convergence and jump information
        let subtitleText = `Generations: ${generations.length}`;
        if (convergence) {
            subtitleText += ' | Status: ‚úÖ Converged';
        } else {
            subtitleText += ' | Status: üîÑ Evolving';
        }
        if (jumps.length > 0) {
            subtitleText += ` | Jumps detected: ${jumps.length}`;
        }

        // Update convergence indicator badge
        const indicator = document.getElementById('convergenceIndicator');
        if (convergence) {
            indicator.textContent = '‚úÖ Converged';
            indicator.className = 'badge bg-success';
            indicator.style.display = 'inline-block';
        } else {
            indicator.textContent = 'üîÑ Evolving';
            indicator.className = 'badge bg-info';
            indicator.style.display = 'inline-block';
        }

        // Update chart
        charts.parameterEvolution.update({
            title: {
                text: evolutionData.parameter_name,
                style: { fontSize: '16px', fontWeight: 'bold', color: '#333' }
            },
            subtitle: {
                text: subtitleText,
                style: { fontSize: '11px', color: '#666' }
            }
        }, false);

        // Update all series
        charts.parameterEvolution.series[0].setData(meanData, false);  // Mean
        charts.parameterEvolution.series[1].setData(eliteMeanData, false);  // Elite Mean
        charts.parameterEvolution.series[2].setData(stdData, false);  // Std Dev
        charts.parameterEvolution.series[3].setData(minData, false);  // Min
        charts.parameterEvolution.series[4].setData(maxData, true);  // Max and redraw

        // Add jump markers to the mean series
        if (jumps.length > 0) {
            console.log(`‚ö° ${jumps.length} parameter jumps detected:`, jumps);
        }
    }

    // Add change listener for parameter selector (updates BOTH charts)
    document.getElementById('parameterSelector').addEventListener('change', function() {
        const paramName = this.value;
        if (paramName) {
            // Load both histogram and evolution data
            loadParameterHistogram(paramName);
            loadParameterEvolution(paramName);
        } else {
            // Reset both charts to default state
            charts.parameterHistogram.update({
                title: {
                    text: 'Select a parameter from the dropdown above',
                    style: { fontSize: '14px', color: '#999' }
                },
                subtitle: { text: '' }
            }, false);
            charts.parameterHistogram.series[0].setData([], false);
            charts.parameterHistogram.series[1].setData([], true);

            charts.parameterEvolution.update({
                title: {
                    text: 'Select a parameter from the dropdown above',
                    style: { fontSize: '14px', color: '#999' }
                },
                subtitle: { text: '' }
            }, false);
            charts.parameterEvolution.series[0].setData([], false);
            charts.parameterEvolution.series[1].setData([], false);
            charts.parameterEvolution.series[2].setData([], false);
            charts.parameterEvolution.series[3].setData([], false);
            charts.parameterEvolution.series[4].setData([], true);

            // Hide convergence indicator
            document.getElementById('convergenceIndicator').style.display = 'none';
        }
    });

    // Test Evaluations Update Function
    function updateTestEvaluations(testEvaluations) {
        const tableBody = document.getElementById('testEvaluationsTable');

        // Clear "No test evaluation data yet" message if it exists
        if (tableBody.innerHTML.includes('No test evaluation data yet')) {
            tableBody.innerHTML = '';
        }

        // Add rows for each elite's test evaluation
        testEvaluations.forEach(evaluation => {
            const generation = evaluation.generation;
            const eliteIndex = evaluation.elite_index;
            const rowId = `test-eval-gen${generation}-elite${eliteIndex}`;

            // Check if row already exists (to avoid duplicates)
            if (document.getElementById(rowId)) {
                return;
            }

            const trainPnL = evaluation.train_pnl;
            const testPnL = evaluation.test_pnl;
            const overfittingScore = evaluation.overfitting_score || 0;

            // Calculate overfitting indicator (positive = overfitting, negative = generalizing well)
            let overfittingClass = '';
            let overfittingText = 'N/A';
            if (trainPnL !== null && testPnL !== null) {
                const diff = trainPnL - testPnL;
                overfittingText = diff.toFixed(2) + '%';
                if (diff > 5) {
                    overfittingClass = 'text-danger fw-bold';
                } else if (diff > 2) {
                    overfittingClass = 'text-warning';
                } else if (diff < -2) {
                    overfittingClass = 'text-success';
                } else {
                    overfittingClass = 'text-muted';
                }
            }

            const trainPnLClass = trainPnL >= 0 ? 'text-success' : 'text-danger';
            const testPnLClass = testPnL >= 0 ? 'text-success' : 'text-danger';

            const rowHtml = `
                <tr id="${rowId}">
                    <td><strong>${generation}</strong></td>
                    <td>Elite ${eliteIndex + 1}</td>
                    <td class="${trainPnLClass}">${trainPnL !== null ? trainPnL.toFixed(2) + '%' : 'N/A'}</td>
                    <td class="${testPnLClass}">${testPnL !== null ? testPnL.toFixed(2) + '%' : 'N/A'}</td>
                    <td>${evaluation.train_trades || 'N/A'}</td>
                    <td>${evaluation.test_trades || 'N/A'}</td>
                    <td class="text-success">${evaluation.train_win_rate !== null ? evaluation.train_win_rate.toFixed(2) + '%' : 'N/A'}</td>
                    <td class="text-success">${evaluation.test_win_rate !== null ? evaluation.test_win_rate.toFixed(2) + '%' : 'N/A'}</td>
                    <td class="${overfittingClass}">${overfittingText}</td>
                </tr>
            `;

            tableBody.insertAdjacentHTML('beforeend', rowHtml);

            // Scroll to bottom to show latest evaluations
            const tableContainer = tableBody.closest('.table-responsive');
            if (tableContainer) {
                tableContainer.scrollTop = tableContainer.scrollHeight;
            }
        });
    }

    // ========================================
    // GLOBAL FUNCTION EXPORTS
    // Make these functions accessible from external modules (optimizer-ui-integration.js)
    // ========================================
    window.updateProgressBar = updateProgressBar;
    window.updateCharts = updateCharts;
    window.updateParameterSelector = updateParameterSelector;
    window.updateTestEvaluations = updateTestEvaluations;
    window.showAlert = showAlert;  // Also expose the alert function
    window.initializeCharts = initializeCharts;  // Expose chart initialization
    window.showCharts = showCharts;  // Expose showCharts for initialization

    // FIX: Expose Performance Metrics Table functions (critical for chart manager integration)
    window.updatePerformanceMetricsTable = updatePerformanceMetricsTable;
    window.formatTableValue = formatTableValue;
    window.getTableCellClass = getTableCellClass;

    // FIX: Expose Parameter Chart functions (critical for auto-update)
    window.loadParameterHistogram = loadParameterHistogram;
    window.loadParameterEvolution = loadParameterEvolution;

    // Make charts object accessible globally for debugging and updates
    window.optimizerCharts = charts;

    // Expose the addedGenerations set so external modules can clear it
    window.addedGenerations = addedGenerations;

    console.log('‚úÖ Global functions exported:', {
        updateProgressBar: typeof window.updateProgressBar,
        updateCharts: typeof window.updateCharts,
        updateParameterSelector: typeof window.updateParameterSelector,
        updateTestEvaluations: typeof window.updateTestEvaluations,
        showAlert: typeof window.showAlert,
        initializeCharts: typeof window.initializeCharts,
        showCharts: typeof window.showCharts,
        chartsObject: typeof window.optimizerCharts
    });

    // Send to Replay functionality
    let selectedEliteIndex = null;

    document.getElementById('sendToReplayBtn').addEventListener('click', function() {
        // Show the elite selection modal
        showEliteSelectionModal();
    });

    async function showEliteSelectionModal() {
        const modal = new bootstrap.Modal(document.getElementById('eliteSelectionModal'));
        const tableBody = document.getElementById('eliteSelectionTable');
        const confirmBtn = document.getElementById('confirmSendToReplayBtn');

        // Reset state
        selectedEliteIndex = null;
        confirmBtn.disabled = true;

        // Show loading state
        tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-muted"><i class="fas fa-spinner fa-spin me-2"></i>Loading elites...</td></tr>';

        // Fetch elites from backend
        try {
            const response = await fetch('/optimizer/api/get_elites');
            const data = await response.json();

            if (data.success && data.elites && data.elites.length > 0) {
                // Populate table with elites
                tableBody.innerHTML = data.elites.map((elite, index) => `
                    <tr class="elite-row" data-elite-index="${index}" style="cursor: pointer;">
                        <td><input type="radio" name="eliteSelection" value="${index}"></td>
                        <td>Elite ${index + 1}</td>
                        <td>${elite.total_pnl ? elite.total_pnl.toFixed(2) + '%' : 'N/A'}</td>
                        <td>${elite.win_rate ? elite.win_rate.toFixed(2) + '%' : 'N/A'}</td>
                        <td>${elite.total_trades || 'N/A'}</td>
                    </tr>
                `).join('');

                // Add click handlers
                document.querySelectorAll('.elite-row').forEach(row => {
                    row.addEventListener('click', function() {
                        const radio = this.querySelector('input[type="radio"]');
                        radio.checked = true;
                        selectedEliteIndex = parseInt(this.dataset.eliteIndex);
                        confirmBtn.disabled = false;
                    });
                });
            } else {
                tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-warning">No elites available</td></tr>';
            }
        } catch (error) {
            console.error('Error loading elites:', error);
            tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-danger">Error loading elites</td></tr>';
        }

        modal.show();
    }

    document.getElementById('confirmSendToReplayBtn').addEventListener('click', async function() {
        if (selectedEliteIndex === null) return;

        try {
            // Fetch the elite configuration
            const response = await fetch(`/optimizer/api/get_elite_config/${selectedEliteIndex}`);
            const data = await response.json();

            if (data.success) {
                // Use default data config
                const defaultDataConfig = {
                    ticker: "NVDA",
                    start_date: "2024-01-01",
                    end_date: "2024-02-28"
                };

                // Store config in sessionStorage for Replay tab
                sessionStorage.setItem('replayMonitorConfig', JSON.stringify(data.monitor_config));
                sessionStorage.setItem('replayDataConfig', JSON.stringify(defaultDataConfig));

                // Close modal
                bootstrap.Modal.getInstance(document.getElementById('eliteSelectionModal')).hide();

                // Open new Replay tab with unique name based on timestamp
                // This ensures each click creates a new tab instead of reusing existing one
                const replayUrl = '/replay';
                const uniqueTabName = `replay_tab_${Date.now()}`;
                const replayWindow = window.open(replayUrl, uniqueTabName);

                if (replayWindow) {
                    replayWindow.focus();
                } else {
                    showAlert('Please allow popups to open the Replay tab', 'warning');
                }
            } else {
                showAlert('Error loading elite configuration', 'danger');
            }
        } catch (error) {
            console.error('Error sending to replay:', error);
            showAlert('Error sending elite to replay', 'danger');
        }
    });
});
</script>
{% endblock %}
