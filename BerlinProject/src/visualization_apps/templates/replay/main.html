{% extends "base.html" %}

{% block title %}Replay{% endblock %}

{% block extra_head %}
<style>
    .indicator-card, .bar-card {
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        padding: 0;
        margin-bottom: 1rem;
        background: #f8f9fa;
        transition: all 0.3s;
    }

    .indicator-card:hover, .bar-card:hover {
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .indicator-card-header, .bar-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem;
        cursor: pointer;
        border-radius: 0.5rem 0.5rem 0 0;
        transition: background 0.3s;
    }

    .indicator-card-header:hover, .bar-card-header:hover {
        background: #e9ecef;
    }

    .indicator-card-title {
        font-weight: 600;
        color: #2c3e50;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .indicator-card-body, .bar-card-body {
        padding: 1rem;
        display: none;
        border-top: 1px solid #dee2e6;
    }

    .indicator-card-body.show, .bar-card-body.show {
        display: block;
    }

    .collapse-icon {
        transition: transform 0.3s;
        color: #6c757d;
    }

    .collapse-icon.expanded {
        transform: rotate(90deg);
    }

    .btn-remove {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 0.25rem 0.75rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.3s;
    }

    .btn-remove:hover {
        background: #c0392b;
    }

    /* Compact parameter inputs */
    .indicator-card-body .form-control,
    .indicator-card-body .form-select,
    .bar-card-body .form-control,
    .bar-card-body .form-select {
        max-width: 200px;
        font-size: 0.875rem;
    }

    .indicator-card-body .form-label,
    .bar-card-body .form-label {
        font-size: 0.875rem;
        margin-bottom: 0.25rem;
    }

    .indicator-card-body .row.g-2,
    .bar-card-body .row.g-2 {
        row-gap: 0.5rem !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h2 class="mb-4">
                <i class="fas fa-play-circle me-2"></i>Replay
            </h2>
        </div>
    </div>
    
    <!-- File Selector -->
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-body">
                    <div class="row align-items-center mb-3">
                        <div class="col-md-5">
                            <label for="monitorFileInput" class="form-label mb-0">
                                <i class="fas fa-file me-2"></i>Monitor Configuration File
                            </label>
                        </div>
                        <div class="col-md-7">
                            <input type="file" class="form-control" id="monitorFileInput" accept=".json">
                        </div>
                    </div>
                    <div class="row align-items-center mb-3">
                        <div class="col-md-5">
                            <label for="dataFileInput" class="form-label mb-0">
                                <i class="fas fa-database me-2"></i>Data Configuration File <span class="text-muted">(Optional)</span>
                            </label>
                        </div>
                        <div class="col-md-7">
                            <input type="file" class="form-control" id="dataFileInput" accept=".json">
                            <small class="text-muted">If not provided, defaults to: NVDA, last 2 weeks through tomorrow</small>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-12 text-center">
                            <button class="btn btn-primary btn-lg" id="loadConfigsBtn" disabled>
                                <i class="fas fa-upload me-2"></i>Load Configurations
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Configuration Editor -->
    <div class="row" id="configEditor" style="display: none;">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="fas fa-edit me-2"></i>Edit Configuration
                    </h5>
                    <button class="btn btn-success" onclick="saveMonitorConfiguration()">
                        <i class="fas fa-save me-2"></i>Save Monitor Config
                    </button>
                </div>
                <div class="card-body">
                    <!-- Tabs -->
                    <ul class="nav nav-tabs mb-3" id="configTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="monitor-tab" data-bs-toggle="tab"
                                    data-bs-target="#monitor-pane" type="button" role="tab">
                                <i class="fas fa-info-circle me-2"></i>Monitor
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="indicators-tab" data-bs-toggle="tab"
                                    data-bs-target="#indicators-pane" type="button" role="tab">
                                <i class="fas fa-chart-line me-2"></i>Indicators
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="bars-tab" data-bs-toggle="tab"
                                    data-bs-target="#bars-pane" type="button" role="tab">
                                <i class="fas fa-bars me-2"></i>Bars
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="trade-executor-tab" data-bs-toggle="tab"
                                    data-bs-target="#trade-executor-pane" type="button" role="tab">
                                <i class="fas fa-exchange-alt me-2"></i>Trade Executor
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="data-config-tab" data-bs-toggle="tab"
                                    data-bs-target="#data-config-pane" type="button" role="tab">
                                <i class="fas fa-database me-2"></i>Data Config
                            </button>
                        </li>
                    </ul>

                    <!-- Tab Content -->
                    <div class="tab-content" id="configTabContent">
                        <!-- Monitor Tab -->
                        <div class="tab-pane fade show active" id="monitor-pane" role="tabpanel">
                            <div class="mb-3">
                                <h6>Basic Information</h6>
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <label for="monitorName" class="form-label">Name</label>
                                        <input type="text" class="form-control" id="monitorName" style="max-width: 300px;">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="monitorDescription" class="form-label">Description</label>
                                        <input type="text" class="form-control" id="monitorDescription" style="max-width: 300px;">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Indicators Tab -->
                        <div class="tab-pane fade" id="indicators-pane" role="tabpanel">
                            <div class="mb-3">
                                <button class="btn btn-success" id="addIndicatorBtn">
                                    <i class="fas fa-plus me-2"></i>Add Indicator
                                </button>
                            </div>
                            <div id="indicatorsContainer"></div>
                        </div>

                        <!-- Bars Tab -->
                        <div class="tab-pane fade" id="bars-pane" role="tabpanel">
                            <div class="mb-3">
                                <button class="btn btn-success" id="addBarBtn">
                                    <i class="fas fa-plus me-2"></i>Add Bar
                                </button>
                            </div>
                            <div id="barsContainer"></div>
                        </div>

                        <!-- Trade Executor Tab -->
                        <div class="tab-pane fade" id="trade-executor-pane" role="tabpanel">
                            {% include 'components/_trade_executor_form.html' %}
                        </div>

                        <!-- Data Config Tab -->
                        <div class="tab-pane fade" id="data-config-pane" role="tabpanel">
                            <div class="mb-3">
                                <h6>Data Configuration</h6>
                                {% include 'components/_data_config_form.html' %}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Run Button -->
    <div class="row mb-4">
        <div class="col-12 text-center">
            <button type="button" class="btn btn-success btn-lg" id="runReplayBtn" disabled>
                <i class="fas fa-play me-2"></i>Run Replay
            </button>
        </div>
    </div>

    <!-- Results Section -->
    <div class="row" id="resultsSection" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="fas fa-chart-area me-2"></i>Visualization Results
                    </h5>
                    <div class="btn-group" role="group">
                        <button type="button" class="btn btn-outline-info btn-sm" id="debugChartsBtn" onclick="captureDebugData()">
                            <i class="fas fa-bug me-1"></i>Debug
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="saveImageBtn" onclick="saveChartsAsImage()">
                            <i class="fas fa-camera me-1"></i>Save Image
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <!-- Strategy Overview -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <h6>Strategy Overview</h6>
                            <div class="row">
                                <div class="col-md-2">
                                    <strong>Strategy:</strong> <span id="strategyName">-</span>
                                </div>
                                <div class="col-md-2">
                                    <strong>Symbol:</strong> <span id="displayTicker">-</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Date Range:</strong> <span id="dateRange">-</span>
                                </div>
                                <div class="col-md-2">
                                    <strong>Total Trades:</strong> <span id="totalTrades">-</span>
                                </div>
                                <div class="col-md-1">
                                    <strong>Wins:</strong> <span id="winningTrades" class="text-success">-</span>
                                </div>
                                <div class="col-md-2">
                                    <strong>Losses:</strong> <span id="losingTrades" class="text-danger">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Performance Metrics -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <h6>Performance Metrics</h6>
                            <div class="row">
                                <!-- Percentage-based metrics -->
                                <div class="col-md-2">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="totalPnL">-</div>
                                        <small class="text-muted">Total P&L %</small>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="avgWin">-</div>
                                        <small class="text-muted">Avg Win %</small>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="avgLoss">-</div>
                                        <small class="text-muted">Avg Loss %</small>
                                    </div>
                                </div>
                                <!-- Dollar-based metrics -->
                                <div class="col-md-2">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="totalPnLDollars">-</div>
                                        <small class="text-muted">Total P&L $</small>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="avgWinDollars">-</div>
                                        <small class="text-muted">Avg Win $</small>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="avgLossDollars">-</div>
                                        <small class="text-muted">Avg Loss $</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Charts and Trade History Side by Side -->
                    <div class="row">
                        <!-- Charts Section (Left Half) -->
                        <div class="col-lg-6">
                            <!-- Stacked Charts Container with shared x-axis -->
                            <div id="stackedChartsContainer">
                                <!-- Chart Container -->
                                <div id="candlestickChart" style="height: 500px; margin-bottom: 5px;"></div>

                                <!-- P&L Chart - COMMENTED OUT
                                <div id="pnlChart" style="height: 300px; margin-bottom: 5px;"></div>
                                -->

                                <!-- Bar Scores Analysis Chart -->
                                <div id="barScoresContainer" style="margin-top: 20px;">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <h6 class="mb-0">Bar Scores Analysis</h6>
                                        <small class="text-muted">Weighted indicator trigger combinations with entry/exit thresholds</small>
                                    </div>
                                    <div id="barScoresChart" style="height: 280px; margin-bottom: 5px;"></div>
                                </div>

                                <!-- Tabbed Indicator Charts Container -->
                                <div id="indicatorChartsContainer" style="margin-top: 20px;">
                                    <h6>Indicator Analysis</h6>
                                    <!-- Indicator tabs will be dynamically created here -->
                                    <ul class="nav nav-tabs" id="indicatorTabs" role="tablist"></ul>
                                    <div class="tab-content" id="indicatorTabContent" style="border: 1px solid #dee2e6; border-top: none; padding: 15px;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Trade History Section (Right Half) -->
                        <div class="col-lg-6">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h6 class="mb-0">Trade History</h6>
                                <div class="d-flex align-items-center">
                                    <!-- Timezone Selector -->
                                    <div class="timezone-selector" style="margin-right: 1rem; border-left: none; padding-left: 0;">
                                        <span class="timezone-label">TZ</span>
                                        <select id="timezoneSelect" class="timezone-select" onchange="handleTimezoneChange(this.value)">
                                            <option value="America/New_York">ET</option>
                                            <option value="America/Los_Angeles">PT</option>
                                            <option value="UTC">UTC</option>
                                        </select>
                                    </div>
                                    <label for="pnlDisplayMode" class="form-label mb-0 me-2 small">Display:</label>
                                    <select class="form-select form-select-sm" id="pnlDisplayMode" style="width: auto;" onchange="updatePnLDisplay()">
                                        <option value="percent">Percentage</option>
                                        <option value="dollars">Dollar Trades</option>
                                        <option value="both" selected>Both</option>
                                    </select>
                                </div>
                            </div>
                            <div class="table-responsive" style="max-height: 800px; overflow-y: auto;">
                                <table class="table table-striped table-sm">
                                    <thead class="sticky-top bg-white">
                                        <tr>
                                            <th>Time</th>
                                            <th>Type</th>
                                            <th>Price</th>
                                            <th>Size</th>
                                            <th class="pnl-col-pct">P&L %</th>
                                            <th class="pnl-col-dollars">P&L $</th>
                                            <th class="pnl-col-pct">Cum. %</th>
                                            <th class="pnl-col-dollars">Cum. $</th>
                                            <th>Signal</th>
                                            <th>Details</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tradeHistoryTable">
                                        <tr>
                                            <td colspan="10" class="text-center text-muted">No trades to display</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Trade Details Modal -->
<div class="modal fade" id="tradeDetailsModal" tabindex="-1" aria-labelledby="tradeDetailsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="tradeDetailsModalLabel">Trade Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="tradeDetailsContent">
                <!-- Content will be populated dynamically -->
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Debug Data Modal -->
<div class="modal fade" id="debugDataModal" tabindex="-1" aria-labelledby="debugDataModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="debugDataModalLabel">
                    <i class="fas fa-bug me-2"></i>Debug Data - Current View
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <h6>Visible Range</h6>
                    <div class="row">
                        <div class="col-md-6">
                            <strong>From:</strong> <span id="debugRangeFrom">-</span>
                        </div>
                        <div class="col-md-6">
                            <strong>To:</strong> <span id="debugRangeTo">-</span>
                        </div>
                    </div>
                </div>
                <div class="mb-3">
                    <h6>Indicator Values in View</h6>
                    <div id="debugIndicatorValues" style="max-height: 300px; overflow-y: auto;">
                        <pre id="debugIndicatorPre" class="bg-light p-2 rounded" style="font-size: 12px;"></pre>
                    </div>
                </div>
                <div class="mb-3">
                    <h6>Bar Scores in View</h6>
                    <div id="debugBarScores" style="max-height: 200px; overflow-y: auto;">
                        <pre id="debugBarScoresPre" class="bg-light p-2 rounded" style="font-size: 12px;"></pre>
                    </div>
                </div>
                <div class="mb-3">
                    <h6>Raw Debug JSON</h6>
                    <textarea id="debugJsonOutput" class="form-control" rows="8" readonly style="font-family: monospace; font-size: 11px;"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-primary" onclick="copyDebugToClipboard()">
                    <i class="fas fa-copy me-1"></i>Copy to Clipboard
                </button>
                <button type="button" class="btn btn-outline-success" onclick="downloadDebugJson()">
                    <i class="fas fa-download me-1"></i>Download JSON
                </button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script src="{{ url_for('static', filename='js/talib-patterns.js') }}"></script>
<script src="{{ url_for('static', filename='js/config-utils.js') }}"></script>
<script src="{{ url_for('static', filename='js/trade-executor-common.js') }}"></script>
<script src="{{ url_for('static', filename='js/replay-config.js') }}"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const runReplayBtn = document.getElementById('runReplayBtn');
    const resultsSection = document.getElementById('resultsSection');
    const configEditor = document.getElementById('configEditor');

    let charts = {};

    // Global state for indicator chart updates
    let globalChartData = {
        perAggregatorCandles: {},
        indicatorAggMapping: {},
        indicatorConfigs: [],
        trades: [],
        tradeDetails: {},  // Detailed trade info for popup (timestamp -> details dict)
        currentIndicator: null
    };

    // Page-specific timezone change handler
    window.handleTimezoneChange = function(timezone) {
        // Call shared handler (updates Highcharts, localStorage, etc.)
        onTimezoneChange(timezone);

        // Redraw all charts
        Object.values(charts).forEach(chart => {
            if (chart && chart.redraw) {
                chart.redraw();
            }
        });

        // Re-render trade history with new timezone
        if (globalChartData.trades && globalChartData.trades.length > 0) {
            populateTradeHistory(globalChartData.trades);
        }
    };

    // Default data configuration - uses shared getDefaultDataConfig() from config-utils.js
    // DEFAULT_DATA_CONFIG is already defined globally in config-utils.js

    // Check if we received configs from optimizer via sessionStorage
    checkForOptimzerData();

    // Setup file input listeners to enable load button
    function checkFilesSelected() {
        const monitorFile = document.getElementById('monitorFileInput').files.length > 0;
        // Only monitor file is required - data file is optional
        document.getElementById('loadConfigsBtn').disabled = !monitorFile;
    }

    document.getElementById('monitorFileInput').addEventListener('change', checkFilesSelected);
    document.getElementById('dataFileInput').addEventListener('change', checkFilesSelected);

    // Load both configs at once
    document.getElementById('loadConfigsBtn').addEventListener('click', async function() {
        const monitorFileInput = document.getElementById('monitorFileInput');
        const dataFileInput = document.getElementById('dataFileInput');

        if (!monitorFileInput.files.length) return;

        try {
            // Load monitor config
            const monitorFile = monitorFileInput.files[0];
            const monitorText = await monitorFile.text();
            monitorConfig = JSON.parse(monitorText);

            // Load data config (optional - use defaults if not provided)
            if (dataFileInput.files.length > 0) {
                const dataFile = dataFileInput.files[0];
                const dataText = await dataFile.text();
                dataConfig = JSON.parse(dataText);
                showAlert('Configurations loaded successfully', 'success');
            } else {
                // Use default data config with dynamic dates (2 weeks ago to tomorrow)
                dataConfig = JSON.parse(JSON.stringify(DEFAULT_DATA_CONFIG));
                showAlert(`Monitor configuration loaded. Using default data: NVDA, ${DEFAULT_DATA_CONFIG.start_date} to ${DEFAULT_DATA_CONFIG.end_date}`, 'info');
            }

            // Render configurations
            renderMonitorConfiguration();
            renderDataConfiguration();

            // Show editor and enable run button
            configEditor.style.display = 'block';
            runReplayBtn.disabled = false;
        } catch (error) {
            alert('Error loading configurations: ' + error.message);
        }
    });

    // Run replay visualization
    runReplayBtn.addEventListener('click', async function() {
        if (!monitorConfig || !dataConfig) {
            alert('Please load both monitor and data configurations first');
            return;
        }

        // Collect updated config from the editor
        collectMonitorConfigData();
        collectDataConfigData();

        try {
            this.disabled = true;
            this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Running Replay...';

            const response = await fetch('/replay/api/run_visualization', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    monitor_config: monitorConfig,
                    data_config: dataConfig
                })
            });

            const result = await response.json();

            if (result.success) {
                displayResults(result.data);
                resultsSection.style.display = 'block';
            } else {
                throw new Error(result.error || 'Visualization failed');
            }

        } catch (error) {
            alert(`Failed to run replay: ${error.message}`);
        } finally {
            this.disabled = false;
            this.innerHTML = '<i class="fas fa-play me-2"></i>Run Replay';
        }
    });
    
    function displayResults(data) {
        // Store data globally for tab change updates
        globalChartData.perAggregatorCandles = data.per_aggregator_candles || {};
        globalChartData.indicatorAggMapping = data.indicator_agg_mapping || {};
        globalChartData.indicatorConfigs = data.indicators || [];
        globalChartData.trades = data.trades || [];
        globalChartData.tradeDetails = data.trade_details || {};  // Detailed trade info for popup
        globalChartData.primaryCandlestickData = data.candlestick_data;
        globalChartData.chartConfigs = data.chart_configs || {};  // Self-describing chart configs

        // Build name to agg_config mapping from indicator configs
        globalChartData.nameToAggConfig = {};
        globalChartData.indicatorConfigs.forEach(config => {
            globalChartData.nameToAggConfig[config.name] = config.agg_config || '1m-normal';
        });

        // Update strategy overview
        document.getElementById('strategyName').textContent = data.monitor_config?.name || 'Unknown';
        document.getElementById('displayTicker').textContent = data.data_config?.ticker || 'Unknown';
        document.getElementById('dateRange').textContent = `${data.data_config?.start_date || 'Unknown'} to ${data.data_config?.end_date || 'Unknown'}`;
        document.getElementById('totalTrades').textContent = data.trades?.length || 0;

        // Calculate and display metrics
        if (data.trades && data.trades.length > 0) {
            calculateMetrics(data.trades);
        }

        // Create charts
        if (data.candlestick_data) {
            createCandlestickChart(data.candlestick_data, data.trades);
        }
        
        // COMMENTED OUT: P&L Chart
        // if (data.pnl_data && data.trades && data.candlestick_data) {
        //     createPnLChart(data.pnl_data, data.trades, data.candlestick_data);
        // }

        // Create bar scores chart showing weighted indicator trigger combinations
        if (data.bar_scores_history && data.bar_scores_history.length > 0) {
            createBarScoresChart(
                data.bar_scores_history,
                data.bars_config || {},
                data.entry_conditions || [],
                data.exit_conditions || []
            );
        }

        // Create indicator charts (raw values + triggers)
        console.log('ðŸ” Indicator charts condition check:');
        console.log('  component_history:', !!data.component_history);
        console.log('  raw_indicator_history:', !!data.raw_indicator_history);
        console.log('  indicator_history:', !!data.indicator_history);
        console.log('  candlestick_data:', !!data.candlestick_data);
        console.log('  class_to_layout:', data.class_to_layout, 'keys:', Object.keys(data.class_to_layout || {}).length);
        console.log('  indicators:', data.indicators, 'count:', data.indicators?.length || 0);

        if (data.component_history && data.raw_indicator_history && data.indicator_history && data.candlestick_data && data.indicators && data.indicators.length > 0) {
            const indicatorConfigs = data.indicators;
            console.log('âœ… Creating indicator charts with configs:', indicatorConfigs);
            console.log('ðŸ“Š Per-aggregator candles available:', Object.keys(data.per_aggregator_candles || {}));
            console.log('ðŸ“Š Indicator-aggregator mapping:', data.indicator_agg_mapping || {});
            console.log('ðŸ“Š Chart configs available:', Object.keys(data.chart_configs || {}));
            createIndicatorCharts(
                data.component_history,
                data.raw_indicator_history,
                data.indicator_history,
                data.candlestick_data,
                indicatorConfigs,
                data.class_to_layout || {},
                data.per_aggregator_candles || {},
                data.indicator_agg_mapping || {},
                data.chart_configs || {}
            );
        } else {
            console.warn('âš ï¸ Skipping indicator charts - missing data or indicators');
        }

        // Populate trade history
        populateTradeHistory(data.trades);
    }
    
    function calculateMetrics(trades) {
        const totalTrades = trades.length;
        let winningTrades = 0;
        let losingTrades = 0;
        let totalWinPnL = 0;
        let totalLossPnL = 0;
        let cumulativePnL = 0;

        // Dollar-based tracking
        let totalWinDollars = 0;
        let totalLossDollars = 0;
        let cumulativePnLDollars = 0;
        let lastEntryPrice = 0;
        let lastPositionSize = 0;

        trades.forEach(trade => {
            // Track entry for dollar calculations
            if (trade.type === 'buy') {
                lastEntryPrice = trade.price || 0;
                lastPositionSize = trade.size || trade.quantity || 0;
            }

            // Calculate dollar P/L for this trade
            let tradePnLDollars = 0;
            if (trade.type === 'sell') {
                if (trade.pnl_dollars !== undefined) {
                    tradePnLDollars = trade.pnl_dollars;
                } else if (lastEntryPrice > 0) {
                    tradePnLDollars = lastPositionSize * ((trade.price || 0) - lastEntryPrice);
                }
            }

            if (trade.pnl > 0) {
                winningTrades++;
                totalWinPnL += trade.pnl;
                totalWinDollars += tradePnLDollars;
            } else if (trade.pnl < 0) {
                losingTrades++;
                totalLossPnL += Math.abs(trade.pnl);
                totalLossDollars += Math.abs(tradePnLDollars);
            }

            cumulativePnL += trade.pnl || 0;
            cumulativePnLDollars += tradePnLDollars;
        });

        const avgWin = winningTrades > 0 ? totalWinPnL / winningTrades : 0;
        const avgLoss = losingTrades > 0 ? totalLossPnL / losingTrades : 0;
        const avgWinDollars = winningTrades > 0 ? totalWinDollars / winningTrades : 0;
        const avgLossDollars = losingTrades > 0 ? totalLossDollars / losingTrades : 0;

        // Update Strategy Overview - Trade counts
        document.getElementById('winningTrades').textContent = winningTrades;
        document.getElementById('losingTrades').textContent = losingTrades;

        // Update Performance Metrics - Percentage
        document.getElementById('totalPnL').textContent = `${cumulativePnL.toFixed(2)}%`;
        document.getElementById('avgWin').textContent = `${avgWin.toFixed(2)}%`;
        document.getElementById('avgLoss').textContent = `${avgLoss.toFixed(2)}%`;

        // Update Performance Metrics - Dollars
        document.getElementById('totalPnLDollars').textContent = `$${cumulativePnLDollars.toFixed(2)}`;
        document.getElementById('avgWinDollars').textContent = `$${avgWinDollars.toFixed(2)}`;
        document.getElementById('avgLossDollars').textContent = `$${avgLossDollars.toFixed(2)}`;

        // Color coding - Percentage
        const totalPnLElement = document.getElementById('totalPnL');
        totalPnLElement.className = `h5 mb-0 ${cumulativePnL >= 0 ? 'text-success' : 'text-danger'}`;

        // Color coding - Dollars
        const totalPnLDollarsElement = document.getElementById('totalPnLDollars');
        totalPnLDollarsElement.className = `h5 mb-0 ${cumulativePnLDollars >= 0 ? 'text-success' : 'text-danger'}`;
    }
    
    function createCandlestickChart(candlestickData, trades) {
        // Prepare trade bands instead of triangular markers
        const chartConfig = {
            chart: {
                height: 500,
                zoomType: 'x',
                panKey: 'shift',
                panning: {
                    enabled: true,
                    type: 'x'
                },
                marginBottom: 10 // Reduce space for x-axis since labels are hidden
            },
            title: { text: 'Price Chart with Trade Background Shading' },
            xAxis: {
                type: 'datetime',
                ordinal: true, // Keep ordinal to remove gaps in candlestick chart
                breaks: [], // Clear any default breaks
                crosshair: true,
                labels: {
                    enabled: false // Hide x-axis labels (shown only on P&L chart)
                },
                lineWidth: 0,
                tickWidth: 0,
                plotBands: [] // Will be populated with trade bands
            },
            yAxis: { 
                title: { text: 'Price' },
                crosshair: true
            },
            series: [
                {
                    name: 'Price',
                    data: candlestickData,
                    type: 'candlestick',
                    color: '#dc3545',
                    upColor: '#28a745'
                }
            ],
            credits: { enabled: false }
        };
        
        if (charts.candlestick) {
            charts.candlestick.destroy();
        }
        charts.candlestick = Highcharts.chart('candlestickChart', chartConfig);
        
        // Clear any existing plot bands before adding new ones
        if (charts.candlestick.xAxis[0].plotLinesAndBands) {
            charts.candlestick.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                if (band.options.className && band.options.className.includes('trade-band')) {
                    band.destroy();
                }
            });
        }

        // Add background shading bands for trades
        addTradeBandsToChart(charts.candlestick, trades);

        // Enable synchronization for candlestick chart
        enableChartSynchronization(charts.candlestick);
    }

    /**
     * Adds trade background shading bands to a chart.
     * Reusable helper for both initial creation and updates.
     */
    function addTradeBandsToChart(chart, trades) {
        if (!chart || !trades || trades.length === 0) return;

        // Clear existing trade bands first
        if (chart.xAxis[0].plotLinesAndBands) {
            chart.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                if (band.options.className && band.options.className.includes('trade-band')) {
                    band.destroy();
                }
            });
        }

        // Group trades by pairs (buy followed by sell)
        const buyTrades = trades.filter(t => t.type === 'buy').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        const sellTrades = trades.filter(t => t.type === 'sell').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        // Create trade pairs and add background bands
        let buyIndex = 0, sellIndex = 0;
        let tradeCount = 0;

        while (buyIndex < buyTrades.length && sellIndex < sellTrades.length) {
            const buyTrade = buyTrades[buyIndex];
            const sellTrade = sellTrades[sellIndex];

            if (new Date(buyTrade.timestamp) < new Date(sellTrade.timestamp)) {
                // Calculate P&L for this trade pair
                const entryPrice = buyTrade.price;
                const exitPrice = sellTrade.price;
                const pnl = ((exitPrice - entryPrice) / entryPrice) * 100;

                // Use the actual P&L from trade data if available
                const actualPnl = sellTrade.pnl || pnl;
                const isActualProfit = actualPnl > 0;

                const bandColor = isActualProfit ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)';

                chart.xAxis[0].addPlotBand({
                    from: new Date(buyTrade.timestamp).getTime(),
                    to: new Date(sellTrade.timestamp).getTime(),
                    color: bandColor,
                    className: `trade-band trade-${tradeCount}`,
                    id: `trade-band-${tradeCount}`,
                    zIndex: 0, // Behind the candlesticks
                    label: {
                        text: `${isActualProfit ? '+' : ''}${actualPnl.toFixed(2)}%`,
                        align: 'center',
                        verticalAlign: 'middle',
                        style: {
                            color: isActualProfit ? '#28a745' : '#dc3545',
                            fontWeight: 'bold',
                            fontSize: '10px',
                            backgroundColor: 'rgba(255, 255, 255, 0.8)',
                            padding: '2px 4px',
                            borderRadius: '3px'
                        }
                    }
                });

                buyIndex++;
                sellIndex++;
                tradeCount++;
            } else {
                sellIndex++;
            }
        }
    }
    
    /* COMMENTED OUT: Cumulative P&L Evolution Chart
    function createPnLChart(pnlData, trades, candlestickData) {
        // Build P&L data with unrealized gains during open positions
        let adjustedPnlData = [];

        // Get time range from candlestick data
        const candlestickStart = candlestickData[0][0]; // First candlestick timestamp
        const candlestickEnd = candlestickData[candlestickData.length - 1][0]; // Last candlestick timestamp

        if (!trades || trades.length === 0) {
            // If no trades, just show flat line at 0
            adjustedPnlData.push([candlestickStart, 0]);
            adjustedPnlData.push([candlestickEnd, 0]);
        } else {
            // Sort trades by timestamp
            const sortedTrades = [...trades].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const buyTrades = sortedTrades.filter(t => t.type === 'buy');
            const sellTrades = sortedTrades.filter(t => t.type === 'sell');

            // Create a map of candlestick data for quick lookup
            const candlestickMap = new Map();
            candlestickData.forEach(candle => {
                candlestickMap.set(candle[0], candle[4]); // timestamp -> close price
            });

            let cumulativeRealizedPnL = 0;
            let currentPosition = null; // {entryPrice, entryTime, buyIndex}
            let buyIndex = 0;
            let sellIndex = 0;

            // Process each candlestick chronologically
            candlestickData.forEach((candle, idx) => {
                const timestamp = candle[0];
                const closePrice = candle[4];

                // Check if there's a buy trade at this timestamp
                while (buyIndex < buyTrades.length && new Date(buyTrades[buyIndex].timestamp).getTime() <= timestamp) {
                    if (!currentPosition) {
                        currentPosition = {
                            entryPrice: buyTrades[buyIndex].price,
                            entryTime: new Date(buyTrades[buyIndex].timestamp).getTime(),
                            buyIndex: buyIndex
                        };
                        console.log(`ðŸ“Š Position opened at ${new Date(timestamp)}, entry price: ${currentPosition.entryPrice}`);
                    }
                    buyIndex++;
                }

                // Check if there's a sell trade at this timestamp
                while (sellIndex < sellTrades.length && new Date(sellTrades[sellIndex].timestamp).getTime() <= timestamp) {
                    if (currentPosition) {
                        // Close position and add realized P&L
                        cumulativeRealizedPnL += (sellTrades[sellIndex].pnl || 0);
                        console.log(`ðŸ“Š Position closed at ${new Date(timestamp)}, realized P&L: ${sellTrades[sellIndex].pnl}, cumulative: ${cumulativeRealizedPnL}`);
                        currentPosition = null;
                    }
                    sellIndex++;
                }

                // Only add data points when in a position
                if (currentPosition) {
                    // Calculate current P&L (realized + unrealized)
                    const unrealizedPnL = ((closePrice - currentPosition.entryPrice) / currentPosition.entryPrice) * 100;
                    const currentPnL = cumulativeRealizedPnL + unrealizedPnL;
                    adjustedPnlData.push([timestamp, currentPnL]);
                } else {
                    // When no position, only add points at trade exits to maintain flat line
                    if (sellIndex > 0 && adjustedPnlData.length > 0) {
                        // Check if we just closed a position
                        const lastDataPoint = adjustedPnlData[adjustedPnlData.length - 1];
                        if (lastDataPoint[0] < timestamp) {
                            // Add a point to extend the flat line
                            adjustedPnlData.push([timestamp, cumulativeRealizedPnL]);
                        }
                    } else if (adjustedPnlData.length === 0) {
                        // Add initial point at 0 if we haven't started yet
                        adjustedPnlData.push([timestamp, 0]);
                    }
                }
            });
        }

        console.log(`ðŸ“ˆ P&L Chart data points: ${adjustedPnlData.length}, Range: ${new Date(candlestickStart)} to ${new Date(candlestickEnd)}`);

        const chartConfig = {
            chart: {
                type: 'line',
                height: 300,
                zoomType: 'x',
                panKey: 'shift',
                panning: {
                    enabled: true,
                    type: 'x'
                },
                marginBottom: 60 // Extra space for x-axis labels
            },
            title: { text: 'Cumulative P&L Evolution' },
            xAxis: {
                type: 'datetime',
                ordinal: true, // Match candlestick chart - removes gaps for weekends/after hours
                breaks: [],
                crosshair: true,
                labels: {
                    enabled: true // Show x-axis labels (this is the bottom chart)
                },
                lineWidth: 1,
                tickWidth: 1
            },
            yAxis: {
                title: { text: 'Cumulative P&L (%)' },
                plotLines: [{
                    value: 0,
                    color: '#999',
                    width: 1,
                    dashStyle: 'dash'
                }]
            },
            series: [{
                name: 'Cumulative P&L',
                data: adjustedPnlData,
                color: '#007bff',
                lineWidth: 2
                // Removed step line - now shows continuous unrealized P&L
            }],
            credits: { enabled: false }
        };

        if (charts.pnl) {
            charts.pnl.destroy();
        }
        charts.pnl = Highcharts.chart('pnlChart', chartConfig);

        // Enable synchronization for P&L chart
        enableChartSynchronization(charts.pnl);
    }
    END COMMENTED OUT: Cumulative P&L Evolution Chart */

    /**
     * Create bar scores chart showing weighted indicator trigger combinations.
     * Each bar is a line series, with threshold lines for entry/exit conditions.
     *
     * @param {Array} barScoresHistory - Array of {timestamp, scores: {bar_name: score}}
     * @param {Object} barsConfig - Bar definitions with weights and types
     * @param {Array} entryConditions - Entry conditions with thresholds
     * @param {Array} exitConditions - Exit conditions with thresholds
     */
    function createBarScoresChart(barScoresHistory, barsConfig, entryConditions, exitConditions) {
        console.log('ðŸ“Š Creating bar scores chart');
        console.log('   Bar scores history entries:', barScoresHistory.length);
        console.log('   Bars config:', Object.keys(barsConfig));
        console.log('   Entry conditions:', entryConditions);
        console.log('   Exit conditions:', exitConditions);

        if (!barScoresHistory || barScoresHistory.length === 0) {
            console.warn('âš ï¸ No bar scores history data');
            return;
        }

        // Get all unique bar names from the first entry
        const barNames = Object.keys(barScoresHistory[0]?.scores || {});
        if (barNames.length === 0) {
            console.warn('âš ï¸ No bar names found in scores history');
            return;
        }

        // Build threshold lookup from entry/exit conditions
        const thresholds = {};
        entryConditions.forEach(cond => {
            if (cond.name) thresholds[cond.name] = { value: cond.threshold || 0.5, type: 'entry' };
        });
        exitConditions.forEach(cond => {
            if (cond.name) thresholds[cond.name] = { value: cond.threshold || 0.5, type: 'exit' };
        });

        // Color palette for bars (bull bars in green tones, bear bars in red tones)
        const bullColors = ['#4CAF50', '#8BC34A', '#CDDC39', '#00BCD4'];
        const bearColors = ['#f44336', '#E91E63', '#FF5722', '#FF9800'];
        const defaultColors = ['#2196F3', '#9C27B0', '#607D8B', '#795548'];

        // Create series for each bar
        const series = [];
        let bullIdx = 0, bearIdx = 0, defaultIdx = 0;

        barNames.forEach(barName => {
            // Extract data for this bar
            const barData = barScoresHistory.map(entry => [
                entry.timestamp,
                entry.scores[barName] || 0
            ]);

            // Determine bar type and color
            const barConfig = barsConfig[barName] || {};
            const barType = barConfig.type || 'unknown';
            let color;

            if (barType === 'bull') {
                color = bullColors[bullIdx % bullColors.length];
                bullIdx++;
            } else if (barType === 'bear') {
                color = bearColors[bearIdx % bearColors.length];
                bearIdx++;
            } else {
                color = defaultColors[defaultIdx % defaultColors.length];
                defaultIdx++;
            }

            series.push({
                name: barName,
                data: barData,
                color: color,
                lineWidth: 2,
                marker: { enabled: false },
                tooltip: {
                    valueDecimals: 3
                }
            });
        });

        // Create threshold plot lines
        const plotLines = [];
        Object.entries(thresholds).forEach(([barName, thresh]) => {
            plotLines.push({
                value: thresh.value,
                color: thresh.type === 'entry' ? '#28a745' : '#dc3545',
                width: 1,
                dashStyle: 'Dash',
                label: {
                    text: `${barName}: ${thresh.value}`,
                    align: 'right',
                    style: {
                        fontSize: '9px',
                        color: thresh.type === 'entry' ? '#28a745' : '#dc3545'
                    }
                },
                zIndex: 3
            });
        });

        const chartConfig = {
            chart: {
                type: 'line',
                height: 280,
                zoomType: 'x',
                panKey: 'shift',
                panning: { enabled: true, type: 'x' },
                marginBottom: 10
            },
            title: { text: 'Bar Scores (Weighted Indicator Triggers)' },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                crosshair: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: {
                title: { text: 'Score' },
                min: 0,
                max: 1.1,
                crosshair: true,
                plotLines: plotLines,
                gridLineWidth: 1,
                gridLineColor: '#e6e6e6'
            },
            legend: {
                enabled: true,
                align: 'right',
                verticalAlign: 'top',
                layout: 'horizontal',
                itemStyle: { fontSize: '10px' }
            },
            plotOptions: {
                line: {
                    lineWidth: 2,
                    marker: { enabled: false },
                    states: { hover: { lineWidth: 3 } }
                }
            },
            series: series,
            tooltip: {
                shared: true,
                crosshairs: true,
                formatter: function() {
                    let s = '<b>' + Highcharts.dateFormat('%Y-%m-%d %H:%M', this.x) + '</b><br/>';
                    this.points.forEach(point => {
                        const thresh = thresholds[point.series.name];
                        const threshStr = thresh ? ` (thresh: ${thresh.value})` : '';
                        const triggered = thresh && point.y >= thresh.value ? ' âœ“' : '';
                        s += `<span style="color:${point.color}">â—</span> ${point.series.name}: <b>${point.y.toFixed(3)}</b>${threshStr}${triggered}<br/>`;
                    });
                    return s;
                }
            },
            credits: { enabled: false }
        };

        // Destroy existing chart if present
        if (charts.barScores) {
            charts.barScores.destroy();
        }

        charts.barScores = Highcharts.chart('barScoresChart', chartConfig);
        enableChartSynchronization(charts.barScores);

        console.log(`âœ… Bar scores chart created with ${barNames.length} bars`);
    }

    function createIndicatorCharts(componentHistory, rawIndicatorHistory, indicatorHistory, candlestickData, indicatorConfigs, classToLayout, perAggregatorCandles, indicatorAggMapping, chartConfigs) {
        console.log('ðŸ“Š Creating indicator charts');
        console.log('Component history keys:', Object.keys(componentHistory));
        console.log('Raw indicator history keys:', Object.keys(rawIndicatorHistory));
        console.log('Class to layout:', classToLayout);
        console.log('Per-aggregator candles:', Object.keys(perAggregatorCandles));
        console.log('Indicator-aggregator mapping:', indicatorAggMapping);
        console.log('Chart configs:', chartConfigs);

        // Get all unique indicator names from raw_indicator_history
        const indicatorNames = Object.keys(rawIndicatorHistory);
        if (indicatorNames.length === 0) {
            console.log('âš ï¸ No indicators found');
            return;
        }

        // Build a map of instance name to class name and agg_config from indicator configs
        const nameToClass = {};
        const nameToAggConfig = {};
        indicatorConfigs.forEach(config => {
            nameToClass[config.name] = config.indicator_class;
            nameToAggConfig[config.name] = config.agg_config || '1m-normal';
        });

        const tabsContainer = document.getElementById('indicatorTabs');
        const contentContainer = document.getElementById('indicatorTabContent');
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = '';

        // Create a tab for each indicator
        indicatorNames.forEach((indicatorName, index) => {
            const isActive = index === 0;
            const tabId = `indicator-tab-${index}`;
            const contentId = `indicator-content-${index}`;

            // Create tab button with indicator name data attribute
            const tabButton = document.createElement('li');
            tabButton.className = 'nav-item';
            tabButton.innerHTML = `
                <button class="nav-link ${isActive ? 'active' : ''}"
                        id="${tabId}"
                        data-bs-toggle="tab"
                        data-bs-target="#${contentId}"
                        data-indicator-name="${indicatorName}"
                        type="button"
                        role="tab">
                    ${indicatorName}
                </button>
            `;
            tabsContainer.appendChild(tabButton);

            // Add click listener to update main candlestick chart when tab is selected
            const buttonElement = tabButton.querySelector('button');
            buttonElement.addEventListener('click', () => {
                updateCandlestickChartForIndicator(indicatorName);
            });

            // Create tab content
            const tabContent = document.createElement('div');
            tabContent.className = `tab-pane fade ${isActive ? 'show active' : ''}`;
            tabContent.id = contentId;
            tabContent.role = 'tabpanel';

            // Add chart containers for raw values and triggers
            const rawChartId = `rawChart_${indicatorName.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const triggerChartId = `triggerChart_${indicatorName.replace(/[^a-zA-Z0-9]/g, '_')}`;

            tabContent.innerHTML = `
                <div id="${rawChartId}" style="height: 300px; margin-bottom: 10px;"></div>
                <div id="${triggerChartId}" style="height: 200px;"></div>
            `;
            contentContainer.appendChild(tabContent);

            // Create charts after a short delay to ensure DOM is ready
            setTimeout(() => {
                const indicatorClass = nameToClass[indicatorName];
                const aggConfig = nameToAggConfig[indicatorName] || indicatorAggMapping[indicatorName] || '1m-normal';

                // Get the correct candlestick data for this indicator's timeframe
                let indicatorCandles = perAggregatorCandles[aggConfig];
                if (!indicatorCandles) {
                    console.warn(`âš ï¸ No candles found for aggregator '${aggConfig}', falling back to primary candlestick data`);
                    indicatorCandles = candlestickData;
                } else {
                    console.log(`ðŸ“ˆ Using ${aggConfig} candles (${indicatorCandles.length} points) for ${indicatorName}`);
                }

                const rawChart = createRawIndicatorChart(indicatorName, indicatorClass, componentHistory, indicatorCandles, rawChartId, classToLayout, chartConfigs);
                const triggerChart = createTriggerChart(indicatorName, rawIndicatorHistory, indicatorHistory, triggerChartId);

                // Enable synchronization with all other charts
                if (rawChart) {
                    enableChartSynchronization(rawChart);
                }
                if (triggerChart) {
                    enableChartSynchronization(triggerChart);
                }
            }, 100);
        });

        // Trigger initial candlestick chart update for the first indicator
        if (indicatorNames.length > 0) {
            // Wait for charts to be created, then update candlestick for first indicator
            setTimeout(() => {
                updateCandlestickChartForIndicator(indicatorNames[0]);
                console.log(`ðŸ“Š Initial candlestick chart updated for first indicator: ${indicatorNames[0]}`);
            }, 200);
        }
    }

    // Helper function to find component keys by pattern matching
    function findComponentKeys(indicatorName, componentHistory, componentNames) {
        const foundKeys = {};

        for (const componentName of componentNames) {
            // Look for keys that end with the component name
            // Pattern: {indicatorName}_.._{componentName}
            const matchingKey = Object.keys(componentHistory).find(key => {
                return key.startsWith(indicatorName + '_') && key.endsWith('_' + componentName);
            });

            if (matchingKey) {
                foundKeys[componentName] = matchingKey;
            }
        }

        return foundKeys;
    }

    function createRawIndicatorChart(indicatorName, indicatorClass, componentHistory, candlestickData, chartId, classToLayout, chartConfigs) {
        // Get layout type from the indicator CLASS
        const layoutType = (classToLayout && classToLayout[indicatorClass]) || 'overlay';

        console.log(`ðŸ“ˆ Creating chart for instance '${indicatorName}' (class: ${indicatorClass}) with layout: '${layoutType}'`);

        // Check for self-describing chart config first (new config-driven approach)
        const chartConfig = chartConfigs && chartConfigs[indicatorClass];
        if (chartConfig && chartConfig.chart_type !== 'generic') {
            console.log(`   â†’ Using chart config for class '${indicatorClass}': ${chartConfig.chart_type}`);
            return createConfigDrivenChart(indicatorName, componentHistory, candlestickData, chartId, chartConfig);
        }

        // Fallback to legacy class name detection for backwards compatibility
        // ADX-type indicators (ADXTrendIndicator)
        if (indicatorClass && indicatorClass.toLowerCase().includes('adx')) {
            console.log(`   â†’ [Legacy] Routing to ADX chart for class '${indicatorClass}'`);
            return createADXChart(indicatorName, componentHistory, chartId);
        }

        // AROON-type indicators (AROONTrendIndicator)
        if (indicatorClass && indicatorClass.toLowerCase().includes('aroon')) {
            console.log(`   â†’ [Legacy] Routing to AROON chart for class '${indicatorClass}'`);
            return createAROONChart(indicatorName, componentHistory, chartId);
        }

        // MACD-type indicators (stacked layout with macd/signal/histogram)
        if (layoutType === 'stacked') {
            // Check if this looks like MACD by looking for macd components
            const macdKeys = findComponentKeys(indicatorName, componentHistory, ['macd', 'signal', 'histogram']);
            if (macdKeys.macd || macdKeys.signal || macdKeys.histogram) {
                return createMACDChart(indicatorName, componentHistory, chartId);
            }
            // For other stacked indicators, use generic chart
            return createGenericIndicatorChart(indicatorName, componentHistory, chartId);
        } else if (layoutType === 'overlay') {
            return createSMAChart(indicatorName, componentHistory, candlestickData, chartId);
        } else {
            // Default: line chart for unknown layout types
            return createGenericIndicatorChart(indicatorName, componentHistory, chartId);
        }
    }

    /**
     * Creates a chart based on the indicator's self-describing chart configuration.
     * This is the new config-driven approach that eliminates frontend hardcoding.
     */
    function createConfigDrivenChart(indicatorName, componentHistory, candlestickData, chartId, chartConfig) {
        console.log(`\nðŸ” [CONFIG-DRIVEN CHART] Creating chart for '${indicatorName}'`);
        console.log(`   Chart config:`, chartConfig);

        const series = [];
        const components = chartConfig.components || [];

        // Build series from components configuration
        for (const comp of components) {
            // Find the component key in componentHistory
            const keySuffix = comp.key_suffix;
            const matchingKey = Object.keys(componentHistory).find(key => {
                return key.startsWith(indicatorName + '_') && key.endsWith('_' + keySuffix);
            });

            if (matchingKey && componentHistory[matchingKey]) {
                const seriesConfig = {
                    name: comp.name,
                    data: componentHistory[matchingKey],
                    color: comp.color || '#2962FF',
                    lineWidth: comp.line_width || 2,
                    marker: { enabled: false }
                };

                // Apply optional styling
                if (comp.dash_style) {
                    seriesConfig.dashStyle = comp.dash_style;
                }
                if (comp.type === 'column') {
                    seriesConfig.type = 'column';
                }
                if (comp.y_axis !== undefined) {
                    seriesConfig.yAxis = comp.y_axis;
                }

                series.push(seriesConfig);
                console.log(`   âœ“ Found component '${keySuffix}' â†’ key '${matchingKey}'`);
            } else {
                console.log(`   âœ— Component '${keySuffix}' not found in componentHistory`);
            }
        }

        // If no components found, fall back to auto-discovery
        if (series.length === 0) {
            console.warn(`âš ï¸ No components matched for '${indicatorName}'. Using auto-discovery.`);
            return createGenericIndicatorChart(indicatorName, componentHistory, chartId);
        }

        // Build y-axis configuration
        const yAxisConfig = {
            title: { text: chartConfig.y_axis?.title || 'Value' }
        };
        if (chartConfig.y_axis?.min !== undefined) {
            yAxisConfig.min = chartConfig.y_axis.min;
        }
        if (chartConfig.y_axis?.max !== undefined) {
            yAxisConfig.max = chartConfig.y_axis.max;
        }

        // Build plot lines from reference_lines configuration
        const plotLines = (chartConfig.reference_lines || []).map(ref => ({
            value: ref.value,
            color: ref.color || '#9E9E9E',
            width: 1,
            dashStyle: ref.dash_style || 'Dash',
            label: {
                text: ref.label || '',
                align: 'right',
                style: { fontSize: '9px', color: ref.color || '#9E9E9E' }
            },
            zIndex: 1
        }));

        if (plotLines.length > 0) {
            yAxisConfig.plotLines = plotLines;
        }

        const highchartsConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - ${chartConfig.title_suffix || 'Raw Values'}`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: yAxisConfig,
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, highchartsConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createMACDChart(indicatorName, componentHistory, chartId) {
        // Find MACD components by pattern matching
        // Keys will be like: macd1m_macd_histogram_crossover_macd, macd1m_macd_histogram_crossover_signal, etc.
        console.log(`\nðŸ” [MACD CHART] Looking for components for '${indicatorName}'`);
        console.log(`   Available keys in componentHistory:`, Object.keys(componentHistory));

        const componentKeys = findComponentKeys(indicatorName, componentHistory, ['macd', 'signal', 'histogram']);

        const series = [];
        if (componentKeys.macd && componentHistory[componentKeys.macd]) {
            series.push({ name: 'MACD Line', data: componentHistory[componentKeys.macd], color: '#2962FF', lineWidth: 2, marker: { enabled: false } });
        }
        if (componentKeys.signal && componentHistory[componentKeys.signal]) {
            series.push({ name: 'Signal Line', data: componentHistory[componentKeys.signal], color: '#FF6D00', lineWidth: 2, marker: { enabled: false } });
        }
        if (componentKeys.histogram && componentHistory[componentKeys.histogram]) {
            series.push({
                name: 'Histogram',
                data: componentHistory[componentKeys.histogram],
                type: 'column',
                color: '#00897B'
            });
        }

        if (series.length === 0) {
            console.warn(`âš ï¸ No MACD components found for '${indicatorName}'.`);
        }

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Value' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    /**
     * Creates an ADX-style chart for ADXTrendIndicator and similar indicators.
     * Displays ADX value (trend strength) along with +DI and -DI lines.
     * Includes threshold reference lines at common ADX levels (20, 25, 40).
     */
    function createADXChart(indicatorName, componentHistory, chartId) {
        console.log(`\nðŸ” [ADX CHART] Looking for components for '${indicatorName}'`);
        console.log(`   Available keys in componentHistory:`, Object.keys(componentHistory));

        // Find ADX components by pattern matching
        const componentKeys = findComponentKeys(indicatorName, componentHistory, ['adx', 'plus_di', 'minus_di', 'strength', 'direction']);

        const series = [];

        // ADX line (main trend strength indicator, 0-100 scale)
        if (componentKeys.adx && componentHistory[componentKeys.adx]) {
            series.push({
                name: 'ADX',
                data: componentHistory[componentKeys.adx],
                color: '#2962FF',
                lineWidth: 2.5,
                marker: { enabled: false },
                tooltip: { valueSuffix: '' }
            });
        }

        // +DI line (positive directional indicator)
        if (componentKeys.plus_di && componentHistory[componentKeys.plus_di]) {
            series.push({
                name: '+DI',
                data: componentHistory[componentKeys.plus_di],
                color: '#26A69A',  // Green
                lineWidth: 1.5,
                marker: { enabled: false },
                dashStyle: 'ShortDash'
            });
        }

        // -DI line (negative directional indicator)
        if (componentKeys.minus_di && componentHistory[componentKeys.minus_di]) {
            series.push({
                name: '-DI',
                data: componentHistory[componentKeys.minus_di],
                color: '#EF5350',  // Red
                lineWidth: 1.5,
                marker: { enabled: false },
                dashStyle: 'ShortDash'
            });
        }

        if (series.length === 0) {
            console.warn(`âš ï¸ No ADX components found for '${indicatorName}'. Falling back to generic chart.`);
            return createGenericIndicatorChart(indicatorName, componentHistory, chartId);
        }

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - ADX Trend Analysis`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: {
                title: { text: 'Value' },
                min: 0,
                max: 100,
                plotLines: [
                    {
                        value: 20,
                        color: '#9E9E9E',
                        width: 1,
                        dashStyle: 'Dot',
                        label: {
                            text: 'Weak Trend (20)',
                            align: 'right',
                            style: { fontSize: '9px', color: '#9E9E9E' }
                        },
                        zIndex: 1
                    },
                    {
                        value: 25,
                        color: '#FFA726',
                        width: 1,
                        dashStyle: 'Dash',
                        label: {
                            text: 'Trend Threshold (25)',
                            align: 'right',
                            style: { fontSize: '9px', color: '#FFA726' }
                        },
                        zIndex: 1
                    },
                    {
                        value: 40,
                        color: '#66BB6A',
                        width: 1,
                        dashStyle: 'Dash',
                        label: {
                            text: 'Strong Trend (40)',
                            align: 'right',
                            style: { fontSize: '9px', color: '#66BB6A' }
                        },
                        zIndex: 1
                    }
                ]
            },
            legend: {
                enabled: true,
                align: 'right',
                verticalAlign: 'top',
                layout: 'horizontal',
                itemStyle: { fontSize: '10px' }
            },
            tooltip: {
                shared: true,
                crosshairs: true,
                formatter: function() {
                    let s = '<b>' + Highcharts.dateFormat('%Y-%m-%d %H:%M', this.x) + '</b><br/>';
                    this.points.forEach(point => {
                        const value = point.y !== null ? point.y.toFixed(2) : 'N/A';
                        s += `<span style="color:${point.color}">â—</span> ${point.series.name}: <b>${value}</b><br/>`;
                    });
                    // Add trend interpretation
                    const adxPoint = this.points.find(p => p.series.name === 'ADX');
                    const plusDiPoint = this.points.find(p => p.series.name === '+DI');
                    const minusDiPoint = this.points.find(p => p.series.name === '-DI');
                    if (adxPoint && plusDiPoint && minusDiPoint) {
                        const adx = adxPoint.y;
                        const plusDi = plusDiPoint.y;
                        const minusDi = minusDiPoint.y;
                        let trend = 'No Trend';
                        if (adx >= 25) {
                            trend = plusDi > minusDi ? 'ðŸ“ˆ Bullish' : 'ðŸ“‰ Bearish';
                            if (adx >= 40) trend += ' (Strong)';
                        }
                        s += `<br/><b>Trend: ${trend}</b>`;
                    }
                    return s;
                }
            },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        console.log(`âœ… ADX chart created for '${indicatorName}' with ${series.length} series`);
        return chart;
    }

    /**
     * Creates an AROON-style chart for AROONTrendIndicator.
     * Displays AROON Up, AROON Down, and the Oscillator.
     */
    function createAROONChart(indicatorName, componentHistory, chartId) {
        console.log(`\nðŸ” [AROON CHART] Looking for components for '${indicatorName}'`);
        console.log(`   Available keys in componentHistory:`, Object.keys(componentHistory));

        // Find AROON components by pattern matching
        const componentKeys = findComponentKeys(indicatorName, componentHistory, ['up', 'down', 'oscillator']);

        const series = [];

        // AROON Up line
        if (componentKeys.up && componentHistory[componentKeys.up]) {
            series.push({
                name: 'AROON Up',
                data: componentHistory[componentKeys.up],
                color: '#26A69A',  // Green
                lineWidth: 2,
                marker: { enabled: false }
            });
        }

        // AROON Down line
        if (componentKeys.down && componentHistory[componentKeys.down]) {
            series.push({
                name: 'AROON Down',
                data: componentHistory[componentKeys.down],
                color: '#EF5350',  // Red
                lineWidth: 2,
                marker: { enabled: false }
            });
        }

        // AROON Oscillator (optional, separate y-axis could be added)
        if (componentKeys.oscillator && componentHistory[componentKeys.oscillator]) {
            series.push({
                name: 'Oscillator',
                data: componentHistory[componentKeys.oscillator],
                color: '#7E57C2',  // Purple
                lineWidth: 1.5,
                dashStyle: 'ShortDash',
                marker: { enabled: false }
            });
        }

        if (series.length === 0) {
            console.warn(`âš ï¸ No AROON components found for '${indicatorName}'. Falling back to generic chart.`);
            return createGenericIndicatorChart(indicatorName, componentHistory, chartId);
        }

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - AROON Analysis`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: {
                title: { text: 'Value' },
                min: -100,
                max: 100,
                plotLines: [
                    {
                        value: 0,
                        color: '#9E9E9E',
                        width: 1,
                        dashStyle: 'Solid',
                        zIndex: 1
                    },
                    {
                        value: 50,
                        color: '#26A69A',
                        width: 1,
                        dashStyle: 'Dot',
                        label: {
                            text: 'Bullish Zone',
                            align: 'right',
                            style: { fontSize: '9px', color: '#26A69A' }
                        },
                        zIndex: 1
                    },
                    {
                        value: -50,
                        color: '#EF5350',
                        width: 1,
                        dashStyle: 'Dot',
                        label: {
                            text: 'Bearish Zone',
                            align: 'right',
                            style: { fontSize: '9px', color: '#EF5350' }
                        },
                        zIndex: 1
                    }
                ]
            },
            legend: {
                enabled: true,
                align: 'right',
                verticalAlign: 'top',
                layout: 'horizontal',
                itemStyle: { fontSize: '10px' }
            },
            tooltip: {
                shared: true,
                crosshairs: true
            },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        console.log(`âœ… AROON chart created for '${indicatorName}' with ${series.length} series`);
        return chart;
    }

    function createSMAChart(indicatorName, componentHistory, candlestickData, chartId) {
        // Find SMA component by pattern matching
        // Keys will be like: sma1m_sma, sma_crossover_1m_sma, etc.
        const componentKeys = findComponentKeys(indicatorName, componentHistory, ['sma']);

        const series = [
            {
                name: 'Price',
                data: candlestickData,
                type: 'candlestick',
                color: '#dc3545',
                upColor: '#28a745'
            }
        ];

        if (componentKeys.sma && componentHistory[componentKeys.sma]) {
            series.push({
                name: indicatorName,
                data: componentHistory[componentKeys.sma],
                type: 'line',
                color: '#2962FF',
                lineWidth: 2,
                marker: { enabled: false }
            });
        } else {
            console.warn(`âš ï¸ No SMA component found for '${indicatorName}'.`);
        }

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values (with Price)`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Price' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createGenericIndicatorChart(indicatorName, componentHistory, chartId) {
        // For unknown indicator types, just plot any matching components
        const matchingKeys = Object.keys(componentHistory).filter(k =>
            k.toLowerCase().includes(indicatorName.toLowerCase())
        );

        const series = matchingKeys.map(key => ({
            name: key,
            data: componentHistory[key],
            lineWidth: 2,
            marker: { enabled: false }
        }));

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Value' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createTriggerChart(indicatorName, rawIndicatorHistory, indicatorHistory, chartId) {
        const series = [];

        // Add time-decayed trigger values (1, 0.9, 0.8, etc.)
        if (indicatorHistory[indicatorName]) {
            series.push({
                name: 'Trigger with Decay',
                data: indicatorHistory[indicatorName],
                color: '#9C27B0',
                lineWidth: 2,
                marker: { enabled: false }
            });
        }

        const chartConfig = {
            chart: { height: 200, zoomType: 'x' },
            title: { text: `${indicatorName} - Trigger Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: true }
            },
            yAxis: {
                title: { text: 'Trigger' },
                min: 0,
                max: 1.1,
                plotLines: [{
                    value: 1,
                    color: '#999',
                    width: 1,
                    dashStyle: 'dash'
                }]
            },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`trigger_${indicatorName}`] = chart;
        return chart;
    }

    function enableChartSynchronization(chart) {
        // Enhanced synchronization for stacked charts including scroll zoom
        chart.update({
            chart: {
                events: {
                    selection: function(event) {
                        if (event.xAxis) {
                            const min = event.xAxis[0].min;
                            const max = event.xAxis[0].max;
                            syncAllCharts(min, max, chart);
                        }
                    },
                    load: function() {
                        // Add mouse wheel zoom synchronization and pan support
                        const chartContainer = this.container;

                        // Mouse wheel zoom (works with or without Ctrl/Cmd key)
                        chartContainer.addEventListener('wheel', function(e) {
                            // Only zoom on wheel over chart area, not the entire page
                            if (e.target.closest('.highcharts-container')) {
                                e.preventDefault();
                                e.stopPropagation();

                                // Prevent sync loop
                                if (window.syncInProgress) return;

                                const chart = chartContainer.chart || chartContainer.hcChart || this;
                                if (chart && chart.xAxis && chart.xAxis[0]) {
                                    const xAxis = chart.xAxis[0];
                                    const currentMin = xAxis.min;
                                    const currentMax = xAxis.max;
                                    const range = currentMax - currentMin;

                                    // Smaller zoom factor for smoother zoom
                                    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                                    const newRange = range * zoomFactor;

                                    // Get mouse position relative to chart for zoom center
                                    const rect = chartContainer.getBoundingClientRect();
                                    const mouseX = e.clientX - rect.left;
                                    const plotLeft = chart.plotLeft || 60;
                                    const plotWidth = chart.plotWidth || (rect.width - 120);

                                    // Calculate zoom center based on mouse position
                                    let centerRatio = 0.5; // Default center
                                    if (mouseX >= plotLeft && mouseX <= plotLeft + plotWidth) {
                                        centerRatio = (mouseX - plotLeft) / plotWidth;
                                    }

                                    const center = currentMin + (range * centerRatio);
                                    const newMin = center - (newRange * centerRatio);
                                    const newMax = center + (newRange * (1 - centerRatio));

                                    // Ensure we don't zoom beyond data limits and maintain minimum range
                                    const dataMin = xAxis.getExtremes().dataMin || currentMin;
                                    const dataMax = xAxis.getExtremes().dataMax || currentMax;
                                    const minRange = (dataMax - dataMin) / 1000; // Minimum zoom level

                                    if (newMin >= dataMin && newMax <= dataMax && newRange > minRange) {
                                        console.log('Wheel zoom:', {newMin, newMax, range: newRange});
                                        syncAllCharts(newMin, newMax, chart);
                                    }
                                }
                            }
                        }, { passive: false });

                        // Store reference for cleanup
                        this.syncContainer = chartContainer;
                    }
                }
            },
            xAxis: {
                events: {
                    afterSetExtremes: function(e) {
                        // Only sync if this was a user action (including mouse wheel)
                        if (e.trigger === 'zoom' || e.trigger === 'pan' || e.trigger === 'selection' || e.trigger === 'mousewheel') {
                            syncAllCharts(e.min, e.max, chart);
                        }
                    }
                }
            }
        });
    }

    function syncAllCharts(min, max, sourceChart) {
        // Prevent infinite loops by temporarily disabling sync
        if (window.syncInProgress) return;
        window.syncInProgress = true;

        console.log('Syncing all charts:', {min, max, sourceChart: sourceChart.renderTo?.id || 'unknown'});

        try {
            let syncedCount = 0;
            Object.values(charts).forEach(chart => {
                if (chart !== sourceChart && chart.xAxis && chart.xAxis[0]) {
                    // Use setExtremes with redraw true for immediate visual feedback
                    chart.xAxis[0].setExtremes(min, max, true, false);
                    syncedCount++;
                }
            });
            console.log(`Synced ${syncedCount} charts`);
        } finally {
            // Re-enable sync after a short delay
            setTimeout(() => {
                window.syncInProgress = false;
            }, 50); // Shorter delay for more responsive sync
        }
    }

    /**
     * Zooms all charts to center around a specific trade timestamp.
     * Creates a window of approximately 2 hours (60 minutes before and after)
     * centered on the trade time for detailed analysis.
     *
     * @param {number} timestamp - The trade timestamp in milliseconds
     */
    function zoomChartsToTradeTimestamp(timestamp) {
        // Define zoom window: Â±60 minutes around the trade (2 hours total)
        const zoomWindowMs = 60 * 60 * 1000; // 60 minutes in milliseconds
        const min = timestamp - zoomWindowMs;
        const max = timestamp + zoomWindowMs;

        console.log(`ðŸ“ Zooming charts to trade at ${new Date(timestamp).toLocaleString()}`);
        console.log(`   Window: ${new Date(min).toLocaleString()} to ${new Date(max).toLocaleString()}`);

        // Get any chart to use as reference (we'll sync all charts including the source)
        const firstChart = Object.values(charts)[0];
        if (!firstChart) {
            console.warn('âš ï¸ No charts available to zoom');
            return;
        }

        // Get data bounds from the first chart to clamp the zoom window
        const xAxis = firstChart.xAxis && firstChart.xAxis[0];
        if (xAxis) {
            const extremes = xAxis.getExtremes();
            const dataMin = extremes.dataMin || min;
            const dataMax = extremes.dataMax || max;

            // Clamp zoom window to data bounds
            const clampedMin = Math.max(min, dataMin);
            const clampedMax = Math.min(max, dataMax);

            // Ensure minimum range (at least 30 minutes)
            const minRange = 30 * 60 * 1000;
            if (clampedMax - clampedMin < minRange) {
                const center = timestamp;
                const halfMinRange = minRange / 2;
                const adjustedMin = Math.max(center - halfMinRange, dataMin);
                const adjustedMax = Math.min(center + halfMinRange, dataMax);
                syncAllChartsFromDetails(adjustedMin, adjustedMax);
            } else {
                syncAllChartsFromDetails(clampedMin, clampedMax);
            }
        }
    }

    /**
     * Syncs all charts to a specific time range (for use from trade details).
     * This variant updates ALL charts including the first one since there's no
     * "source" chart when triggered from the trade details popup.
     *
     * @param {number} min - Start of zoom window in milliseconds
     * @param {number} max - End of zoom window in milliseconds
     */
    function syncAllChartsFromDetails(min, max) {
        // Prevent infinite loops
        if (window.syncInProgress) return;
        window.syncInProgress = true;

        console.log(`ðŸ” Zooming all charts to: ${new Date(min).toLocaleString()} - ${new Date(max).toLocaleString()}`);

        try {
            let syncedCount = 0;
            Object.values(charts).forEach(chart => {
                if (chart && chart.xAxis && chart.xAxis[0]) {
                    chart.xAxis[0].setExtremes(min, max, true, false);
                    syncedCount++;
                }
            });
            console.log(`âœ… Zoomed ${syncedCount} charts to trade timestamp`);
        } finally {
            setTimeout(() => {
                window.syncInProgress = false;
            }, 50);
        }
    }
    
    function populateTradeHistory(trades) {
        const tableBody = document.getElementById('tradeHistoryTable');

        if (!trades || trades.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="10" class="text-center text-muted">No trades to display</td></tr>';
            return;
        }

        let cumulativePnLPct = 0;
        let cumulativePnLDollars = 0;
        let lastEntryPrice = 0;
        let lastPositionSize = 0;

        const rows = trades.map(trade => {
            // Track entry price and position size for dollar P/L calculation
            if (trade.type === 'buy') {
                lastEntryPrice = trade.price || 0;
                lastPositionSize = trade.size || 0;
            }

            // Calculate dollar P/L for sell trades
            let pnlDollars = 0;
            if (trade.type === 'sell' && lastEntryPrice > 0) {
                // Dollar P/L = position_size * (exit_price - entry_price)
                pnlDollars = lastPositionSize * ((trade.price || 0) - lastEntryPrice);
            }

            // Also check if pnl_dollars is provided from backend
            if (trade.pnl_dollars !== undefined) {
                pnlDollars = trade.pnl_dollars;
            }

            cumulativePnLPct += trade.pnl || 0;
            cumulativePnLDollars += pnlDollars;

            const pnlPct = trade.pnl || 0;
            const pnlPctClass = pnlPct > 0 ? 'text-success' : (pnlPct < 0 ? 'text-danger' : '');
            const pnlDollarsClass = pnlDollars > 0 ? 'text-success' : (pnlDollars < 0 ? 'text-danger' : '');
            const cumPctClass = cumulativePnLPct >= 0 ? 'text-success' : 'text-danger';
            const cumDollarsClass = cumulativePnLDollars >= 0 ? 'text-success' : 'text-danger';

            // Format date and time using selected timezone (from timezone-utils.js)
            const dateTimeStr = formatDateTimeInTimezone(trade.timestamp, window.currentTimezone, {
                timeZone: window.currentTimezone,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });

            // Format P/L values (show dash for entry trades)
            const pnlPctDisplay = trade.type === 'sell' ? `${pnlPct.toFixed(2)}%` : '-';
            const pnlDollarsDisplay = trade.type === 'sell' ? `$${pnlDollars.toFixed(2)}` : '-';
            const cumPctDisplay = trade.type === 'sell' ? `${cumulativePnLPct.toFixed(2)}%` : '-';
            const cumDollarsDisplay = trade.type === 'sell' ? `$${cumulativePnLDollars.toFixed(2)}` : '-';

            return `
                <tr>
                    <td class="small">${dateTimeStr}</td>
                    <td><span class="badge bg-${trade.type === 'buy' ? 'success' : 'danger'}">${trade.type}</span></td>
                    <td>$${(trade.price || 0).toFixed(2)}</td>
                    <td>${trade.size || 0}</td>
                    <td class="pnl-col-pct ${pnlPctClass}">${pnlPctDisplay}</td>
                    <td class="pnl-col-dollars ${pnlDollarsClass}">${pnlDollarsDisplay}</td>
                    <td class="pnl-col-pct ${cumPctClass}">${cumPctDisplay}</td>
                    <td class="pnl-col-dollars ${cumDollarsClass}">${cumDollarsDisplay}</td>
                    <td class="small">${trade.reason || '-'}</td>
                    <td><button class="btn btn-sm btn-outline-primary" onclick="showTradeDetails(${trade.timestamp})">Details</button></td>
                </tr>
            `;
        }).join('');

        tableBody.innerHTML = rows;

        // Apply current display mode
        updatePnLDisplay();
    }

    /**
     * Toggle P&L column visibility based on selected display mode
     */
    function updatePnLDisplay() {
        const mode = document.getElementById('pnlDisplayMode').value;
        const pctCols = document.querySelectorAll('.pnl-col-pct');
        const dollarCols = document.querySelectorAll('.pnl-col-dollars');

        pctCols.forEach(col => {
            col.style.display = (mode === 'percent' || mode === 'both') ? '' : 'none';
        });

        dollarCols.forEach(col => {
            col.style.display = (mode === 'dollars' || mode === 'both') ? '' : 'none';
        });
    }

    // Show trade details popup
    window.showTradeDetails = function(timestamp) {
        const details = globalChartData.tradeDetails[timestamp];
        if (!details) {
            alert('No detailed information available for this trade.');
            return;
        }

        // Zoom all charts to center around this trade's timestamp
        zoomChartsToTradeTimestamp(timestamp);

        // Format the details for the modal
        let content = `<div class="trade-details-content">`;
        content += `<h5 class="mb-3">${details.action || 'Trade'}</h5>`;
        content += `<p><strong>Date/Time:</strong> ${details.datetime || 'N/A'}</p>`;

        if (details.type === 'entry') {
            content += `<p><strong>Entry Price:</strong> $${(details.price || 0).toFixed(2)}</p>`;
            content += `<p><strong>Position Size:</strong> ${details.position_size || 'N/A'}</p>`;

            // Trigger info
            if (details.trigger_info) {
                content += `<hr><h6>Trigger Reason</h6>`;
                content += `<p><strong>Trigger Bar:</strong> ${details.trigger_info.bar_name || 'N/A'}</p>`;
                content += `<p><strong>Bar Score:</strong> ${(details.trigger_info.bar_score || 0).toFixed(4)} >= ${(details.trigger_info.threshold || 0).toFixed(4)}</p>`;
            }

            // Exit targets
            content += `<hr><h6>Exit Targets</h6>`;
            content += `<p><strong>Stop Loss:</strong> $${(details.stop_loss || 0).toFixed(2)} (${((details.stop_loss_pct || 0) * 100).toFixed(2)}% below entry)</p>`;
            // Show take profit with type indicator
            if (details.take_profit_type === 'dollars') {
                content += `<p><strong>Take Profit:</strong> $${(details.take_profit || 0).toFixed(2)} <span class="badge bg-info">$${(details.take_profit_dollars || 0).toFixed(2)} target</span></p>`;
            } else {
                content += `<p><strong>Take Profit:</strong> $${(details.take_profit || 0).toFixed(2)} (${((details.take_profit_pct || 0) * 100).toFixed(2)}% above entry)</p>`;
            }
            if (details.trailing_stop_loss) {
                content += `<p><strong>Trailing Stop:</strong> $${(details.trailing_stop_price || 0).toFixed(2)}</p>`;
                content += `<p class="small text-muted">Distance: ${((details.trailing_stop_distance_pct || 0) * 100).toFixed(2)}%, Activation: ${((details.trailing_stop_activation_pct || 0) * 100).toFixed(2)}%</p>`;
            }
        } else {
            // Exit trade
            content += `<p><strong>Entry Price:</strong> $${(details.entry_price || 0).toFixed(2)}</p>`;
            content += `<p><strong>Exit Price:</strong> $${(details.exit_price || 0).toFixed(2)}</p>`;
            content += `<p><strong>Position Size:</strong> ${details.position_size || 'N/A'}</p>`;
            // Calculate dollar P/L if not provided
            const pnlDollars = details.pnl_dollars !== undefined ? details.pnl_dollars :
                (details.position_size && details.exit_price && details.entry_price ?
                    details.position_size * (details.exit_price - details.entry_price) : 0);
            const pnlClass = (details.pnl_pct || 0) >= 0 ? 'text-success' : 'text-danger';
            content += `<p><strong>P&L:</strong> <span class="${pnlClass}">${(details.pnl_pct || 0).toFixed(2)}% ($${pnlDollars.toFixed(2)})</span></p>`;

            // Trigger info
            if (details.trigger_info) {
                content += `<hr><h6>Exit Reason</h6>`;
                content += `<p><strong>Reason:</strong> ${details.trigger_info.reason || 'N/A'}</p>`;
                if (details.trigger_info.bar_name) {
                    content += `<p><strong>Trigger Bar:</strong> ${details.trigger_info.bar_name}</p>`;
                    content += `<p><strong>Bar Score:</strong> ${(details.trigger_info.bar_score || 0).toFixed(4)} >= ${(details.trigger_info.threshold || 0).toFixed(4)}</p>`;
                }
                if (details.trigger_info.trigger_price) {
                    content += `<p><strong>Trigger Price:</strong> $${(details.trigger_info.trigger_price || 0).toFixed(2)}</p>`;
                }
            }
        }

        // Bar scores at trade time
        if (details.bar_scores && Object.keys(details.bar_scores).length > 0) {
            content += `<hr><h6>Bar Scores at Trade</h6>`;
            content += `<table class="table table-sm table-bordered"><tbody>`;
            for (const [barName, score] of Object.entries(details.bar_scores)) {
                content += `<tr><td>${barName}</td><td>${(score || 0).toFixed(4)}</td></tr>`;
            }
            content += `</tbody></table>`;
        }

        // Indicator values at trade time
        if (details.indicators && Object.keys(details.indicators).length > 0) {
            content += `<hr><h6>Indicator Values at Trade</h6>`;
            content += `<table class="table table-sm table-bordered"><tbody>`;
            for (const [indName, value] of Object.entries(details.indicators)) {
                content += `<tr><td>${indName}</td><td>${(value || 0).toFixed(4)}</td></tr>`;
            }
            content += `</tbody></table>`;
        }

        content += `</div>`;

        // Show in modal
        document.getElementById('tradeDetailsContent').innerHTML = content;
        const modal = new bootstrap.Modal(document.getElementById('tradeDetailsModal'));
        modal.show();
    }

    /**
     * Updates the main candlestick chart when an indicator tab is selected.
     * This ensures the candlestick data matches the indicator's timeframe.
     */
    function updateCandlestickChartForIndicator(indicatorName) {
        console.log(`ðŸ”„ Updating candlestick chart for indicator: ${indicatorName}`);

        // Get the aggregator config for this indicator
        const aggConfig = globalChartData.nameToAggConfig[indicatorName] ||
                          globalChartData.indicatorAggMapping[indicatorName] ||
                          '1m-normal';

        console.log(`   Aggregator config: ${aggConfig}`);

        // Get the candlestick data for this aggregator
        let candlestickData = globalChartData.perAggregatorCandles[aggConfig];

        if (!candlestickData) {
            console.warn(`âš ï¸ No candles found for aggregator '${aggConfig}', keeping current chart`);
            return;
        }

        console.log(`   Using ${candlestickData.length} candles from ${aggConfig}`);

        // Update the main candlestick chart if it exists
        if (charts.candlestick) {
            // Update the chart title to reflect the current timeframe
            charts.candlestick.setTitle({ text: `Price Chart (${aggConfig}) with Trade Background Shading` });

            // Update the candlestick series data
            charts.candlestick.series[0].setData(candlestickData, false);

            // Re-add trade bands using the reusable helper
            addTradeBandsToChart(charts.candlestick, globalChartData.trades);

            // Redraw the chart
            charts.candlestick.redraw();

            console.log(`âœ… Candlestick chart updated with ${aggConfig} data`);
        }

        // Store current indicator for reference
        globalChartData.currentIndicator = indicatorName;
    }

    // Check for data from optimizer in sessionStorage
    async function checkForOptimzerData() {
        const monitorConfigJson = sessionStorage.getItem('replayMonitorConfig');
        const dataConfigJson = sessionStorage.getItem('replayDataConfig');

        if (monitorConfigJson && dataConfigJson) {
            console.log('ðŸ“¥ Received configs from optimizer, loading...');

            try {
                // Ensure indicator classes are loaded first
                if (!indicatorClasses || Object.keys(indicatorClasses).length === 0) {
                    console.log('â³ Waiting for indicator classes to load...');
                    await loadIndicatorClasses();
                }

                // Parse configs
                const receivedConfig = JSON.parse(monitorConfigJson);
                dataConfig = JSON.parse(dataConfigJson);

                // Transform the flat MonitorConfiguration structure to the nested format
                // that renderMonitorConfiguration expects
                monitorConfig = {
                    monitor: {
                        name: receivedConfig.name || '',
                        description: receivedConfig.description || '',
                        trade_executor: receivedConfig.trade_executor || {},
                        bars: receivedConfig.bars || {},
                        enter_long: receivedConfig.enter_long || [],
                        exit_long: receivedConfig.exit_long || []
                    },
                    indicators: receivedConfig.indicators || []
                };

                console.log('ðŸ”„ Transformed monitor config:', monitorConfig);
                console.log('ðŸ“Š Indicator count:', monitorConfig.indicators.length);
                if (monitorConfig.indicators.length > 0) {
                    console.log('ðŸ“Š First indicator:', monitorConfig.indicators[0]);
                    console.log('ðŸ“Š First indicator_class:', monitorConfig.indicators[0].indicator_class);
                }

                // Clear sessionStorage to prevent reloading on refresh
                sessionStorage.removeItem('replayMonitorConfig');
                sessionStorage.removeItem('replayDataConfig');

                // Render configurations
                renderMonitorConfiguration();
                renderDataConfiguration();

                // Show editor and enable run button
                configEditor.style.display = 'block';
                runReplayBtn.disabled = false;

                showAlert('Elite configuration loaded from optimizer!', 'success');

                console.log('âœ… Configurations loaded and rendered');
            } catch (error) {
                console.error('Error loading configs from sessionStorage:', error);
                showAlert('Error loading configuration from optimizer', 'danger');
            }
        }
    }

    // =========================================================================
    // DEBUG AND EXPORT FUNCTIONS
    // =========================================================================

    /**
     * Capture debug data from current chart view.
     * Shows indicator values, bar scores, and price data for the visible range.
     */
    window.captureDebugData = function() {
        const debugData = {
            timestamp: new Date().toISOString(),
            visibleRange: { from: null, to: null },
            indicators: {},
            barScores: {},
            priceData: [],
            chartConfig: {}
        };

        // Get visible range from candlestick chart
        if (charts.candlestick && charts.candlestick.xAxis && charts.candlestick.xAxis[0]) {
            const xAxis = charts.candlestick.xAxis[0];
            const extremes = xAxis.getExtremes();
            debugData.visibleRange.from = extremes.min;
            debugData.visibleRange.to = extremes.max;

            // Format dates for display
            const fromDate = new Date(extremes.min);
            const toDate = new Date(extremes.max);
            document.getElementById('debugRangeFrom').textContent = fromDate.toLocaleString();
            document.getElementById('debugRangeTo').textContent = toDate.toLocaleString();
        }

        // Collect price data in visible range
        if (charts.candlestick && charts.candlestick.series) {
            charts.candlestick.series.forEach(series => {
                if (series.name === 'Price' || series.type === 'candlestick') {
                    const visibleData = series.data.filter(point => {
                        if (!point || point.x === undefined) return false;
                        return point.x >= debugData.visibleRange.from &&
                               point.x <= debugData.visibleRange.to;
                    });
                    debugData.priceData = visibleData.map(p => ({
                        time: new Date(p.x).toISOString(),
                        open: p.open,
                        high: p.high,
                        low: p.low,
                        close: p.close
                    }));
                }
            });
        }

        // Collect bar scores in visible range
        if (charts.barScores && charts.barScores.series) {
            charts.barScores.series.forEach(series => {
                if (!series.visible || !series.data) return;
                const visibleData = series.data.filter(point => {
                    if (!point || point.x === undefined) return false;
                    return point.x >= debugData.visibleRange.from &&
                           point.x <= debugData.visibleRange.to;
                });
                debugData.barScores[series.name] = visibleData.map(p => ({
                    time: new Date(p.x).toISOString(),
                    value: p.y
                }));
            });
        }

        // Collect indicator data from all indicator charts
        // Charts are stored with prefixes: raw_, trigger_
        const indicatorChartPrefixes = ['raw_', 'trigger_'];
        const indicatorCharts = Object.keys(charts).filter(k =>
            indicatorChartPrefixes.some(prefix => k.startsWith(prefix))
        );

        console.log('Debug: Found indicator charts:', indicatorCharts);

        indicatorCharts.forEach(chartKey => {
            const chart = charts[chartKey];
            if (!chart || !chart.series) return;

            chart.series.forEach(series => {
                if (!series.visible || !series.data) return;
                const seriesKey = `${chartKey}::${series.name}`;
                const visibleData = series.data.filter(point => {
                    if (!point || point.x === undefined) return false;
                    return point.x >= debugData.visibleRange.from &&
                           point.x <= debugData.visibleRange.to;
                });
                debugData.indicators[seriesKey] = visibleData.map(p => ({
                    time: new Date(p.x).toISOString(),
                    value: p.y
                }));
            });
        });

        // Also list all chart keys for debugging
        debugData.chartKeys = Object.keys(charts);

        // Also collect from globalChartData if available
        if (globalChartData && globalChartData.indicatorConfigs) {
            debugData.chartConfig.indicatorConfigs = globalChartData.indicatorConfigs;
        }

        // Format for display
        const indicatorText = JSON.stringify(debugData.indicators, null, 2);
        const barScoresText = JSON.stringify(debugData.barScores, null, 2);
        const fullJson = JSON.stringify(debugData, null, 2);

        document.getElementById('debugIndicatorPre').textContent = indicatorText;
        document.getElementById('debugBarScoresPre').textContent = barScoresText;
        document.getElementById('debugJsonOutput').value = fullJson;

        // Store for download
        window.currentDebugData = debugData;

        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('debugDataModal'));
        modal.show();
    };

    /**
     * Copy debug JSON to clipboard.
     */
    window.copyDebugToClipboard = function() {
        const jsonOutput = document.getElementById('debugJsonOutput');
        jsonOutput.select();
        document.execCommand('copy');
        showAlert('Debug data copied to clipboard!', 'success');
    };

    /**
     * Download debug data as JSON file.
     */
    window.downloadDebugJson = function() {
        if (!window.currentDebugData) {
            showAlert('No debug data available', 'warning');
            return;
        }
        const filename = `debug_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        downloadJsonFile(window.currentDebugData, filename);
        showAlert('Debug data downloaded!', 'success');
    };

    /**
     * Save all charts as a single image.
     * Captures Price Chart, Bar Scores, and visible Indicator charts.
     */
    window.saveChartsAsImage = async function() {
        showAlert('Capturing charts...', 'info');

        try {
            // Use html2canvas to capture the entire stacked charts container
            const container = document.getElementById('stackedChartsContainer');
            if (!container) {
                showAlert('Charts container not found', 'danger');
                return;
            }

            // Check if html2canvas is available, if not load it
            if (typeof html2canvas === 'undefined') {
                await loadHtml2Canvas();
            }

            // Capture the container
            const canvas = await html2canvas(container, {
                backgroundColor: '#ffffff',
                scale: 2, // Higher quality
                logging: false,
                useCORS: true,
                allowTaint: true
            });

            // Convert to image and download
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `charts_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();

            showAlert('Charts saved as image!', 'success');
        } catch (error) {
            console.error('Error saving charts as image:', error);
            showAlert('Error saving image: ' + error.message, 'danger');
        }
    };

    /**
     * Load html2canvas library dynamically.
     */
    async function loadHtml2Canvas() {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
});
</script>
{% endblock %}