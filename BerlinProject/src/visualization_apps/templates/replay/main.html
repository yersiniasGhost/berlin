{% extends "base.html" %}

{% block title %}Replay Visualization{% endblock %}

{% block extra_head %}
<style>
    .indicator-card, .bar-card {
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        padding: 0;
        margin-bottom: 1rem;
        background: #f8f9fa;
        transition: all 0.3s;
    }

    .indicator-card:hover, .bar-card:hover {
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .indicator-card-header, .bar-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem;
        cursor: pointer;
        border-radius: 0.5rem 0.5rem 0 0;
        transition: background 0.3s;
    }

    .indicator-card-header:hover, .bar-card-header:hover {
        background: #e9ecef;
    }

    .indicator-card-title {
        font-weight: 600;
        color: #2c3e50;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .indicator-card-body, .bar-card-body {
        padding: 1rem;
        display: none;
        border-top: 1px solid #dee2e6;
    }

    .indicator-card-body.show, .bar-card-body.show {
        display: block;
    }

    .collapse-icon {
        transition: transform 0.3s;
        color: #6c757d;
    }

    .collapse-icon.expanded {
        transform: rotate(90deg);
    }

    .btn-remove {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 0.25rem 0.75rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.3s;
    }

    .btn-remove:hover {
        background: #c0392b;
    }

    /* Compact parameter inputs */
    .indicator-card-body .form-control,
    .indicator-card-body .form-select,
    .bar-card-body .form-control,
    .bar-card-body .form-select {
        max-width: 200px;
        font-size: 0.875rem;
    }

    .indicator-card-body .form-label,
    .bar-card-body .form-label {
        font-size: 0.875rem;
        margin-bottom: 0.25rem;
    }

    .indicator-card-body .row.g-2,
    .bar-card-body .row.g-2 {
        row-gap: 0.5rem !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h2 class="mb-4">
                <i class="fas fa-play-circle me-2"></i>Replay Visualization
            </h2>
        </div>
    </div>
    
    <!-- File Selector -->
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-body">
                    <div class="row align-items-center mb-3">
                        <div class="col-md-5">
                            <label for="monitorFileInput" class="form-label mb-0">
                                <i class="fas fa-file me-2"></i>Monitor Configuration File
                            </label>
                        </div>
                        <div class="col-md-7">
                            <input type="file" class="form-control" id="monitorFileInput" accept=".json">
                        </div>
                    </div>
                    <div class="row align-items-center mb-3">
                        <div class="col-md-5">
                            <label for="dataFileInput" class="form-label mb-0">
                                <i class="fas fa-database me-2"></i>Data Configuration File <span class="text-muted">(Optional)</span>
                            </label>
                        </div>
                        <div class="col-md-7">
                            <input type="file" class="form-control" id="dataFileInput" accept=".json">
                            <small class="text-muted">If not provided, defaults to: NVDA, 01/01/2024 - 02/28/2024</small>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-12 text-center">
                            <button class="btn btn-primary btn-lg" id="loadConfigsBtn" disabled>
                                <i class="fas fa-upload me-2"></i>Load Configurations
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Configuration Editor -->
    <div class="row" id="configEditor" style="display: none;">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="fas fa-edit me-2"></i>Edit Configuration
                    </h5>
                    <button class="btn btn-success" onclick="saveMonitorConfiguration()">
                        <i class="fas fa-save me-2"></i>Save Monitor Config
                    </button>
                </div>
                <div class="card-body">
                    <!-- Tabs -->
                    <ul class="nav nav-tabs mb-3" id="configTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="monitor-tab" data-bs-toggle="tab"
                                    data-bs-target="#monitor-pane" type="button" role="tab">
                                <i class="fas fa-info-circle me-2"></i>Monitor
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="indicators-tab" data-bs-toggle="tab"
                                    data-bs-target="#indicators-pane" type="button" role="tab">
                                <i class="fas fa-chart-line me-2"></i>Indicators
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="bars-tab" data-bs-toggle="tab"
                                    data-bs-target="#bars-pane" type="button" role="tab">
                                <i class="fas fa-bars me-2"></i>Bars
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="trade-executor-tab" data-bs-toggle="tab"
                                    data-bs-target="#trade-executor-pane" type="button" role="tab">
                                <i class="fas fa-exchange-alt me-2"></i>Trade Executor
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="data-config-tab" data-bs-toggle="tab"
                                    data-bs-target="#data-config-pane" type="button" role="tab">
                                <i class="fas fa-database me-2"></i>Data Config
                            </button>
                        </li>
                    </ul>

                    <!-- Tab Content -->
                    <div class="tab-content" id="configTabContent">
                        <!-- Monitor Tab -->
                        <div class="tab-pane fade show active" id="monitor-pane" role="tabpanel">
                            <div class="mb-3">
                                <h6>Basic Information</h6>
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <label for="monitorName" class="form-label">Name</label>
                                        <input type="text" class="form-control" id="monitorName" style="max-width: 300px;">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="monitorDescription" class="form-label">Description</label>
                                        <input type="text" class="form-control" id="monitorDescription" style="max-width: 300px;">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Indicators Tab -->
                        <div class="tab-pane fade" id="indicators-pane" role="tabpanel">
                            <div class="mb-3">
                                <button class="btn btn-success" id="addIndicatorBtn">
                                    <i class="fas fa-plus me-2"></i>Add Indicator
                                </button>
                            </div>
                            <div id="indicatorsContainer"></div>
                        </div>

                        <!-- Bars Tab -->
                        <div class="tab-pane fade" id="bars-pane" role="tabpanel">
                            <div class="mb-3">
                                <button class="btn btn-success" id="addBarBtn">
                                    <i class="fas fa-plus me-2"></i>Add Bar
                                </button>
                            </div>
                            <div id="barsContainer"></div>
                        </div>

                        <!-- Trade Executor Tab -->
                        <div class="tab-pane fade" id="trade-executor-pane" role="tabpanel">
                            <div class="mb-3">
                                <h6>Position Settings</h6>
                                <div class="row g-3">
                                    <div class="col-md-4">
                                        <label for="positionSize" class="form-label">Position Size</label>
                                        <input type="number" class="form-control" id="positionSize" step="0.01" style="max-width: 200px;">
                                    </div>
                                    <div class="col-md-4">
                                        <label for="stopLoss" class="form-label">Stop Loss %</label>
                                        <input type="number" class="form-control" id="stopLoss" step="0.001" style="max-width: 200px;">
                                    </div>
                                    <div class="col-md-4">
                                        <label for="takeProfit" class="form-label">Take Profit %</label>
                                        <input type="number" class="form-control" id="takeProfit" step="0.001" style="max-width: 200px;">
                                    </div>
                                </div>
                            </div>

                            <div class="mb-3">
                                <h6>Trailing Stop Loss</h6>
                                <div class="row g-3">
                                    <div class="col-md-4">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="trailingStopEnabled">
                                            <label class="form-check-label" for="trailingStopEnabled">
                                                Enable Trailing Stop
                                            </label>
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <label for="trailingDistance" class="form-label">Distance %</label>
                                        <input type="number" class="form-control" id="trailingDistance" step="0.001" style="max-width: 200px;">
                                    </div>
                                    <div class="col-md-4">
                                        <label for="trailingActivation" class="form-label">Activation %</label>
                                        <input type="number" class="form-control" id="trailingActivation" step="0.001" style="max-width: 200px;">
                                    </div>
                                </div>
                            </div>

                            <div class="mb-3">
                                <h6>Entry Conditions</h6>
                                <div id="enterLongContainer"></div>
                            </div>

                            <div class="mb-3">
                                <h6>Exit Conditions</h6>
                                <div id="exitLongContainer"></div>
                            </div>

                            <div class="mb-3">
                                <h6>Behavior</h6>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="ignoreBearSignals">
                                    <label class="form-check-label" for="ignoreBearSignals">
                                        Ignore Bear Signals
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- Data Config Tab -->
                        <div class="tab-pane fade" id="data-config-pane" role="tabpanel">
                            <div class="mb-3">
                                <h6>Data Configuration</h6>
                                <div class="row g-3">
                                    <div class="col-md-4">
                                        <label for="dataTicker" class="form-label">Ticker Symbol</label>
                                        <input type="text" class="form-control" id="dataTicker" placeholder="e.g., NVDA" style="max-width: 200px;">
                                    </div>
                                    <div class="col-md-4">
                                        <label for="dataStartDate" class="form-label">Start Date</label>
                                        <input type="date" class="form-control" id="dataStartDate" style="max-width: 200px;">
                                    </div>
                                    <div class="col-md-4">
                                        <label for="dataEndDate" class="form-label">End Date</label>
                                        <input type="date" class="form-control" id="dataEndDate" style="max-width: 200px;">
                                    </div>
                                    <div class="col-md-4">
                                        <div class="form-check mt-4">
                                            <input class="form-check-input" type="checkbox" id="dataExtendedHours" checked>
                                            <label class="form-check-label" for="dataExtendedHours">
                                                Include Extended Hours
                                            </label>
                                            <small class="form-text text-muted d-block">When unchecked, only uses data from 9:30 AM - 4:00 PM ET (regular market hours)</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Run Button -->
    <div class="row mb-4">
        <div class="col-12 text-center">
            <button type="button" class="btn btn-success btn-lg" id="runReplayBtn" disabled>
                <i class="fas fa-play me-2"></i>Run Replay Visualization
            </button>
        </div>
    </div>

    <!-- Results Section -->
    <div class="row" id="resultsSection" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-chart-area me-2"></i>Visualization Results
                    </h5>
                </div>
                <div class="card-body">
                    <!-- Strategy Overview -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <h6>Strategy Overview</h6>
                            <div class="row">
                                <div class="col-md-3">
                                    <strong>Strategy:</strong> <span id="strategyName">-</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Symbol:</strong> <span id="dataTicker">-</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Date Range:</strong> <span id="dateRange">-</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Total Trades:</strong> <span id="totalTrades">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Performance Metrics -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <h6>Performance Metrics</h6>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="totalPnL">-</div>
                                        <small class="text-muted">Total P&L</small>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="avgWin">-</div>
                                        <small class="text-muted">Avg Win</small>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="avgLoss">-</div>
                                        <small class="text-muted">Avg Loss</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Charts and Trade History Side by Side -->
                    <div class="row">
                        <!-- Charts Section (Left Half) -->
                        <div class="col-lg-6">
                            <!-- Stacked Charts Container with shared x-axis -->
                            <div id="stackedChartsContainer">
                                <!-- Chart Container -->
                                <div id="candlestickChart" style="height: 500px; margin-bottom: 5px;"></div>

                                <!-- P&L Chart -->
                                <div id="pnlChart" style="height: 300px; margin-bottom: 5px;"></div>

                                <!-- Bar Scores Analysis Chart -->
                                <div id="barScoresContainer" style="margin-top: 20px;">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <h6 class="mb-0">Bar Scores Analysis</h6>
                                        <small class="text-muted">Weighted indicator trigger combinations with entry/exit thresholds</small>
                                    </div>
                                    <div id="barScoresChart" style="height: 280px; margin-bottom: 5px;"></div>
                                </div>

                                <!-- Tabbed Indicator Charts Container -->
                                <div id="indicatorChartsContainer" style="margin-top: 20px;">
                                    <h6>Indicator Analysis</h6>
                                    <!-- Indicator tabs will be dynamically created here -->
                                    <ul class="nav nav-tabs" id="indicatorTabs" role="tablist"></ul>
                                    <div class="tab-content" id="indicatorTabContent" style="border: 1px solid #dee2e6; border-top: none; padding: 15px;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Trade History Section (Right Half) -->
                        <div class="col-lg-6">
                            <h6>Trade History</h6>
                            <div class="table-responsive" style="max-height: 800px; overflow-y: auto;">
                                <table class="table table-striped table-sm">
                                    <thead class="sticky-top bg-white">
                                        <tr>
                                            <th>Time</th>
                                            <th>Type</th>
                                            <th>Price</th>
                                            <th>Size</th>
                                            <th>P&L</th>
                                            <th>Cumulative P&L</th>
                                            <th>Signal</th>
                                            <th>Details</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tradeHistoryTable">
                                        <tr>
                                            <td colspan="8" class="text-center text-muted">No trades to display</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Trade Details Modal -->
<div class="modal fade" id="tradeDetailsModal" tabindex="-1" aria-labelledby="tradeDetailsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="tradeDetailsModalLabel">Trade Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="tradeDetailsContent">
                <!-- Content will be populated dynamically -->
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script src="{{ url_for('static', filename='js/talib-patterns.js') }}"></script>
<script src="{{ url_for('static', filename='js/config-utils.js') }}"></script>
<script src="{{ url_for('static', filename='js/replay-config.js') }}"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const runReplayBtn = document.getElementById('runReplayBtn');
    const resultsSection = document.getElementById('resultsSection');
    const configEditor = document.getElementById('configEditor');

    let charts = {};

    // Global state for indicator chart updates
    let globalChartData = {
        perAggregatorCandles: {},
        indicatorAggMapping: {},
        indicatorConfigs: [],
        trades: [],
        tradeDetails: {},  // Detailed trade info for popup (timestamp -> details dict)
        currentIndicator: null
    };

    // Default data configuration
    const DEFAULT_DATA_CONFIG = {
        ticker: "NVDA",
        start_date: "2024-01-01",
        end_date: "2024-02-28"
    };

    // Check if we received configs from optimizer via sessionStorage
    checkForOptimzerData();

    // Setup file input listeners to enable load button
    function checkFilesSelected() {
        const monitorFile = document.getElementById('monitorFileInput').files.length > 0;
        // Only monitor file is required - data file is optional
        document.getElementById('loadConfigsBtn').disabled = !monitorFile;
    }

    document.getElementById('monitorFileInput').addEventListener('change', checkFilesSelected);
    document.getElementById('dataFileInput').addEventListener('change', checkFilesSelected);

    // Load both configs at once
    document.getElementById('loadConfigsBtn').addEventListener('click', async function() {
        const monitorFileInput = document.getElementById('monitorFileInput');
        const dataFileInput = document.getElementById('dataFileInput');

        if (!monitorFileInput.files.length) return;

        try {
            // Load monitor config
            const monitorFile = monitorFileInput.files[0];
            const monitorText = await monitorFile.text();
            monitorConfig = JSON.parse(monitorText);

            // Load data config (optional - use defaults if not provided)
            if (dataFileInput.files.length > 0) {
                const dataFile = dataFileInput.files[0];
                const dataText = await dataFile.text();
                dataConfig = JSON.parse(dataText);
                showAlert('Configurations loaded successfully', 'success');
            } else {
                // Use default data config: NVDA, 2024-01-01 to 2024-02-28
                dataConfig = JSON.parse(JSON.stringify(DEFAULT_DATA_CONFIG));
                showAlert('Monitor configuration loaded. Using default data: NVDA, 01/01/2024 - 02/28/2024', 'info');
            }

            // Render configurations
            renderMonitorConfiguration();
            renderDataConfiguration();

            // Show editor and enable run button
            configEditor.style.display = 'block';
            runReplayBtn.disabled = false;
        } catch (error) {
            alert('Error loading configurations: ' + error.message);
        }
    });

    // Run replay visualization
    runReplayBtn.addEventListener('click', async function() {
        if (!monitorConfig || !dataConfig) {
            alert('Please load both monitor and data configurations first');
            return;
        }

        // Collect updated config from the editor
        collectMonitorConfigData();
        collectDataConfigData();

        try {
            this.disabled = true;
            this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Running Replay...';

            const response = await fetch('/replay/api/run_visualization', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    monitor_config: monitorConfig,
                    data_config: dataConfig
                })
            });

            const result = await response.json();

            if (result.success) {
                displayResults(result.data);
                resultsSection.style.display = 'block';
            } else {
                throw new Error(result.error || 'Visualization failed');
            }

        } catch (error) {
            alert(`Failed to run replay: ${error.message}`);
        } finally {
            this.disabled = false;
            this.innerHTML = '<i class="fas fa-play me-2"></i>Run Replay Visualization';
        }
    });
    
    function displayResults(data) {
        // Store data globally for tab change updates
        globalChartData.perAggregatorCandles = data.per_aggregator_candles || {};
        globalChartData.indicatorAggMapping = data.indicator_agg_mapping || {};
        globalChartData.indicatorConfigs = data.indicators || [];
        globalChartData.trades = data.trades || [];
        globalChartData.tradeDetails = data.trade_details || {};  // Detailed trade info for popup
        globalChartData.primaryCandlestickData = data.candlestick_data;

        // Build name to agg_config mapping from indicator configs
        globalChartData.nameToAggConfig = {};
        globalChartData.indicatorConfigs.forEach(config => {
            globalChartData.nameToAggConfig[config.name] = config.agg_config || '1m-normal';
        });

        // Update strategy overview
        document.getElementById('strategyName').textContent = data.monitor_config?.name || 'Unknown';
        document.getElementById('dataTicker').textContent = data.data_config?.ticker || 'Unknown';
        document.getElementById('dateRange').textContent = `${data.data_config?.start_date || 'Unknown'} to ${data.data_config?.end_date || 'Unknown'}`;
        document.getElementById('totalTrades').textContent = data.trades?.length || 0;

        // Calculate and display metrics
        if (data.trades && data.trades.length > 0) {
            calculateMetrics(data.trades);
        }

        // Create charts
        if (data.candlestick_data) {
            createCandlestickChart(data.candlestick_data, data.trades);
        }
        
        if (data.pnl_data && data.trades && data.candlestick_data) {
            createPnLChart(data.pnl_data, data.trades, data.candlestick_data);
        }

        // Create bar scores chart showing weighted indicator trigger combinations
        if (data.bar_scores_history && data.bar_scores_history.length > 0) {
            createBarScoresChart(
                data.bar_scores_history,
                data.bars_config || {},
                data.entry_conditions || [],
                data.exit_conditions || []
            );
        }

        // Create indicator charts (raw values + triggers)
        console.log('ðŸ” Indicator charts condition check:');
        console.log('  component_history:', !!data.component_history);
        console.log('  raw_indicator_history:', !!data.raw_indicator_history);
        console.log('  indicator_history:', !!data.indicator_history);
        console.log('  candlestick_data:', !!data.candlestick_data);
        console.log('  class_to_layout:', data.class_to_layout, 'keys:', Object.keys(data.class_to_layout || {}).length);
        console.log('  indicators:', data.indicators, 'count:', data.indicators?.length || 0);

        if (data.component_history && data.raw_indicator_history && data.indicator_history && data.candlestick_data && data.indicators && data.indicators.length > 0) {
            const indicatorConfigs = data.indicators;
            console.log('âœ… Creating indicator charts with configs:', indicatorConfigs);
            console.log('ðŸ“Š Per-aggregator candles available:', Object.keys(data.per_aggregator_candles || {}));
            console.log('ðŸ“Š Indicator-aggregator mapping:', data.indicator_agg_mapping || {});
            createIndicatorCharts(
                data.component_history,
                data.raw_indicator_history,
                data.indicator_history,
                data.candlestick_data,
                indicatorConfigs,
                data.class_to_layout || {},
                data.per_aggregator_candles || {},
                data.indicator_agg_mapping || {}
            );
        } else {
            console.warn('âš ï¸ Skipping indicator charts - missing data or indicators');
        }

        // Populate trade history
        populateTradeHistory(data.trades);
    }
    
    function calculateMetrics(trades) {
        const totalTrades = trades.length;
        let winningTrades = 0;
        let losingTrades = 0;
        let totalWinPnL = 0;
        let totalLossPnL = 0;
        let cumulativePnL = 0;
        
        trades.forEach(trade => {
            if (trade.pnl > 0) {
                winningTrades++;
                totalWinPnL += trade.pnl;
            } else if (trade.pnl < 0) {
                losingTrades++;
                totalLossPnL += Math.abs(trade.pnl);
            }
            
            cumulativePnL += trade.pnl;
        });
        
        const avgWin = winningTrades > 0 ? totalWinPnL / winningTrades : 0;
        const avgLoss = losingTrades > 0 ? totalLossPnL / losingTrades : 0;
        
        // Update UI
        document.getElementById('totalPnL').textContent = `${cumulativePnL.toFixed(2)}%`;
        document.getElementById('avgWin').textContent = `${avgWin.toFixed(2)}%`;
        document.getElementById('avgLoss').textContent = `${avgLoss.toFixed(2)}%`;
        
        // Color coding
        const totalPnLElement = document.getElementById('totalPnL');
        totalPnLElement.className = `h5 mb-0 ${cumulativePnL >= 0 ? 'text-success' : 'text-danger'}`;
    }
    
    function createCandlestickChart(candlestickData, trades) {
        // Prepare trade bands instead of triangular markers
        const chartConfig = {
            chart: {
                height: 500,
                zoomType: 'x',
                panKey: 'shift',
                panning: {
                    enabled: true,
                    type: 'x'
                },
                marginBottom: 10 // Reduce space for x-axis since labels are hidden
            },
            title: { text: 'Price Chart with Trade Background Shading' },
            xAxis: {
                type: 'datetime',
                ordinal: true, // Keep ordinal to remove gaps in candlestick chart
                breaks: [], // Clear any default breaks
                crosshair: true,
                labels: {
                    enabled: false // Hide x-axis labels (shown only on P&L chart)
                },
                lineWidth: 0,
                tickWidth: 0,
                plotBands: [] // Will be populated with trade bands
            },
            yAxis: { 
                title: { text: 'Price' },
                crosshair: true
            },
            series: [
                {
                    name: 'Price',
                    data: candlestickData,
                    type: 'candlestick',
                    color: '#dc3545',
                    upColor: '#28a745'
                }
            ],
            credits: { enabled: false }
        };
        
        if (charts.candlestick) {
            charts.candlestick.destroy();
        }
        charts.candlestick = Highcharts.chart('candlestickChart', chartConfig);
        
        // Clear any existing plot bands before adding new ones
        if (charts.candlestick.xAxis[0].plotLinesAndBands) {
            charts.candlestick.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                if (band.options.className && band.options.className.includes('trade-band')) {
                    band.destroy();
                }
            });
        }

        // Add background shading bands for trades
        addTradeBandsToChart(charts.candlestick, trades);

        // Enable synchronization for candlestick chart
        enableChartSynchronization(charts.candlestick);
    }

    /**
     * Adds trade background shading bands to a chart.
     * Reusable helper for both initial creation and updates.
     */
    function addTradeBandsToChart(chart, trades) {
        if (!chart || !trades || trades.length === 0) return;

        // Clear existing trade bands first
        if (chart.xAxis[0].plotLinesAndBands) {
            chart.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                if (band.options.className && band.options.className.includes('trade-band')) {
                    band.destroy();
                }
            });
        }

        // Group trades by pairs (buy followed by sell)
        const buyTrades = trades.filter(t => t.type === 'buy').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        const sellTrades = trades.filter(t => t.type === 'sell').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        // Create trade pairs and add background bands
        let buyIndex = 0, sellIndex = 0;
        let tradeCount = 0;

        while (buyIndex < buyTrades.length && sellIndex < sellTrades.length) {
            const buyTrade = buyTrades[buyIndex];
            const sellTrade = sellTrades[sellIndex];

            if (new Date(buyTrade.timestamp) < new Date(sellTrade.timestamp)) {
                // Calculate P&L for this trade pair
                const entryPrice = buyTrade.price;
                const exitPrice = sellTrade.price;
                const pnl = ((exitPrice - entryPrice) / entryPrice) * 100;

                // Use the actual P&L from trade data if available
                const actualPnl = sellTrade.pnl || pnl;
                const isActualProfit = actualPnl > 0;

                const bandColor = isActualProfit ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)';

                chart.xAxis[0].addPlotBand({
                    from: new Date(buyTrade.timestamp).getTime(),
                    to: new Date(sellTrade.timestamp).getTime(),
                    color: bandColor,
                    className: `trade-band trade-${tradeCount}`,
                    id: `trade-band-${tradeCount}`,
                    zIndex: 0, // Behind the candlesticks
                    label: {
                        text: `${isActualProfit ? '+' : ''}${actualPnl.toFixed(2)}%`,
                        align: 'center',
                        verticalAlign: 'middle',
                        style: {
                            color: isActualProfit ? '#28a745' : '#dc3545',
                            fontWeight: 'bold',
                            fontSize: '10px',
                            backgroundColor: 'rgba(255, 255, 255, 0.8)',
                            padding: '2px 4px',
                            borderRadius: '3px'
                        }
                    }
                });

                buyIndex++;
                sellIndex++;
                tradeCount++;
            } else {
                sellIndex++;
            }
        }
    }
    
    function createPnLChart(pnlData, trades, candlestickData) {
        // Build P&L data with unrealized gains during open positions
        let adjustedPnlData = [];

        // Get time range from candlestick data
        const candlestickStart = candlestickData[0][0]; // First candlestick timestamp
        const candlestickEnd = candlestickData[candlestickData.length - 1][0]; // Last candlestick timestamp

        if (!trades || trades.length === 0) {
            // If no trades, just show flat line at 0
            adjustedPnlData.push([candlestickStart, 0]);
            adjustedPnlData.push([candlestickEnd, 0]);
        } else {
            // Sort trades by timestamp
            const sortedTrades = [...trades].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const buyTrades = sortedTrades.filter(t => t.type === 'buy');
            const sellTrades = sortedTrades.filter(t => t.type === 'sell');

            // Create a map of candlestick data for quick lookup
            const candlestickMap = new Map();
            candlestickData.forEach(candle => {
                candlestickMap.set(candle[0], candle[4]); // timestamp -> close price
            });

            let cumulativeRealizedPnL = 0;
            let currentPosition = null; // {entryPrice, entryTime, buyIndex}
            let buyIndex = 0;
            let sellIndex = 0;

            // Process each candlestick chronologically
            candlestickData.forEach((candle, idx) => {
                const timestamp = candle[0];
                const closePrice = candle[4];

                // Check if there's a buy trade at this timestamp
                while (buyIndex < buyTrades.length && new Date(buyTrades[buyIndex].timestamp).getTime() <= timestamp) {
                    if (!currentPosition) {
                        currentPosition = {
                            entryPrice: buyTrades[buyIndex].price,
                            entryTime: new Date(buyTrades[buyIndex].timestamp).getTime(),
                            buyIndex: buyIndex
                        };
                        console.log(`ðŸ“Š Position opened at ${new Date(timestamp)}, entry price: ${currentPosition.entryPrice}`);
                    }
                    buyIndex++;
                }

                // Check if there's a sell trade at this timestamp
                while (sellIndex < sellTrades.length && new Date(sellTrades[sellIndex].timestamp).getTime() <= timestamp) {
                    if (currentPosition) {
                        // Close position and add realized P&L
                        cumulativeRealizedPnL += (sellTrades[sellIndex].pnl || 0);
                        console.log(`ðŸ“Š Position closed at ${new Date(timestamp)}, realized P&L: ${sellTrades[sellIndex].pnl}, cumulative: ${cumulativeRealizedPnL}`);
                        currentPosition = null;
                    }
                    sellIndex++;
                }

                // Only add data points when in a position
                if (currentPosition) {
                    // Calculate current P&L (realized + unrealized)
                    const unrealizedPnL = ((closePrice - currentPosition.entryPrice) / currentPosition.entryPrice) * 100;
                    const currentPnL = cumulativeRealizedPnL + unrealizedPnL;
                    adjustedPnlData.push([timestamp, currentPnL]);
                } else {
                    // When no position, only add points at trade exits to maintain flat line
                    if (sellIndex > 0 && adjustedPnlData.length > 0) {
                        // Check if we just closed a position
                        const lastDataPoint = adjustedPnlData[adjustedPnlData.length - 1];
                        if (lastDataPoint[0] < timestamp) {
                            // Add a point to extend the flat line
                            adjustedPnlData.push([timestamp, cumulativeRealizedPnL]);
                        }
                    } else if (adjustedPnlData.length === 0) {
                        // Add initial point at 0 if we haven't started yet
                        adjustedPnlData.push([timestamp, 0]);
                    }
                }
            });
        }

        console.log(`ðŸ“ˆ P&L Chart data points: ${adjustedPnlData.length}, Range: ${new Date(candlestickStart)} to ${new Date(candlestickEnd)}`);

        const chartConfig = {
            chart: {
                type: 'line',
                height: 300,
                zoomType: 'x',
                panKey: 'shift',
                panning: {
                    enabled: true,
                    type: 'x'
                },
                marginBottom: 60 // Extra space for x-axis labels
            },
            title: { text: 'Cumulative P&L Evolution' },
            xAxis: {
                type: 'datetime',
                ordinal: true, // Match candlestick chart - removes gaps for weekends/after hours
                breaks: [],
                crosshair: true,
                labels: {
                    enabled: true // Show x-axis labels (this is the bottom chart)
                },
                lineWidth: 1,
                tickWidth: 1
            },
            yAxis: { 
                title: { text: 'Cumulative P&L (%)' },
                plotLines: [{
                    value: 0,
                    color: '#999',
                    width: 1,
                    dashStyle: 'dash'
                }]
            },
            series: [{
                name: 'Cumulative P&L',
                data: adjustedPnlData,
                color: '#007bff',
                lineWidth: 2
                // Removed step line - now shows continuous unrealized P&L
            }],
            credits: { enabled: false }
        };
        
        if (charts.pnl) {
            charts.pnl.destroy();
        }
        charts.pnl = Highcharts.chart('pnlChart', chartConfig);
        
        // Enable synchronization for P&L chart
        enableChartSynchronization(charts.pnl);
    }

    /**
     * Create bar scores chart showing weighted indicator trigger combinations.
     * Each bar is a line series, with threshold lines for entry/exit conditions.
     *
     * @param {Array} barScoresHistory - Array of {timestamp, scores: {bar_name: score}}
     * @param {Object} barsConfig - Bar definitions with weights and types
     * @param {Array} entryConditions - Entry conditions with thresholds
     * @param {Array} exitConditions - Exit conditions with thresholds
     */
    function createBarScoresChart(barScoresHistory, barsConfig, entryConditions, exitConditions) {
        console.log('ðŸ“Š Creating bar scores chart');
        console.log('   Bar scores history entries:', barScoresHistory.length);
        console.log('   Bars config:', Object.keys(barsConfig));
        console.log('   Entry conditions:', entryConditions);
        console.log('   Exit conditions:', exitConditions);

        if (!barScoresHistory || barScoresHistory.length === 0) {
            console.warn('âš ï¸ No bar scores history data');
            return;
        }

        // Get all unique bar names from the first entry
        const barNames = Object.keys(barScoresHistory[0]?.scores || {});
        if (barNames.length === 0) {
            console.warn('âš ï¸ No bar names found in scores history');
            return;
        }

        // Build threshold lookup from entry/exit conditions
        const thresholds = {};
        entryConditions.forEach(cond => {
            if (cond.name) thresholds[cond.name] = { value: cond.threshold || 0.5, type: 'entry' };
        });
        exitConditions.forEach(cond => {
            if (cond.name) thresholds[cond.name] = { value: cond.threshold || 0.5, type: 'exit' };
        });

        // Color palette for bars (bull bars in green tones, bear bars in red tones)
        const bullColors = ['#4CAF50', '#8BC34A', '#CDDC39', '#00BCD4'];
        const bearColors = ['#f44336', '#E91E63', '#FF5722', '#FF9800'];
        const defaultColors = ['#2196F3', '#9C27B0', '#607D8B', '#795548'];

        // Create series for each bar
        const series = [];
        let bullIdx = 0, bearIdx = 0, defaultIdx = 0;

        barNames.forEach(barName => {
            // Extract data for this bar
            const barData = barScoresHistory.map(entry => [
                entry.timestamp,
                entry.scores[barName] || 0
            ]);

            // Determine bar type and color
            const barConfig = barsConfig[barName] || {};
            const barType = barConfig.type || 'unknown';
            let color;

            if (barType === 'bull') {
                color = bullColors[bullIdx % bullColors.length];
                bullIdx++;
            } else if (barType === 'bear') {
                color = bearColors[bearIdx % bearColors.length];
                bearIdx++;
            } else {
                color = defaultColors[defaultIdx % defaultColors.length];
                defaultIdx++;
            }

            series.push({
                name: barName,
                data: barData,
                color: color,
                lineWidth: 2,
                marker: { enabled: false },
                tooltip: {
                    valueDecimals: 3
                }
            });
        });

        // Create threshold plot lines
        const plotLines = [];
        Object.entries(thresholds).forEach(([barName, thresh]) => {
            plotLines.push({
                value: thresh.value,
                color: thresh.type === 'entry' ? '#28a745' : '#dc3545',
                width: 1,
                dashStyle: 'Dash',
                label: {
                    text: `${barName}: ${thresh.value}`,
                    align: 'right',
                    style: {
                        fontSize: '9px',
                        color: thresh.type === 'entry' ? '#28a745' : '#dc3545'
                    }
                },
                zIndex: 3
            });
        });

        const chartConfig = {
            chart: {
                type: 'line',
                height: 280,
                zoomType: 'x',
                panKey: 'shift',
                panning: { enabled: true, type: 'x' },
                marginBottom: 10
            },
            title: { text: 'Bar Scores (Weighted Indicator Triggers)' },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                crosshair: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: {
                title: { text: 'Score' },
                min: 0,
                max: 1.1,
                crosshair: true,
                plotLines: plotLines,
                gridLineWidth: 1,
                gridLineColor: '#e6e6e6'
            },
            legend: {
                enabled: true,
                align: 'right',
                verticalAlign: 'top',
                layout: 'horizontal',
                itemStyle: { fontSize: '10px' }
            },
            plotOptions: {
                line: {
                    lineWidth: 2,
                    marker: { enabled: false },
                    states: { hover: { lineWidth: 3 } }
                }
            },
            series: series,
            tooltip: {
                shared: true,
                crosshairs: true,
                formatter: function() {
                    let s = '<b>' + Highcharts.dateFormat('%Y-%m-%d %H:%M', this.x) + '</b><br/>';
                    this.points.forEach(point => {
                        const thresh = thresholds[point.series.name];
                        const threshStr = thresh ? ` (thresh: ${thresh.value})` : '';
                        const triggered = thresh && point.y >= thresh.value ? ' âœ“' : '';
                        s += `<span style="color:${point.color}">â—</span> ${point.series.name}: <b>${point.y.toFixed(3)}</b>${threshStr}${triggered}<br/>`;
                    });
                    return s;
                }
            },
            credits: { enabled: false }
        };

        // Destroy existing chart if present
        if (charts.barScores) {
            charts.barScores.destroy();
        }

        charts.barScores = Highcharts.chart('barScoresChart', chartConfig);
        enableChartSynchronization(charts.barScores);

        console.log(`âœ… Bar scores chart created with ${barNames.length} bars`);
    }

    function createIndicatorCharts(componentHistory, rawIndicatorHistory, indicatorHistory, candlestickData, indicatorConfigs, classToLayout, perAggregatorCandles, indicatorAggMapping) {
        console.log('ðŸ“Š Creating indicator charts');
        console.log('Component history keys:', Object.keys(componentHistory));
        console.log('Raw indicator history keys:', Object.keys(rawIndicatorHistory));
        console.log('Class to layout:', classToLayout);
        console.log('Per-aggregator candles:', Object.keys(perAggregatorCandles));
        console.log('Indicator-aggregator mapping:', indicatorAggMapping);

        // Get all unique indicator names from raw_indicator_history
        const indicatorNames = Object.keys(rawIndicatorHistory);
        if (indicatorNames.length === 0) {
            console.log('âš ï¸ No indicators found');
            return;
        }

        // Build a map of instance name to class name and agg_config from indicator configs
        const nameToClass = {};
        const nameToAggConfig = {};
        indicatorConfigs.forEach(config => {
            nameToClass[config.name] = config.indicator_class;
            nameToAggConfig[config.name] = config.agg_config || '1m-normal';
        });

        const tabsContainer = document.getElementById('indicatorTabs');
        const contentContainer = document.getElementById('indicatorTabContent');
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = '';

        // Create a tab for each indicator
        indicatorNames.forEach((indicatorName, index) => {
            const isActive = index === 0;
            const tabId = `indicator-tab-${index}`;
            const contentId = `indicator-content-${index}`;

            // Create tab button with indicator name data attribute
            const tabButton = document.createElement('li');
            tabButton.className = 'nav-item';
            tabButton.innerHTML = `
                <button class="nav-link ${isActive ? 'active' : ''}"
                        id="${tabId}"
                        data-bs-toggle="tab"
                        data-bs-target="#${contentId}"
                        data-indicator-name="${indicatorName}"
                        type="button"
                        role="tab">
                    ${indicatorName}
                </button>
            `;
            tabsContainer.appendChild(tabButton);

            // Add click listener to update main candlestick chart when tab is selected
            const buttonElement = tabButton.querySelector('button');
            buttonElement.addEventListener('click', () => {
                updateCandlestickChartForIndicator(indicatorName);
            });

            // Create tab content
            const tabContent = document.createElement('div');
            tabContent.className = `tab-pane fade ${isActive ? 'show active' : ''}`;
            tabContent.id = contentId;
            tabContent.role = 'tabpanel';

            // Add chart containers for raw values and triggers
            const rawChartId = `rawChart_${indicatorName.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const triggerChartId = `triggerChart_${indicatorName.replace(/[^a-zA-Z0-9]/g, '_')}`;

            tabContent.innerHTML = `
                <div id="${rawChartId}" style="height: 300px; margin-bottom: 10px;"></div>
                <div id="${triggerChartId}" style="height: 200px;"></div>
            `;
            contentContainer.appendChild(tabContent);

            // Create charts after a short delay to ensure DOM is ready
            setTimeout(() => {
                const indicatorClass = nameToClass[indicatorName];
                const aggConfig = nameToAggConfig[indicatorName] || indicatorAggMapping[indicatorName] || '1m-normal';

                // Get the correct candlestick data for this indicator's timeframe
                let indicatorCandles = perAggregatorCandles[aggConfig];
                if (!indicatorCandles) {
                    console.warn(`âš ï¸ No candles found for aggregator '${aggConfig}', falling back to primary candlestick data`);
                    indicatorCandles = candlestickData;
                } else {
                    console.log(`ðŸ“ˆ Using ${aggConfig} candles (${indicatorCandles.length} points) for ${indicatorName}`);
                }

                const rawChart = createRawIndicatorChart(indicatorName, indicatorClass, componentHistory, indicatorCandles, rawChartId, classToLayout);
                const triggerChart = createTriggerChart(indicatorName, rawIndicatorHistory, indicatorHistory, triggerChartId);

                // Enable synchronization with all other charts
                if (rawChart) {
                    enableChartSynchronization(rawChart);
                }
                if (triggerChart) {
                    enableChartSynchronization(triggerChart);
                }
            }, 100);
        });

        // Trigger initial candlestick chart update for the first indicator
        if (indicatorNames.length > 0) {
            // Wait for charts to be created, then update candlestick for first indicator
            setTimeout(() => {
                updateCandlestickChartForIndicator(indicatorNames[0]);
                console.log(`ðŸ“Š Initial candlestick chart updated for first indicator: ${indicatorNames[0]}`);
            }, 200);
        }
    }

    // Helper function to find component keys by pattern matching
    function findComponentKeys(indicatorName, componentHistory, componentNames) {
        const foundKeys = {};

        for (const componentName of componentNames) {
            // Look for keys that end with the component name
            // Pattern: {indicatorName}_.._{componentName}
            const matchingKey = Object.keys(componentHistory).find(key => {
                return key.startsWith(indicatorName + '_') && key.endsWith('_' + componentName);
            });

            if (matchingKey) {
                foundKeys[componentName] = matchingKey;
            }
        }

        return foundKeys;
    }

    function createRawIndicatorChart(indicatorName, indicatorClass, componentHistory, candlestickData, chartId, classToLayout) {
        // Get layout type from the indicator CLASS
        const layoutType = (classToLayout && classToLayout[indicatorClass]) || 'overlay';

        console.log(`ðŸ“ˆ Creating chart for instance '${indicatorName}' (class: ${indicatorClass}) with layout: '${layoutType}'`);

        // Route to appropriate chart type based on layout_type from indicator class
        if (layoutType === 'stacked') {
            return createMACDChart(indicatorName, componentHistory, chartId);
        } else if (layoutType === 'overlay') {
            return createSMAChart(indicatorName, componentHistory, candlestickData, chartId);
        } else {
            // Default: line chart for unknown layout types
            return createGenericIndicatorChart(indicatorName, componentHistory, chartId);
        }
    }

    function createMACDChart(indicatorName, componentHistory, chartId) {
        // Find MACD components by pattern matching
        // Keys will be like: macd1m_macd_histogram_crossover_macd, macd1m_macd_histogram_crossover_signal, etc.
        console.log(`\nðŸ” [MACD CHART] Looking for components for '${indicatorName}'`);
        console.log(`   Available keys in componentHistory:`, Object.keys(componentHistory));

        const componentKeys = findComponentKeys(indicatorName, componentHistory, ['macd', 'signal', 'histogram']);

        const series = [];
        if (componentKeys.macd && componentHistory[componentKeys.macd]) {
            series.push({ name: 'MACD Line', data: componentHistory[componentKeys.macd], color: '#2962FF', lineWidth: 2, marker: { enabled: false } });
        }
        if (componentKeys.signal && componentHistory[componentKeys.signal]) {
            series.push({ name: 'Signal Line', data: componentHistory[componentKeys.signal], color: '#FF6D00', lineWidth: 2, marker: { enabled: false } });
        }
        if (componentKeys.histogram && componentHistory[componentKeys.histogram]) {
            series.push({
                name: 'Histogram',
                data: componentHistory[componentKeys.histogram],
                type: 'column',
                color: '#00897B'
            });
        }

        if (series.length === 0) {
            console.warn(`âš ï¸ No MACD components found for '${indicatorName}'.`);
        }

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Value' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createSMAChart(indicatorName, componentHistory, candlestickData, chartId) {
        // Find SMA component by pattern matching
        // Keys will be like: sma1m_sma, sma_crossover_1m_sma, etc.
        const componentKeys = findComponentKeys(indicatorName, componentHistory, ['sma']);

        const series = [
            {
                name: 'Price',
                data: candlestickData,
                type: 'candlestick',
                color: '#dc3545',
                upColor: '#28a745'
            }
        ];

        if (componentKeys.sma && componentHistory[componentKeys.sma]) {
            series.push({
                name: indicatorName,
                data: componentHistory[componentKeys.sma],
                type: 'line',
                color: '#2962FF',
                lineWidth: 2,
                marker: { enabled: false }
            });
        } else {
            console.warn(`âš ï¸ No SMA component found for '${indicatorName}'.`);
        }

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values (with Price)`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Price' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createGenericIndicatorChart(indicatorName, componentHistory, chartId) {
        // For unknown indicator types, just plot any matching components
        const matchingKeys = Object.keys(componentHistory).filter(k =>
            k.toLowerCase().includes(indicatorName.toLowerCase())
        );

        const series = matchingKeys.map(key => ({
            name: key,
            data: componentHistory[key],
            lineWidth: 2,
            marker: { enabled: false }
        }));

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Value' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createTriggerChart(indicatorName, rawIndicatorHistory, indicatorHistory, chartId) {
        const series = [];

        // Add time-decayed trigger values (1, 0.9, 0.8, etc.)
        if (indicatorHistory[indicatorName]) {
            series.push({
                name: 'Trigger with Decay',
                data: indicatorHistory[indicatorName],
                color: '#9C27B0',
                lineWidth: 2,
                marker: { enabled: false }
            });
        }

        const chartConfig = {
            chart: { height: 200, zoomType: 'x' },
            title: { text: `${indicatorName} - Trigger Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: true }
            },
            yAxis: {
                title: { text: 'Trigger Value' },
                min: 0,
                max: 1.1,
                plotLines: [{
                    value: 1,
                    color: '#999',
                    width: 1,
                    dashStyle: 'dash'
                }]
            },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`trigger_${indicatorName}`] = chart;
        return chart;
    }

    function enableChartSynchronization(chart) {
        // Enhanced synchronization for stacked charts including scroll zoom
        chart.update({
            chart: {
                events: {
                    selection: function(event) {
                        if (event.xAxis) {
                            const min = event.xAxis[0].min;
                            const max = event.xAxis[0].max;
                            syncAllCharts(min, max, chart);
                        }
                    },
                    load: function() {
                        // Add mouse wheel zoom synchronization and pan support
                        const chartContainer = this.container;

                        // Mouse wheel zoom (works with or without Ctrl/Cmd key)
                        chartContainer.addEventListener('wheel', function(e) {
                            // Only zoom on wheel over chart area, not the entire page
                            if (e.target.closest('.highcharts-container')) {
                                e.preventDefault();
                                e.stopPropagation();

                                // Prevent sync loop
                                if (window.syncInProgress) return;

                                const chart = chartContainer.chart || chartContainer.hcChart || this;
                                if (chart && chart.xAxis && chart.xAxis[0]) {
                                    const xAxis = chart.xAxis[0];
                                    const currentMin = xAxis.min;
                                    const currentMax = xAxis.max;
                                    const range = currentMax - currentMin;

                                    // Smaller zoom factor for smoother zoom
                                    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                                    const newRange = range * zoomFactor;

                                    // Get mouse position relative to chart for zoom center
                                    const rect = chartContainer.getBoundingClientRect();
                                    const mouseX = e.clientX - rect.left;
                                    const plotLeft = chart.plotLeft || 60;
                                    const plotWidth = chart.plotWidth || (rect.width - 120);

                                    // Calculate zoom center based on mouse position
                                    let centerRatio = 0.5; // Default center
                                    if (mouseX >= plotLeft && mouseX <= plotLeft + plotWidth) {
                                        centerRatio = (mouseX - plotLeft) / plotWidth;
                                    }

                                    const center = currentMin + (range * centerRatio);
                                    const newMin = center - (newRange * centerRatio);
                                    const newMax = center + (newRange * (1 - centerRatio));

                                    // Ensure we don't zoom beyond data limits and maintain minimum range
                                    const dataMin = xAxis.getExtremes().dataMin || currentMin;
                                    const dataMax = xAxis.getExtremes().dataMax || currentMax;
                                    const minRange = (dataMax - dataMin) / 1000; // Minimum zoom level

                                    if (newMin >= dataMin && newMax <= dataMax && newRange > minRange) {
                                        console.log('Wheel zoom:', {newMin, newMax, range: newRange});
                                        syncAllCharts(newMin, newMax, chart);
                                    }
                                }
                            }
                        }, { passive: false });

                        // Store reference for cleanup
                        this.syncContainer = chartContainer;
                    }
                }
            },
            xAxis: {
                events: {
                    afterSetExtremes: function(e) {
                        // Only sync if this was a user action (including mouse wheel)
                        if (e.trigger === 'zoom' || e.trigger === 'pan' || e.trigger === 'selection' || e.trigger === 'mousewheel') {
                            syncAllCharts(e.min, e.max, chart);
                        }
                    }
                }
            }
        });
    }

    function syncAllCharts(min, max, sourceChart) {
        // Prevent infinite loops by temporarily disabling sync
        if (window.syncInProgress) return;
        window.syncInProgress = true;

        console.log('Syncing all charts:', {min, max, sourceChart: sourceChart.renderTo?.id || 'unknown'});

        try {
            let syncedCount = 0;
            Object.values(charts).forEach(chart => {
                if (chart !== sourceChart && chart.xAxis && chart.xAxis[0]) {
                    // Use setExtremes with redraw true for immediate visual feedback
                    chart.xAxis[0].setExtremes(min, max, true, false);
                    syncedCount++;
                }
            });
            console.log(`Synced ${syncedCount} charts`);
        } finally {
            // Re-enable sync after a short delay
            setTimeout(() => {
                window.syncInProgress = false;
            }, 50); // Shorter delay for more responsive sync
        }
    }
    
    function populateTradeHistory(trades) {
        const tableBody = document.getElementById('tradeHistoryTable');

        if (!trades || trades.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="8" class="text-center text-muted">No trades to display</td></tr>';
            return;
        }

        let cumulativePnL = 0;
        const rows = trades.map(trade => {
            cumulativePnL += trade.pnl || 0;
            const pnlClass = (trade.pnl || 0) > 0 ? 'text-success' : ((trade.pnl || 0) < 0 ? 'text-danger' : '');
            const cumPnLClass = cumulativePnL >= 0 ? 'text-success' : 'text-danger';

            // Format date and time
            const tradeDate = new Date(trade.timestamp);
            const dateTimeStr = tradeDate.toLocaleString('en-US', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });

            return `
                <tr>
                    <td class="small">${dateTimeStr}</td>
                    <td><span class="badge bg-${trade.type === 'buy' ? 'success' : 'danger'}">${trade.type}</span></td>
                    <td>$${(trade.price || 0).toFixed(2)}</td>
                    <td>${trade.size || 0}</td>
                    <td class="${pnlClass}">${(trade.pnl || 0).toFixed(2)}%</td>
                    <td class="${cumPnLClass}">${cumulativePnL.toFixed(2)}%</td>
                    <td class="small">${trade.reason || '-'}</td>
                    <td><button class="btn btn-sm btn-outline-primary" onclick="showTradeDetails(${trade.timestamp})">Details</button></td>
                </tr>
            `;
        }).join('');

        tableBody.innerHTML = rows;
    }

    // Show trade details popup
    window.showTradeDetails = function(timestamp) {
        const details = globalChartData.tradeDetails[timestamp];
        if (!details) {
            alert('No detailed information available for this trade.');
            return;
        }

        // Format the details for the modal
        let content = `<div class="trade-details-content">`;
        content += `<h5 class="mb-3">${details.action || 'Trade'}</h5>`;
        content += `<p><strong>Date/Time:</strong> ${details.datetime || 'N/A'}</p>`;

        if (details.type === 'entry') {
            content += `<p><strong>Entry Price:</strong> $${(details.price || 0).toFixed(2)}</p>`;
            content += `<p><strong>Position Size:</strong> ${details.position_size || 'N/A'}</p>`;

            // Trigger info
            if (details.trigger_info) {
                content += `<hr><h6>Trigger Reason</h6>`;
                content += `<p><strong>Trigger Bar:</strong> ${details.trigger_info.bar_name || 'N/A'}</p>`;
                content += `<p><strong>Bar Score:</strong> ${(details.trigger_info.bar_score || 0).toFixed(4)} >= ${(details.trigger_info.threshold || 0).toFixed(4)}</p>`;
            }

            // Exit targets
            content += `<hr><h6>Exit Targets</h6>`;
            content += `<p><strong>Stop Loss:</strong> $${(details.stop_loss || 0).toFixed(2)} (${((details.stop_loss_pct || 0) * 100).toFixed(2)}% below entry)</p>`;
            content += `<p><strong>Take Profit:</strong> $${(details.take_profit || 0).toFixed(2)} (${((details.take_profit_pct || 0) * 100).toFixed(2)}% above entry)</p>`;
            if (details.trailing_stop_loss) {
                content += `<p><strong>Trailing Stop:</strong> $${(details.trailing_stop_price || 0).toFixed(2)}</p>`;
                content += `<p class="small text-muted">Distance: ${((details.trailing_stop_distance_pct || 0) * 100).toFixed(2)}%, Activation: ${((details.trailing_stop_activation_pct || 0) * 100).toFixed(2)}%</p>`;
            }
        } else {
            // Exit trade
            content += `<p><strong>Entry Price:</strong> $${(details.entry_price || 0).toFixed(2)}</p>`;
            content += `<p><strong>Exit Price:</strong> $${(details.exit_price || 0).toFixed(2)}</p>`;
            content += `<p><strong>P&L:</strong> <span class="${details.pnl_pct >= 0 ? 'text-success' : 'text-danger'}">${(details.pnl_pct || 0).toFixed(2)}%</span></p>`;

            // Trigger info
            if (details.trigger_info) {
                content += `<hr><h6>Exit Reason</h6>`;
                content += `<p><strong>Reason:</strong> ${details.trigger_info.reason || 'N/A'}</p>`;
                if (details.trigger_info.bar_name) {
                    content += `<p><strong>Trigger Bar:</strong> ${details.trigger_info.bar_name}</p>`;
                    content += `<p><strong>Bar Score:</strong> ${(details.trigger_info.bar_score || 0).toFixed(4)} >= ${(details.trigger_info.threshold || 0).toFixed(4)}</p>`;
                }
                if (details.trigger_info.trigger_price) {
                    content += `<p><strong>Trigger Price:</strong> $${(details.trigger_info.trigger_price || 0).toFixed(2)}</p>`;
                }
            }
        }

        // Bar scores at trade time
        if (details.bar_scores && Object.keys(details.bar_scores).length > 0) {
            content += `<hr><h6>Bar Scores at Trade</h6>`;
            content += `<table class="table table-sm table-bordered"><tbody>`;
            for (const [barName, score] of Object.entries(details.bar_scores)) {
                content += `<tr><td>${barName}</td><td>${(score || 0).toFixed(4)}</td></tr>`;
            }
            content += `</tbody></table>`;
        }

        // Indicator values at trade time
        if (details.indicators && Object.keys(details.indicators).length > 0) {
            content += `<hr><h6>Indicator Values at Trade</h6>`;
            content += `<table class="table table-sm table-bordered"><tbody>`;
            for (const [indName, value] of Object.entries(details.indicators)) {
                content += `<tr><td>${indName}</td><td>${(value || 0).toFixed(4)}</td></tr>`;
            }
            content += `</tbody></table>`;
        }

        content += `</div>`;

        // Show in modal
        document.getElementById('tradeDetailsContent').innerHTML = content;
        const modal = new bootstrap.Modal(document.getElementById('tradeDetailsModal'));
        modal.show();
    }

    /**
     * Updates the main candlestick chart when an indicator tab is selected.
     * This ensures the candlestick data matches the indicator's timeframe.
     */
    function updateCandlestickChartForIndicator(indicatorName) {
        console.log(`ðŸ”„ Updating candlestick chart for indicator: ${indicatorName}`);

        // Get the aggregator config for this indicator
        const aggConfig = globalChartData.nameToAggConfig[indicatorName] ||
                          globalChartData.indicatorAggMapping[indicatorName] ||
                          '1m-normal';

        console.log(`   Aggregator config: ${aggConfig}`);

        // Get the candlestick data for this aggregator
        let candlestickData = globalChartData.perAggregatorCandles[aggConfig];

        if (!candlestickData) {
            console.warn(`âš ï¸ No candles found for aggregator '${aggConfig}', keeping current chart`);
            return;
        }

        console.log(`   Using ${candlestickData.length} candles from ${aggConfig}`);

        // Update the main candlestick chart if it exists
        if (charts.candlestick) {
            // Update the chart title to reflect the current timeframe
            charts.candlestick.setTitle({ text: `Price Chart (${aggConfig}) with Trade Background Shading` });

            // Update the candlestick series data
            charts.candlestick.series[0].setData(candlestickData, false);

            // Re-add trade bands using the reusable helper
            addTradeBandsToChart(charts.candlestick, globalChartData.trades);

            // Redraw the chart
            charts.candlestick.redraw();

            console.log(`âœ… Candlestick chart updated with ${aggConfig} data`);
        }

        // Store current indicator for reference
        globalChartData.currentIndicator = indicatorName;
    }

    // Check for data from optimizer in sessionStorage
    async function checkForOptimzerData() {
        const monitorConfigJson = sessionStorage.getItem('replayMonitorConfig');
        const dataConfigJson = sessionStorage.getItem('replayDataConfig');

        if (monitorConfigJson && dataConfigJson) {
            console.log('ðŸ“¥ Received configs from optimizer, loading...');

            try {
                // Ensure indicator classes are loaded first
                if (!indicatorClasses || Object.keys(indicatorClasses).length === 0) {
                    console.log('â³ Waiting for indicator classes to load...');
                    await loadIndicatorClasses();
                }

                // Parse configs
                const receivedConfig = JSON.parse(monitorConfigJson);
                dataConfig = JSON.parse(dataConfigJson);

                // Transform the flat MonitorConfiguration structure to the nested format
                // that renderMonitorConfiguration expects
                monitorConfig = {
                    monitor: {
                        name: receivedConfig.name || '',
                        description: receivedConfig.description || '',
                        trade_executor: receivedConfig.trade_executor || {},
                        bars: receivedConfig.bars || {},
                        enter_long: receivedConfig.enter_long || [],
                        exit_long: receivedConfig.exit_long || []
                    },
                    indicators: receivedConfig.indicators || []
                };

                console.log('ðŸ”„ Transformed monitor config:', monitorConfig);
                console.log('ðŸ“Š Indicator count:', monitorConfig.indicators.length);
                if (monitorConfig.indicators.length > 0) {
                    console.log('ðŸ“Š First indicator:', monitorConfig.indicators[0]);
                    console.log('ðŸ“Š First indicator_class:', monitorConfig.indicators[0].indicator_class);
                }

                // Clear sessionStorage to prevent reloading on refresh
                sessionStorage.removeItem('replayMonitorConfig');
                sessionStorage.removeItem('replayDataConfig');

                // Render configurations
                renderMonitorConfiguration();
                renderDataConfiguration();

                // Show editor and enable run button
                configEditor.style.display = 'block';
                runReplayBtn.disabled = false;

                showAlert('Elite configuration loaded from optimizer!', 'success');

                console.log('âœ… Configurations loaded and rendered');
            } catch (error) {
                console.error('Error loading configs from sessionStorage:', error);
                showAlert('Error loading configuration from optimizer', 'danger');
            }
        }
    }
});
</script>
{% endblock %}