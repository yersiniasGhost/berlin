{% extends "base.html" %}

{% block title %}Replay Visualization{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h2 class="mb-4">
                <i class="fas fa-play-circle me-2"></i>Replay Visualization
            </h2>
        </div>
    </div>
    
    <!-- Configuration Section -->
    <div class="row">
        <div class="col-12">
            {% set file_types = [
                {'key': 'monitor_config', 'title': 'Monitor Configuration', 'description': 'Upload your monitor configuration JSON file'},
                {'key': 'data_config', 'title': 'Data Configuration', 'description': 'Upload your data configuration JSON file'}
            ] %}
            {% include 'components/file_upload.html' %}
        </div>
    </div>
    
    <!-- Configuration Editor -->
    <div class="row">
        <div class="col-12">
            {% set config_tabs = [
                {'key': 'monitor_config', 'title': 'Monitor Config', 'icon': 'fas fa-cogs'},
                {'key': 'data_config', 'title': 'Data Config', 'icon': 'fas fa-database'}
            ] %}
            {% include 'components/config_editor.html' %}
        </div>
    </div>
    
    <!-- Run Button -->
    <div class="row mb-4">
        <div class="col-12 text-center">
            <button type="button" class="btn btn-success btn-lg" id="runReplayBtn" disabled>
                <i class="fas fa-play me-2"></i>Run Replay Visualization
            </button>
        </div>
    </div>
    
    <!-- Results Section -->
    <div class="row" id="resultsSection" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-chart-area me-2"></i>Visualization Results
                    </h5>
                </div>
                <div class="card-body">
                    <!-- Strategy Overview -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <h6>Strategy Overview</h6>
                            <div class="row">
                                <div class="col-md-3">
                                    <strong>Strategy:</strong> <span id="strategyName">-</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Symbol:</strong> <span id="dataTicker">-</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Date Range:</strong> <span id="dateRange">-</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Total Trades:</strong> <span id="totalTrades">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Performance Metrics -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <h6>Performance Metrics</h6>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="totalPnL">-</div>
                                        <small class="text-muted">Total P&L</small>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="avgWin">-</div>
                                        <small class="text-muted">Avg Win</small>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="text-center p-3 border rounded">
                                        <div class="h5 mb-0" id="avgLoss">-</div>
                                        <small class="text-muted">Avg Loss</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Charts and Trade History Side by Side -->
                    <div class="row">
                        <!-- Charts Section (Left Half) -->
                        <div class="col-lg-6">
                            <!-- Stacked Charts Container with shared x-axis -->
                            <div id="stackedChartsContainer">
                                <!-- Chart Container -->
                                <div id="candlestickChart" style="height: 500px; margin-bottom: 5px;"></div>

                                <!-- P&L Chart -->
                                <div id="pnlChart" style="height: 300px; margin-bottom: 5px;"></div>

                                <!-- Tabbed Indicator Charts Container -->
                                <div id="indicatorChartsContainer" style="margin-top: 20px;">
                                    <h6>Indicator Analysis</h6>
                                    <!-- Indicator tabs will be dynamically created here -->
                                    <ul class="nav nav-tabs" id="indicatorTabs" role="tablist"></ul>
                                    <div class="tab-content" id="indicatorTabContent" style="border: 1px solid #dee2e6; border-top: none; padding: 15px;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Trade History Section (Right Half) -->
                        <div class="col-lg-6">
                            <h6>Trade History</h6>
                            <div class="table-responsive" style="max-height: 800px; overflow-y: auto;">
                                <table class="table table-striped table-sm">
                                    <thead class="sticky-top bg-white">
                                        <tr>
                                            <th>Date</th>
                                            <th>Type</th>
                                            <th>Price</th>
                                            <th>Size</th>
                                            <th>P&L</th>
                                            <th>Cumulative P&L</th>
                                            <th>Signal</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tradeHistoryTable">
                                        <tr>
                                            <td colspan="7" class="text-center text-muted">No trades to display</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const runReplayBtn = document.getElementById('runReplayBtn');
    const resultsSection = document.getElementById('resultsSection');
    
    let charts = {};
    
    // Listen for config changes to enable/disable run button
    document.addEventListener('configsReady', function() {
        runReplayBtn.disabled = false;
    });
    
    document.addEventListener('examplesLoaded', function() {
        runReplayBtn.disabled = false;
    });
    
    // Run replay visualization
    runReplayBtn.addEventListener('click', async function() {
        if (!window.currentConfigs || !window.currentConfigs.monitor_config || !window.currentConfigs.data_config) {
            showAlert('Please load both monitor and data configurations first', 'warning');
            return;
        }
        
        try {
            this.disabled = true;
            this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Running Replay...';
            
            const response = await fetch('/replay/api/run_visualization', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    monitor_config: window.currentConfigs.monitor_config,
                    data_config: window.currentConfigs.data_config
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                displayResults(result.data);
                resultsSection.style.display = 'block';
                showAlert('Replay visualization completed successfully', 'success');
            } else {
                throw new Error(result.error || 'Visualization failed');
            }
            
        } catch (error) {
            showAlert(`Failed to run replay: ${error.message}`, 'danger');
        } finally {
            this.disabled = false;
            this.innerHTML = '<i class="fas fa-play me-2"></i>Run Replay Visualization';
        }
    });
    
    function displayResults(data) {
        // Update strategy overview
        document.getElementById('strategyName').textContent = data.monitor_config?.name || 'Unknown';
        document.getElementById('dataTicker').textContent = data.data_config?.ticker || 'Unknown';
        document.getElementById('dateRange').textContent = `${data.data_config?.start_date || 'Unknown'} to ${data.data_config?.end_date || 'Unknown'}`;
        document.getElementById('totalTrades').textContent = data.trades?.length || 0;
        
        // Calculate and display metrics
        if (data.trades && data.trades.length > 0) {
            calculateMetrics(data.trades);
        }
        
        // Create charts
        if (data.candlestick_data) {
            createCandlestickChart(data.candlestick_data, data.trades);
        }
        
        if (data.pnl_data && data.trades && data.candlestick_data) {
            createPnLChart(data.pnl_data, data.trades, data.candlestick_data);
        }

        // Create indicator charts (raw values + triggers)
        if (data.component_history && data.raw_indicator_history && data.indicator_history && data.candlestick_data) {
            createIndicatorCharts(data.component_history, data.raw_indicator_history, data.indicator_history, data.candlestick_data);
        }

        // Populate trade history
        populateTradeHistory(data.trades);
    }
    
    function calculateMetrics(trades) {
        const totalTrades = trades.length;
        let winningTrades = 0;
        let losingTrades = 0;
        let totalWinPnL = 0;
        let totalLossPnL = 0;
        let cumulativePnL = 0;
        
        trades.forEach(trade => {
            if (trade.pnl > 0) {
                winningTrades++;
                totalWinPnL += trade.pnl;
            } else if (trade.pnl < 0) {
                losingTrades++;
                totalLossPnL += Math.abs(trade.pnl);
            }
            
            cumulativePnL += trade.pnl;
        });
        
        const avgWin = winningTrades > 0 ? totalWinPnL / winningTrades : 0;
        const avgLoss = losingTrades > 0 ? totalLossPnL / losingTrades : 0;
        
        // Update UI
        document.getElementById('totalPnL').textContent = `${cumulativePnL.toFixed(2)}%`;
        document.getElementById('avgWin').textContent = `${avgWin.toFixed(2)}%`;
        document.getElementById('avgLoss').textContent = `${avgLoss.toFixed(2)}%`;
        
        // Color coding
        const totalPnLElement = document.getElementById('totalPnL');
        totalPnLElement.className = `h5 mb-0 ${cumulativePnL >= 0 ? 'text-success' : 'text-danger'}`;
    }
    
    function createCandlestickChart(candlestickData, trades) {
        // Prepare trade bands instead of triangular markers
        const chartConfig = {
            chart: {
                height: 500,
                zoomType: 'x',
                panKey: 'shift',
                panning: {
                    enabled: true,
                    type: 'x'
                },
                marginBottom: 10 // Reduce space for x-axis since labels are hidden
            },
            title: { text: 'Price Chart with Trade Background Shading' },
            xAxis: {
                type: 'datetime',
                ordinal: true, // Keep ordinal to remove gaps in candlestick chart
                breaks: [], // Clear any default breaks
                crosshair: true,
                labels: {
                    enabled: false // Hide x-axis labels (shown only on P&L chart)
                },
                lineWidth: 0,
                tickWidth: 0,
                plotBands: [] // Will be populated with trade bands
            },
            yAxis: { 
                title: { text: 'Price' },
                crosshair: true
            },
            series: [
                {
                    name: 'Price',
                    data: candlestickData,
                    type: 'candlestick',
                    color: '#dc3545',
                    upColor: '#28a745'
                }
            ],
            credits: { enabled: false }
        };
        
        if (charts.candlestick) {
            charts.candlestick.destroy();
        }
        charts.candlestick = Highcharts.chart('candlestickChart', chartConfig);
        
        // Clear any existing plot bands before adding new ones
        if (charts.candlestick.xAxis[0].plotLinesAndBands) {
            charts.candlestick.xAxis[0].plotLinesAndBands.slice().forEach(band => {
                if (band.options.className && band.options.className.includes('trade-band')) {
                    band.destroy();
                }
            });
        }

        // Add background shading bands for trades
        if (trades && trades.length > 0) {
            // Group trades by pairs (buy followed by sell)
            const buyTrades = trades.filter(t => t.type === 'buy').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const sellTrades = trades.filter(t => t.type === 'sell').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Create trade pairs and add background bands
            let buyIndex = 0, sellIndex = 0;
            let tradeCount = 0;
            
            while (buyIndex < buyTrades.length && sellIndex < sellTrades.length) {
                const buyTrade = buyTrades[buyIndex];
                const sellTrade = sellTrades[sellIndex];
                
                if (new Date(buyTrade.timestamp) < new Date(sellTrade.timestamp)) {
                    // Calculate P&L for this trade pair
                    const entryPrice = buyTrade.price;
                    const exitPrice = sellTrade.price;
                    const pnl = ((exitPrice - entryPrice) / entryPrice) * 100;
                    const isProfit = pnl > 0;
                    
                    // Use the actual P&L from trade data if available
                    const actualPnl = sellTrade.pnl || pnl;
                    const isActualProfit = actualPnl > 0;
                    
                    const bandColor = isActualProfit ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)';
                    
                    charts.candlestick.xAxis[0].addPlotBand({
                        from: new Date(buyTrade.timestamp).getTime(),
                        to: new Date(sellTrade.timestamp).getTime(),
                        color: bandColor,
                        className: `trade-band trade-${tradeCount}`,
                        id: `trade-band-${tradeCount}`,
                        zIndex: 0, // Behind the candlesticks
                        label: {
                            text: `${isActualProfit ? '+' : ''}${actualPnl.toFixed(2)}%`,
                            align: 'center',
                            verticalAlign: 'middle',
                            style: {
                                color: isActualProfit ? '#28a745' : '#dc3545',
                                fontWeight: 'bold',
                                fontSize: '10px',
                                backgroundColor: 'rgba(255, 255, 255, 0.8)',
                                padding: '2px 4px',
                                borderRadius: '3px'
                            }
                        }
                    });
                    
                    buyIndex++;
                    sellIndex++;
                    tradeCount++;
                } else {
                    sellIndex++;
                }
            }
        }
        
        // Enable synchronization for candlestick chart
        enableChartSynchronization(charts.candlestick);
    }
    
    function createPnLChart(pnlData, trades, candlestickData) {
        // Build P&L data with unrealized gains during open positions
        let adjustedPnlData = [];

        // Get time range from candlestick data
        const candlestickStart = candlestickData[0][0]; // First candlestick timestamp
        const candlestickEnd = candlestickData[candlestickData.length - 1][0]; // Last candlestick timestamp

        if (!trades || trades.length === 0) {
            // If no trades, just show flat line at 0
            adjustedPnlData.push([candlestickStart, 0]);
            adjustedPnlData.push([candlestickEnd, 0]);
        } else {
            // Sort trades by timestamp
            const sortedTrades = [...trades].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const buyTrades = sortedTrades.filter(t => t.type === 'buy');
            const sellTrades = sortedTrades.filter(t => t.type === 'sell');

            // Create a map of candlestick data for quick lookup
            const candlestickMap = new Map();
            candlestickData.forEach(candle => {
                candlestickMap.set(candle[0], candle[4]); // timestamp -> close price
            });

            let cumulativeRealizedPnL = 0;
            let currentPosition = null; // {entryPrice, entryTime, buyIndex}
            let buyIndex = 0;
            let sellIndex = 0;

            // Process each candlestick chronologically
            candlestickData.forEach((candle, idx) => {
                const timestamp = candle[0];
                const closePrice = candle[4];

                // Check if there's a buy trade at this timestamp
                while (buyIndex < buyTrades.length && new Date(buyTrades[buyIndex].timestamp).getTime() <= timestamp) {
                    if (!currentPosition) {
                        currentPosition = {
                            entryPrice: buyTrades[buyIndex].price,
                            entryTime: new Date(buyTrades[buyIndex].timestamp).getTime(),
                            buyIndex: buyIndex
                        };
                        console.log(`ðŸ“Š Position opened at ${new Date(timestamp)}, entry price: ${currentPosition.entryPrice}`);
                    }
                    buyIndex++;
                }

                // Check if there's a sell trade at this timestamp
                while (sellIndex < sellTrades.length && new Date(sellTrades[sellIndex].timestamp).getTime() <= timestamp) {
                    if (currentPosition) {
                        // Close position and add realized P&L
                        cumulativeRealizedPnL += (sellTrades[sellIndex].pnl || 0);
                        console.log(`ðŸ“Š Position closed at ${new Date(timestamp)}, realized P&L: ${sellTrades[sellIndex].pnl}, cumulative: ${cumulativeRealizedPnL}`);
                        currentPosition = null;
                    }
                    sellIndex++;
                }

                // Only add data points when in a position
                if (currentPosition) {
                    // Calculate current P&L (realized + unrealized)
                    const unrealizedPnL = ((closePrice - currentPosition.entryPrice) / currentPosition.entryPrice) * 100;
                    const currentPnL = cumulativeRealizedPnL + unrealizedPnL;
                    adjustedPnlData.push([timestamp, currentPnL]);
                } else {
                    // When no position, only add points at trade exits to maintain flat line
                    if (sellIndex > 0 && adjustedPnlData.length > 0) {
                        // Check if we just closed a position
                        const lastDataPoint = adjustedPnlData[adjustedPnlData.length - 1];
                        if (lastDataPoint[0] < timestamp) {
                            // Add a point to extend the flat line
                            adjustedPnlData.push([timestamp, cumulativeRealizedPnL]);
                        }
                    } else if (adjustedPnlData.length === 0) {
                        // Add initial point at 0 if we haven't started yet
                        adjustedPnlData.push([timestamp, 0]);
                    }
                }
            });
        }

        console.log(`ðŸ“ˆ P&L Chart data points: ${adjustedPnlData.length}, Range: ${new Date(candlestickStart)} to ${new Date(candlestickEnd)}`);

        const chartConfig = {
            chart: {
                type: 'line',
                height: 300,
                zoomType: 'x',
                panKey: 'shift',
                panning: {
                    enabled: true,
                    type: 'x'
                },
                marginBottom: 60 // Extra space for x-axis labels
            },
            title: { text: 'Cumulative P&L Evolution' },
            xAxis: {
                type: 'datetime',
                ordinal: true, // Match candlestick chart - removes gaps for weekends/after hours
                breaks: [],
                crosshair: true,
                labels: {
                    enabled: true // Show x-axis labels (this is the bottom chart)
                },
                lineWidth: 1,
                tickWidth: 1
            },
            yAxis: { 
                title: { text: 'Cumulative P&L (%)' },
                plotLines: [{
                    value: 0,
                    color: '#999',
                    width: 1,
                    dashStyle: 'dash'
                }]
            },
            series: [{
                name: 'Cumulative P&L',
                data: adjustedPnlData,
                color: '#007bff',
                lineWidth: 2
                // Removed step line - now shows continuous unrealized P&L
            }],
            credits: { enabled: false }
        };
        
        if (charts.pnl) {
            charts.pnl.destroy();
        }
        charts.pnl = Highcharts.chart('pnlChart', chartConfig);
        
        // Enable synchronization for P&L chart
        enableChartSynchronization(charts.pnl);
    }
    
    function createIndicatorCharts(componentHistory, rawIndicatorHistory, indicatorHistory, candlestickData) {
        console.log('ðŸ“Š Creating indicator charts');
        console.log('Component history keys:', Object.keys(componentHistory));
        console.log('Raw indicator history keys:', Object.keys(rawIndicatorHistory));
        console.log('Indicator history keys:', Object.keys(indicatorHistory));

        // Get all unique indicator names from raw_indicator_history
        const indicatorNames = Object.keys(rawIndicatorHistory);
        if (indicatorNames.length === 0) {
            console.log('âš ï¸ No indicators found');
            return;
        }

        const tabsContainer = document.getElementById('indicatorTabs');
        const contentContainer = document.getElementById('indicatorTabContent');
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = '';

        // Create a tab for each indicator
        indicatorNames.forEach((indicatorName, index) => {
            const isActive = index === 0;
            const tabId = `indicator-tab-${index}`;
            const contentId = `indicator-content-${index}`;

            // Create tab button
            const tabButton = document.createElement('li');
            tabButton.className = 'nav-item';
            tabButton.innerHTML = `
                <button class="nav-link ${isActive ? 'active' : ''}"
                        id="${tabId}"
                        data-bs-toggle="tab"
                        data-bs-target="#${contentId}"
                        type="button"
                        role="tab">
                    ${indicatorName}
                </button>
            `;
            tabsContainer.appendChild(tabButton);

            // Create tab content
            const tabContent = document.createElement('div');
            tabContent.className = `tab-pane fade ${isActive ? 'show active' : ''}`;
            tabContent.id = contentId;
            tabContent.role = 'tabpanel';

            // Add chart containers for raw values and triggers
            const rawChartId = `rawChart_${indicatorName.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const triggerChartId = `triggerChart_${indicatorName.replace(/[^a-zA-Z0-9]/g, '_')}`;

            tabContent.innerHTML = `
                <div id="${rawChartId}" style="height: 300px; margin-bottom: 10px;"></div>
                <div id="${triggerChartId}" style="height: 200px;"></div>
            `;
            contentContainer.appendChild(tabContent);

            // Create charts after a short delay to ensure DOM is ready
            setTimeout(() => {
                const rawChart = createRawIndicatorChart(indicatorName, componentHistory, candlestickData, rawChartId);
                const triggerChart = createTriggerChart(indicatorName, rawIndicatorHistory, indicatorHistory, triggerChartId);

                // Enable synchronization with all other charts
                if (rawChart) {
                    enableChartSynchronization(rawChart);
                }
                if (triggerChart) {
                    enableChartSynchronization(triggerChart);
                }
            }, 100);
        });
    }

    function createRawIndicatorChart(indicatorName, componentHistory, candlestickData, chartId) {
        // Determine chart type based on indicator name
        const indicatorLower = indicatorName.toLowerCase();

        if (indicatorLower.includes('macd')) {
            return createMACDChart(indicatorName, componentHistory, chartId);
        } else if (indicatorLower.includes('sma') || indicatorLower.includes('ema')) {
            return createSMAChart(indicatorName, componentHistory, candlestickData, chartId);
        } else {
            // Default: line chart for unknown indicator types
            return createGenericIndicatorChart(indicatorName, componentHistory, chartId);
        }
    }

    function createMACDChart(indicatorName, componentHistory, chartId) {
        // Find MACD components for this indicator using the naming convention: {indicator_name}_macd, {indicator_name}_signal, {indicator_name}_histogram
        const macdKey = `${indicatorName}_macd`;
        const signalKey = `${indicatorName}_signal`;
        const histogramKey = `${indicatorName}_histogram`;

        const series = [];
        if (componentHistory[macdKey]) {
            series.push({ name: 'MACD Line', data: componentHistory[macdKey], color: '#2962FF', lineWidth: 2, marker: { enabled: false } });
        }
        if (componentHistory[signalKey]) {
            series.push({ name: 'Signal Line', data: componentHistory[signalKey], color: '#FF6D00', lineWidth: 2, marker: { enabled: false } });
        }
        if (componentHistory[histogramKey]) {
            series.push({
                name: 'Histogram',
                data: componentHistory[histogramKey],
                type: 'column',
                color: '#00897B'
            });
        }

        if (series.length === 0) {
            console.warn(`âš ï¸ No MACD components found for ${indicatorName}`);
        }

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Value' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createSMAChart(indicatorName, componentHistory, candlestickData, chartId) {
        // Find SMA component for this indicator using the naming convention: {indicator_name}_sma
        const smaKey = `${indicatorName}_sma`;

        const series = [
            {
                name: 'Price',
                data: candlestickData,
                type: 'candlestick',
                color: '#dc3545',
                upColor: '#28a745'
            }
        ];

        if (componentHistory[smaKey]) {
            series.push({
                name: indicatorName,
                data: componentHistory[smaKey],
                type: 'line',
                color: '#2962FF',
                lineWidth: 2,
                marker: { enabled: false }
            });
        } else {
            console.warn(`âš ï¸ No SMA component found for ${indicatorName}`);
        }

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values (with Price)`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Price' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createGenericIndicatorChart(indicatorName, componentHistory, chartId) {
        // For unknown indicator types, just plot any matching components
        const matchingKeys = Object.keys(componentHistory).filter(k =>
            k.toLowerCase().includes(indicatorName.toLowerCase())
        );

        const series = matchingKeys.map(key => ({
            name: key,
            data: componentHistory[key],
            lineWidth: 2,
            marker: { enabled: false }
        }));

        const chartConfig = {
            chart: { height: 300, zoomType: 'x' },
            title: { text: `${indicatorName} - Raw Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: false },
                lineWidth: 0,
                tickWidth: 0
            },
            yAxis: { title: { text: 'Value' } },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`raw_${indicatorName}`] = chart;
        return chart;
    }

    function createTriggerChart(indicatorName, rawIndicatorHistory, indicatorHistory, chartId) {
        const series = [];

        // Add time-decayed trigger values (1, 0.9, 0.8, etc.)
        if (indicatorHistory[indicatorName]) {
            series.push({
                name: 'Trigger with Decay',
                data: indicatorHistory[indicatorName],
                color: '#9C27B0',
                lineWidth: 2,
                marker: { enabled: false }
            });
        }

        const chartConfig = {
            chart: { height: 200, zoomType: 'x' },
            title: { text: `${indicatorName} - Trigger Values`, style: { fontSize: '14px' } },
            xAxis: {
                type: 'datetime',
                ordinal: true,
                labels: { enabled: true }
            },
            yAxis: {
                title: { text: 'Trigger Value' },
                min: 0,
                max: 1.1,
                plotLines: [{
                    value: 1,
                    color: '#999',
                    width: 1,
                    dashStyle: 'dash'
                }]
            },
            series: series,
            credits: { enabled: false }
        };

        const chart = Highcharts.chart(chartId, chartConfig);
        charts[`trigger_${indicatorName}`] = chart;
        return chart;
    }

    function enableChartSynchronization(chart) {
        // Enhanced synchronization for stacked charts including scroll zoom
        chart.update({
            chart: {
                events: {
                    selection: function(event) {
                        if (event.xAxis) {
                            const min = event.xAxis[0].min;
                            const max = event.xAxis[0].max;
                            syncAllCharts(min, max, chart);
                        }
                    },
                    load: function() {
                        // Add mouse wheel zoom synchronization and pan support
                        const chartContainer = this.container;

                        // Mouse wheel zoom (works with or without Ctrl/Cmd key)
                        chartContainer.addEventListener('wheel', function(e) {
                            // Only zoom on wheel over chart area, not the entire page
                            if (e.target.closest('.highcharts-container')) {
                                e.preventDefault();
                                e.stopPropagation();

                                // Prevent sync loop
                                if (window.syncInProgress) return;

                                const chart = chartContainer.chart || chartContainer.hcChart || this;
                                if (chart && chart.xAxis && chart.xAxis[0]) {
                                    const xAxis = chart.xAxis[0];
                                    const currentMin = xAxis.min;
                                    const currentMax = xAxis.max;
                                    const range = currentMax - currentMin;

                                    // Smaller zoom factor for smoother zoom
                                    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                                    const newRange = range * zoomFactor;

                                    // Get mouse position relative to chart for zoom center
                                    const rect = chartContainer.getBoundingClientRect();
                                    const mouseX = e.clientX - rect.left;
                                    const plotLeft = chart.plotLeft || 60;
                                    const plotWidth = chart.plotWidth || (rect.width - 120);

                                    // Calculate zoom center based on mouse position
                                    let centerRatio = 0.5; // Default center
                                    if (mouseX >= plotLeft && mouseX <= plotLeft + plotWidth) {
                                        centerRatio = (mouseX - plotLeft) / plotWidth;
                                    }

                                    const center = currentMin + (range * centerRatio);
                                    const newMin = center - (newRange * centerRatio);
                                    const newMax = center + (newRange * (1 - centerRatio));

                                    // Ensure we don't zoom beyond data limits and maintain minimum range
                                    const dataMin = xAxis.getExtremes().dataMin || currentMin;
                                    const dataMax = xAxis.getExtremes().dataMax || currentMax;
                                    const minRange = (dataMax - dataMin) / 1000; // Minimum zoom level

                                    if (newMin >= dataMin && newMax <= dataMax && newRange > minRange) {
                                        console.log('Wheel zoom:', {newMin, newMax, range: newRange});
                                        syncAllCharts(newMin, newMax, chart);
                                    }
                                }
                            }
                        }, { passive: false });

                        // Store reference for cleanup
                        this.syncContainer = chartContainer;
                    }
                }
            },
            xAxis: {
                events: {
                    afterSetExtremes: function(e) {
                        // Only sync if this was a user action (including mouse wheel)
                        if (e.trigger === 'zoom' || e.trigger === 'pan' || e.trigger === 'selection' || e.trigger === 'mousewheel') {
                            syncAllCharts(e.min, e.max, chart);
                        }
                    }
                }
            }
        });
    }

    function syncAllCharts(min, max, sourceChart) {
        // Prevent infinite loops by temporarily disabling sync
        if (window.syncInProgress) return;
        window.syncInProgress = true;

        console.log('Syncing all charts:', {min, max, sourceChart: sourceChart.renderTo?.id || 'unknown'});

        try {
            let syncedCount = 0;
            Object.values(charts).forEach(chart => {
                if (chart !== sourceChart && chart.xAxis && chart.xAxis[0]) {
                    // Use setExtremes with redraw true for immediate visual feedback
                    chart.xAxis[0].setExtremes(min, max, true, false);
                    syncedCount++;
                }
            });
            console.log(`Synced ${syncedCount} charts`);
        } finally {
            // Re-enable sync after a short delay
            setTimeout(() => {
                window.syncInProgress = false;
            }, 50); // Shorter delay for more responsive sync
        }
    }
    
    function populateTradeHistory(trades) {
        const tableBody = document.getElementById('tradeHistoryTable');
        
        if (!trades || trades.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No trades to display</td></tr>';
            return;
        }
        
        let cumulativePnL = 0;
        const rows = trades.map(trade => {
            cumulativePnL += trade.pnl || 0;
            const pnlClass = (trade.pnl || 0) > 0 ? 'text-success' : ((trade.pnl || 0) < 0 ? 'text-danger' : '');
            const cumPnLClass = cumulativePnL >= 0 ? 'text-success' : 'text-danger';
            
            return `
                <tr>
                    <td>${new Date(trade.timestamp).toLocaleDateString()}</td>
                    <td><span class="badge bg-${trade.type === 'buy' ? 'success' : 'danger'}">${trade.type}</span></td>
                    <td>$${(trade.price || 0).toFixed(2)}</td>
                    <td>${trade.size || 0}</td>
                    <td class="${pnlClass}">${(trade.pnl || 0).toFixed(2)}%</td>
                    <td class="${cumPnLClass}">${cumulativePnL.toFixed(2)}%</td>
                    <td class="small">${trade.reason || '-'}</td>
                </tr>
            `;
        }).join('');
        
        tableBody.innerHTML = rows;
    }
});
</script>
{% endblock %}